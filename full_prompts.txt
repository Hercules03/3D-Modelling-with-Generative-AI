

================================================================================
PROMPT FOR: I want a camera
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: unknown_65b1e79a
                Score: 0.543
                Description: I want a camera lens
                Code:
                ```scad
                // Camera Lens Model
// Author: OpenSCAD Expert
// Description: A parametric DSLR camera lens with realistic details

// Main parameters
lens_diameter = 70;      // Outer diameter of the lens barrel
lens_length = 100;       // Total length of the lens
mount_diameter = 65;     // Diameter of the lens mount
front_element_diameter = 58; // Diameter of the front glass element
focus_ring_width = 25;   // Width of the focus ring
focus_ring_depth = 3;    // Depth of the knurling on the focus ring
aperture_ring_width = 15; // Width of the aperture ring
aperture_ring_depth = 2; // Depth of the knurling on the aperture ring
knurl_count = 60;        // Number of knurls around the rings

// Colors
color_barrel = [0.2, 0.2, 0.2];    // Black lens barrel
color_ring = [0.25, 0.25, 0.25];   // Dark gray rings
color_glass = [0.8, 0.9, 0.95, 0.6]; // Slightly blue transparent glass
color_mount = [0.3, 0.3, 0.3];     // Dark gray mount
color_red = [0.8, 0.2, 0.2];       // Red accent color for lens markings

// Module for creating the lens barrel
module lens_barrel() {
    color(color_barrel)
    difference() {
        cylinder(h=lens_length, d=lens_diameter, $fn=100);
        translate([0, 0, -1])
            cylinder(h=lens_length+2, d=lens_diameter-4, $fn=100);
    }
}

// Module for lens glass elements
module lens_element(diameter, curvature, thickness) {
    color(color_glass)
    translate([0, 0, 0])
    union() {
        // Main cylindrical part of the element
        cylinder(h=thickness, d=diameter, $fn=100);
        
        // Convex front part
        translate([0, 0, thickness])
            scale([1, 1, curvature])
            sphere(d=diameter, $fn=100);
    }
}

// Module for creating knurled rings (focus and aperture)
module knurled_ring(diameter, width, depth, knurls) {
    color(color_ring)
    difference() {
        cylinder(h=width, d=diameter, $fn=100);
        
        // Create the knurling pattern
        for(i = [0 : knurls - 1]) {
            rotate([0, 0, i * (360 / knurls)])
            translate([diameter/2 - depth/2, 0, -1])
            rotate([0, 0, 45])
            cube([depth, depth, width+2]);
        }
        
        // Hollow out the inside
        translate([0, 0, -1])
            cylinder(h=width+2, d=diameter-8, $fn=100);
    }
}

// Module for lens mount (bayonet style)
module lens_mount() {
    color(color_mount)
    difference() {
        cylinder(h=10, d=mount_diameter, $fn=100);
        
        // Hollow out the inside
        translate([0, 0, -1])
            cylinder(h=12, d=mount_diameter-8, $fn=100);
        
        // Create bayonet notches
        for(i = [0 : 2]) {
            rotate([0, 0, i * 120])
            translate([mount_diameter/2 - 4, 0, 5])
            cube([10, 8, 5], center=true);
        }
    }
    
    // Add mounting pins
    for(i = [0 : 2]) {
        rotate([0, 0, i * 120 + 60])
        translate([mount_diameter/2 - 5, 0, 3])
        rotate([90, 0, 0])
        cylinder(h=3, d=4, center=true, $fn=20);
    }
}

// Module for front lens cap
module lens_cap() {
    color([0.15, 0.15, 0.15])
    difference() {
        union() {
            cylinder(h=3, d=lens_diameter+2, $fn=100);
            cylinder(h=8, d=front_element_diameter+6, $fn=100);
        }
        
        translate([0, 0, -1])
            cylinder(h=10, d=front_element_diameter+2, $fn=100);
    }
}

// Module for branding details
module branding() {
    // Red dot (brand logo)
    color(color_red)
    translate([lens_diameter/2 - 1.5, 0, lens_length - 15])
    rotate([0, 90, 0])
    cylinder(h=3, d=5, $fn=20);
    
    // Lens markings (simplified)
    color([0.9, 0.9, 0.9])
    for(i = [0 : 5]) {
        rotate([0, 0, i * 60])
        translate([lens_diameter/2 - 0.5, 0, lens_length - focus_ring_width - 10])
        cube([1, 1, 3]);
    }
}

// Module for aperture label
module aperture_label() {
    color([0.9, 0.9, 0.9])
    for(i = [0 : 4]) {
        angle = i * 20;
        rotate([0, 0, angle])
        translate([lens_diameter/2 - 0.5, 0, 50])
        cube([1, 1.5, 2]);
        
        // f-numbers
        rotate([0, 0, angle + 10])
        translate([lens_diameter/2 - 0.5, 0, 50])
        cube([1, 0.5, 2]);
    }
}

// Assemble the complete lens
module camera_lens() {
    // Main components
    lens_barrel();
    
    // Front glass element
    translate([0, 0, lens_length - 5])
        lens_element(front_element_diameter, 0.2, 3);
    
    // Secondary glass element
    translate([0, 0, lens_length - 20])
        lens_element(front_element_diameter - 10, -0.15, 2);
    
    // Focus ring
    translate([0, 0, lens_length - focus_ring_width - 20])
        knurled_ring(lens_diameter, focus_ring_width, focus_ring_depth, knurl_count);
    
    // Aperture ring
    translate([0, 0, lens_length - focus_ring_width - aperture_ring_width - 25])
        knurled_ring(lens_diameter - 5, aperture_ring_width, aperture_ring_depth, knurl_count);
    
    // Lens mount at the back
    translate([0, 0, 0])
        lens_mount();
    
    // Branding and labels
    branding();
    aperture_label();
}

// Render the lens
camera_lens();

// Uncomment to show the lens cap
// translate([0, 0, lens_length])
//     lens_cap();
                ```
                

                Example ID: modular_099c3391
                Score: 0.468
                Description: A frame of drone with 4 arms
                Code:
                ```scad
                // Globals

motorDiameter = 16;
motorLength   = 40;

baseLength    = 180;
baseWidth     = 100;
baseThick     = 3;
ridgeThick    = 5;

droneColor    = [0, .75, 0, 1]; // Green
    
armLength     = 160;
armWidth      = 30;
armXOffset    = 20;
armYOffset    = 70;
armAngle      = 20;
armRidgeShort = 44;

legHeight     = 30;
// Run

main();

// Code

module main() {
    union() {
        color(droneColor) {

            base();
            // Arms
            arm(armLength, armWidth, armXOffset, armYOffset, armAngle);
            arm(armLength, armWidth, armXOffset, -armYOffset, -armAngle);
            arm(armLength, armWidth, -armXOffset, armYOffset, 180 - armAngle);
            arm(armLength, armWidth, -armXOffset, -armYOffset, 180 + armAngle);

        }    
    }
}

module base() 
{
    
//    arm(armLength, armWidth, 0, 0, 0);
/**/
    union(){
        difference() {
            // Base
            cube(
                [baseWidth, baseLength, baseThick],
                center = true
            );

            // Leg hole
            translate([baseWidth/2 - 12, baseLength/2  - motorDiameter - 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };

            // Leg hole
            translate([-baseWidth/2 + 12, baseLength/2 - motorDiameter - 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };

            // Leg hole
            translate([baseWidth/2 - 12, -baseLength/2  + motorDiameter + 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };
            
            // Leg hole
            translate([-baseWidth/2 + 12, -baseLength/2  + motorDiameter + 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };
            
            // Cable Hole
            translate([0, baseLength/2 - 20, 0]){
                cylinder(motorLength, motorDiameter/2, motorDiameter/2, center = true);
            };

        }
        
        // Stiffeners 
        translate([0, baseLength/2 - 8, ridgeThick/2]) {
            cube([baseWidth, ridgeThick, ridgeThick], center = true);
        }
        translate([0, -baseLength/2 + 8, ridgeThick/2]) {
            cube([baseWidth, ridgeThick, ridgeThick], center = true);
        }

        translate([baseWidth/2-4, 0, ridgeThick/2]) {
            cube([ridgeThick, baseLength - 8, ridgeThick], center = true);
        }
        translate([-baseWidth/2+4, 0, ridgeThick/2]) {
            cube([ridgeThick, baseLength - 8, ridgeThick], center = true);
        }
            
    
    }
/**/
}

module arm(len, wid, x, y, deg) 
{
    union() {
        translate([cos(deg)*len/2 + x, sin(deg)*len/2 + y, 0]) {
            rotate(deg) {
                union() {
                    
                    // Plate with hole
                    difference() {
                        cube(
                            [len, wid, baseThick],
                            center = true
                        );
                        translate([len/2 - motorDiameter, 0, 0]){
                            cylinder(motorLength, motorDiameter/2, motorDiameter/2, center = true);
                        };
                    }

                    
                    translate([-1.2*motorDiameter+2, 0, baseThick]) {
                        union() {
                            // Motor Support
                            translate([(len-motorDiameter)/2 - motorLength/2, 0, (motorLength*.75)/2-2]) {
                                difference() {
                                    cube ([motorLength, ridgeThick*2, motorLength*.75], center = true);
                                    translate([motorLength-motorDiameter*1.7, 0, -motorLength*.1]){
                                        rotate([90,0,0]) {
                                            cylinder(50, motorDiameter/4, motorDiameter/4, center = true);
                                        }
                                    };
                                    translate([motorLength-motorDiameter*1.7, 0, motorLength*.2]){
                                        rotate([90,0,0]) {
                                            cylinder(50, motorDiameter/4, motorDiameter/4, center = true);
                                        }
                                    };
                                    
                                }
                            }
                            // Plate Stiffner
                            cube ([len-motorDiameter*2 - armRidgeShort, ridgeThick, ridgeThick], center = true);
                        }
                    }

                }
            }
        }
    }
    
}
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Accuracy to physical camera dimensions and proportionality
- Functional design respecting working mechanical components
- Surface detail hierarchy (primary shapes first, details later)
- Material properties consideration (reflective lens, textured grip areas)
- Polygon efficiency balanced with visual fidelity
- Topology optimization for animation/deformation where needed
- Reference-based modeling for authenticity
- Code Structure: module structure
- Code Structure: algorithms for surface details
- Code Structure: material slots
- Implementation Technique: mirror
- Implementation Technique: minkowski
- Implementation Technique: union
- Implementation Technique: pattern
- Implementation Technique: rotate
- Implementation Technique: extrude
- Implementation Technique: difference
- Implementation Technique: scale
                    
                    SHAPE COMPONENTS:
                    - Main camera body (rectangular prism with rounded edges)
- Lens assembly (cylindrical with internal elements)
- Viewfinder section (raised rectangular element)
- LCD screen (flat recessed rectangle)
- Control buttons and dials (small geometric extrusions)
- Battery compartment (defined cutout section)
- Memory card slot (subtle indentation)
- Flash assembly (raised geometric shape)
- Hand grip contour (ergonomic curved surface)
- Strap attachment points (small loop structures)
                    
                    IMPLEMENTATION STEPS:
                    1. Reference gathering (photos, technical diagrams, measurements)
2. Block-out basic shapes with primitive geometry
3. Define primary form silhouette and major proportions
4. Refine primary surfaces with proper edge flow
5. Model lens assembly with appropriate detail level
6. Add secondary geometric details (buttons, ports, dials)
7. Create recessed areas (screen, compartments)
8. Establish proper topology for smooth surfaces
9. Add surface details (texture patterns, logos, text)
10. Optimize mesh density across different areas based on visibility
11. Set up UV coordinates for texturing
12. Apply appropriate smoothing groups/edge hardness
13. Create material slots for different camera components
14. Perform final proportion and accuracy check against references

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "mechanical" type. Here's a suggested structure:
                
                ```scad
                
        module camera(height=10, width=20, depth=15, wall_thickness=2) {
            union() {
                // Base shape based on: Main camera body (rectangular prism with rounded edges), Lens assembly (cylindrical with internal elements), Viewfinder section (raised rectangular element), LCD screen (flat recessed rectangle), Control buttons and dials (small geometric extrusions), Battery compartment (defined cutout section), Memory card slot (subtle indentation), Flash assembly (raised geometric shape), Hand grip contour (ergonomic curved surface), Strap attachment points (small loop structures)
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
body_width = 130; // Width of the camera body in mm
body_height = 90; // Height of the camera body in mm
body_depth = 80; // Depth of the camera body in mm
lens_diameter = 42; // Diameter of the main lens assembly in mm
lens_length = 100; // Total length of the lens in mm
grip_depth = 30; // Depth of the camera grip in mm
body_color = [0.2, 0.2, 0.2]; // Color of the camera body as RGB values
has_viewfinder = true; // Whether to include a viewfinder on top of the camera
body_dimensions = [120, 80, 45]; // Main camera body dimensions [width, height, depth] in mm
body_corner_radius = 5; // Radius of rounded corners on camera body in mm
lens_extension = 30; // How far the lens extends from the camera body in mm
viewfinder_dimensions = [30, 20, 15]; // Viewfinder dimensions [width, height, depth] in mm
detail_level = 2; // Level of detail (1-3): 1=basic shapes only, 2=medium detail, 3=high detail


USER REQUEST:
camera digital

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a frame of a drone please
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: modular_e755671c
                Score: 0.811
                Description: A frame for a foldable nano drone
                Code:
                ```scad
                // Select object to show / print
show = "all" ; 

// Show additional electronic components
ghosts = 0 ; // [0:w/o electronic parts, 1:With ghost components]

// Select flight controller footprint
FC_footprint = "31x31" ; // ["31x31":Naze32 30.5x30.5mm, "45x45":MultiWii 45x45mm, "none":No footprint]

/* [Frame Dimensions] */
// Frame Basic Length
Quad_L = 90 ;	// [80:150]

// Frame Basic Width
Quad_B = 70 ;	 // [65:100]

// Boom Flight Position Angle
Quad_W = 50 ; // [45:65]

// Jeti RSAT antenna holder on top
ant_holder = 1 ; // [0:w/o antenna holder, 1:with antenna holder]

// Cover dome on top
top_cover = 1 ; // [0:w/o top cover, 1:with top cover]

// Height of 4 Flight Controller screw domes
Dome_H = 6 ;  // [3:0.5:10]

// Geometry of Flight Position Stoppers 
StopperFill = 1 ; // [0:No fill-only stopper blades, 1:Side blades filled]

/* [Boom Dimensions] */
// Motor type
motor_type = "hk1811sup" ; // ["hk1811sup":HK1811 with support, "hk1811":HK1811 without support, "bx1306":BX1306]

// Height of rotor bell
H_Rotor = 7.5 ; // [7.5:7.5 for HK1811 Motor, 10.0:10 Low for BX1306, 12.0:12 High for BX1306]

// Inner radius of motor holder around rotor bell
R_Rotor = 9.7 ; // [9.7:9.7 for HK1811 Motor, 10.0:10.0 for BX1306 Motor]

// Length of boom tube (to motor center, 5" prop: 85, 4" prop: 75) 
L_Arm = 85 ; // [60:120]

// Outer Radius of Boom Cylinder
R_Arm = 4.5 ; // [4.0:0.1:5.0]

// Wall thickness of boom tube
Wall_Arm = 0.9 ; // [0.7:0.1:1.2]

// Ovality factor of boom (H to W ratio in %)
Q_Arm   = 105 ; // [90:120]

// Chamfers at BX1306 motor fixing holes
Hole_chamfers = 1 ; // [0:No chamfers, 1:Chamfers]

// Wall thickness around rotor bell
Wall_Rotor = 1.2 ; // [0.9:0.1:1.5]

// Wall thickness at motor holder socket
Wall_Sockel = 1.5 ; 

/* [Leg dimensions] */
// Wideness of leg
 W_leg = 8.5 ; // [7.5:0.1:12]

// Material thickness of leg
H_leg = 3.2 ; // [2.5:0.1:4.0]

// Length extension of leg
 L_leg = 0 ;  // [0:15] 
 
// Use stop nuts or cut thread yourself
legeco = 0 ; // [1:Thread core hole, 0:M3 stop nut hole]

/* [Top cover  parameters] */
// Cover dome height
h_dome = 7; // [4:15]

// Dome cylinder radius
radome = 3.0 ; // [2:0.1:3.8]

// Border frame height
kragen = 1.5 ; // [1:0.1:3]

/* [Further internal parameters] */
// Height of chamfer below
H_Rotfase = 1 ;				
// Height of cone at lower side of motor holder
H_Rotkegel = 3 ;				
// Motor flange radius 1
R_hold1 = 4.5 ;				
// Motor flange radius 2
R_hold2 = 6 ;
// Motor flange height
H_hold = 8.8 ;				
// Lower flange outside radius (for stiff motor fixing)
R_Naussen = 5.2 ;
// Hole radius for "simple holder"
R_Nabe = 3.0 ;
// Position of M2.5 Motor fixing thread
MFix_z = 2.0 ; // [1.5:0.1:2.5]
// Radius cable channel inside boom
R_cable = 2.9;				
// Propeller Diameter (5"=127, 4"=102, 3"=76)
D_prop = 126 ; // [76:152]
// Hinge length
L_Hinge  = 20; // [18:22]		
// Hinge width
B_Hinge  = 14 ; // [12:16]	
// M3-Screw hole radius
R_Screw = 1.53 ;	 // [1.4:0.05:1.65]
// M3-Screw thread core hole
R_M3core = 1.2 ;
// axial length of chamfer hinge -> boom tube
H_HFase = 3.54 ;				
// axial backstand of internal bar in hinge
stegbak  = 1.0 ;				
// axial length of nose bar in hinge
stegovl  = 5 ;				
// Plate size reduction towards "mickey ears"
Quad_red = 11 ;	
// Thickness of lower frame plate
Quad_H = 1.6;	 // [1.3:0.1:2.0]
// Distance of Arm-End to Frame-Outline
Armbord = 18 ; // [15:18]
// Radius of Mickey Ears 
Quadmic_R = 18.0 ; // [17:20]
// Side walls thickness in lower frame
LowerWall = 1.4 ; // [1.0:0.1:2.0]
// Gap between lower side wall and upper frame
LowerSlot = 0.2 ;	 // [0.15:0.05:0.25]	
// Width of flight position stopper 
StopperWall = 1.6 ; // [1.3:0.1:2.0]
// Gap of flight position stopper to boom
StopperGap = 0.4 ; // [0.1:0.1:0.6]
// Height of storage position stopper 
Stopper_H = 3 ;  // [2.0:0.1:4.0]
// Height of strengthening X-dir bars around FC
QXbar_H = Dome_H*0.65 ; 
// Height of strengthening Y-dir bars around FC (w space for RX)
QYbar_H = 0.5 ;				
// Antenna hole radius
r_antenna = 1.2 ; // [1.2:0.1:1.5]

module arm_1811(support)
{
    // Hollow motor holder
    difference() {
       union() {
          translate ([0,0,H_Rotfase]) 
			cylinder (r=R_Rotor+Wall_Rotor, h=H_Rotor+Wall_Sockel-H_Rotfase, $fn=60) ;

	    // Cone below rotor bell
          translate ([0,0,-H_Rotkegel/2-H_Rotfase/2]) 
          		cylinder (r2=R_Rotor+Wall_Rotor, r1=R_Naussen, h=H_Rotkegel, $fn=40) ;

          // Flange tube holder with chamfer
          translate ([0,0,-H_hold]) cylinder (r1=R_Naussen, r2=R_Naussen+1, h=H_hold-H_Rotfase, $fn=40) ;
          translate ([0,0,-H_hold-1]) cylinder (r1=R_Naussen-1, r2=R_Naussen, h=1, $fn=40) ;

	    // Cylinder for flange fix screws
          translate ([0,0,-H_hold/2+MFix_z]) rotate ([90,0,0]) scale ([1.4,1,1]) cylinder (r=2.3, h=2*R_Naussen+3, $fn=20, center=true) ;  

          // Oval boom
          scale ([1,Q_Arm/100,1]) translate ([0,0,R_Arm]) rotate ([0,90,0]) cylinder (r=R_Arm, h=L_Arm, $fn=40) ;

          // Hinge block
          translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;

          // Chamfer between hinge and boom
          hull() {
             translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;
             scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge-H_HFase,0,R_Arm]) rotate ([0,90,0]) 
			cylinder (r=R_Arm, h=0.1, center=true, $fn=30) ;          
          }

	     // Cable tube below motor holder (outside)
         translate ([9.5,0,+0.2]) rotate ([0,-110,0]) scale ([1.1,1.33*Q_Arm/112,1]) cylinder (r = R_cable+0.9, h=24, $fn=40, center=true) ;
       }
      
       translate ([0,0,Wall_Sockel]) cylinder (r=R_Rotor, h=H_Rotor+0.05, $fn=40) ;			// Around rotor 
       translate ([0,0,-1.85]) cylinder (r2=R_Rotor, r1=R_Nabe-2, h=3.4, $fn=40) ;			// Below rotor, conic hole
       cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								// flange hole

       scale ([1,Q_Arm/100,1]) translate ([R_Rotor+Wall_Arm,0,R_Arm]) rotate ([0,90,0]) 			// boom tube hollow with end cap
			cylinder (r=R_Arm-Wall_Arm, h=L_Arm+0.1, $fn=30) ;

      // Cable tube at rotor, rotated part (inside)
      translate ([12.7,0,+0.0]) rotate ([0,-110,0]) scale ([0.72,1.2,1]) cylinder (r = R_cable, h=18, $fn=20, center=true) ;
	 // Cable tube, horizontal part
      translate ([6,0,-0.0]) rotate ([0,91,0]) scale ([0.8,1.3,1]) cylinder (r = 2.2, h=9.5, $fn=20, center=true) ;
      translate ([6.8,0,-0.6]) rotate ([0,91,0]) scale ([1.0,1.3,1]) cylinder (r = 2.2, h=6, $fn=20, center=true) ;

	// Hole for motor fixing screws M2.5
      translate ([0,0,-H_hold/2+MFix_z]) rotate ([90,0,0]) cylinder (r = 0.7, h=30, $fn=20, center=true) ;

	 // 50% wider hole in boom within hinge block, with chamfer
       hull() {
         scale ([1,1.50*Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2+stegbak,0,R_Arm]) rotate ([0,90,0])
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
         scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2-H_HFase/3-1.6,0,R_Arm]) rotate ([0,90,0]) 	
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
       }

       // M3 holes in hinge
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
    
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;

	 // 4 Chamfers at hinge block
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 2*R_Arm]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 2*R_Arm]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 0]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 0]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;    

       // Cylindrical cutout at hinge base for less cable movement when folding
       translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
    }

    // Vertical bar with screw holes in hinge block
   difference() { 
     hull() {
       translate ([L_Arm-L_Hinge/2+stegbak/2, 0, R_Arm]) cube ([L_Hinge-stegbak, 1+2*R_Screw, 2*R_Arm-0.5], center=true) ;
       translate ([L_Arm-L_Hinge/2-stegovl, 0, R_Arm]) cube ([L_Hinge, 0.5, 2*R_Arm-0.5], center=true) ;
     }

     // Again 4 M3 screw holes incl chamfers
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
  } 

  // Strengthening tube in motor dome (only possible together with support tube)
  if (support == 1) 
  {
    difference() { 
       union() {
         translate ([0,0,-1.5]) cylinder (r=R_Nabe+1.5, h=2, $fn=30) ;		    // Strenghtening tube
         translate ([0,0,-0.5]) cylinder (r1=R_Nabe+3, r2=R_Nabe+1.0, h=2, $fn=30) ;  // chamfer
       }
       cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								    // Flange hole
       translate ([R_Nabe+1.4,0,0]) scale ([1.3,0.95,1]) cylinder (r=R_cable, h=10, center=true, $fn=30) ;	            // Cable hole
    } // difference 

    // Support-tube in motor dome (can be broken away after print)
    difference() { 
        translate ([0,0,1]) cylinder (r=R_Nabe+0.8, h=H_Rotor+Wall_Sockel-1, $fn=30) ;	// Thin tube
        cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								        // Flange hole
        translate ([0,0,0.3]) rotate ([0,0,30]) cube ([10,2.5,4], center = true) ;				// 3 x 2 cutouts
	    translate ([0,0,0.3]) rotate ([0,0,90]) cube ([10,2.5,4], center = true) ;		
	    translate ([0,0,0.3]) rotate ([0,0,150]) cube ([10,2.5,4], center = true) ;
    } // difference

  } // if
}

module arm_bx1306()
{
    // Hollow Boom
    difference() {
       union() {
          translate ([0,0,H_Rotfase]) 
			 cylinder (r=R_Rotor+Wall_Rotor, h=H_Rotor+Wall_Sockel-H_Rotfase, $fn=60) ;
          translate ([0,0,H_Rotfase+H_Rotor+0.5]) 
			 cylinder (r1=R_Rotor+Wall_Rotor, r2=R_Rotor+Wall_Rotor-0.6, h=0.6, $fn=60) ;
          cylinder (r1=R_Rotor+Wall_Rotor-H_Rotfase, r2=R_Rotor+Wall_Rotor, h=H_Rotfase, $fn=50) ;
 
          // Strengthening fin between boom and motor dome
          hull() {
              translate ([R_Rotor,0,H_Rotor+1]) rotate ([0,90+36,0]) cylinder (r=0.8, h=10, $fn=10) ;
              translate ([R_Rotor,0,3]) rotate ([0,90,0]) cylinder (r=1.5, h=10, $fn=10) ;
          }
           
          // Oval boom tube
         scale ([1,Q_Arm/100,1]) translate ([0,0,R_Arm]) rotate ([0,90,0]) cylinder (r=R_Arm, h=L_Arm, $fn=40) ;

          // Hinge block
          translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;

          // Chamfer between hinge and boom
          hull() {
             translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;
             scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge-H_HFase,0,R_Arm]) rotate ([0,90,0]) 
			cylinder (r=R_Arm, h=0.1, center=true, $fn=30) ;          
          } // hull
       } // union
      
       translate ([0,0,Wall_Sockel]) cylinder (r=R_Rotor, h=H_Rotor+1.01, $fn=30) ;		// rotor hole
       translate ([0,0,0.5]) cylinder (r=5.5/2, h=2, $fn=30) ;	                                    // center groove
       scale ([1,Q_Arm/100,1]) translate ([8,0,R_Arm]) rotate ([0,90,0]) 						    // tube boom hole
			cylinder (r=R_Arm-Wall_Arm, h=L_Arm+0.1, $fn=30) ;
       scale ([1,Q_Arm/100,1]) translate ([8-6+0.1,0,R_Arm]) rotate ([0,90,0]) 					// tube boom hole
			cylinder (r2=R_Arm-Wall_Arm, r1=R_Arm-Wall_Arm-1.5, h=6, $fn=30) ;

       // 4 holes in boom bottom for fixing screws, with optional chamfers
       for (i= [0:3]) {
           assign (rot = i*90) rotate ([0,0,45+rot]) 
           {
             translate ([12/2, 0, -1]) cylinder (r=2.3/2, h=10, $fn=20) ;                         // hole
             if (Hole_chamfers == 1)
                 translate ([12/2, 0, -0.1]) cylinder (r2=2.3/2, r1=2.3/2+1, h=1, $fn=20) ;     // chamfer
           } // rotate
       } // for

	 // 50% wider hole in hinge block
       hull() {
         scale ([1,1.50*Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2+stegbak,0,R_Arm]) rotate ([0,90,0])
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
         scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2-H_HFase/3,0,R_Arm]) rotate ([0,90,0]) 	
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
       }

       // M3 holes
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

       // M3 chamfers
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;

	 // 4 Hinge chamfers
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 2*R_Arm]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 2*R_Arm]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 0]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 0]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       
       // Cylindrical cutout at hinge base for less cable movement when folding
       translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
    }

    // Vertical bar in hinge block
   difference() { 
     hull() {
       translate ([L_Arm-L_Hinge/2+stegbak/2, 0, R_Arm]) cube ([L_Hinge-stegbak, 1+2*R_Screw, 2*R_Arm-0.5], center=true) ;
       translate ([L_Arm-L_Hinge/2-stegovl, 0, R_Arm]) cube ([L_Hinge, 0.5, 2*R_Arm-0.5], center=true) ;
     }

     // Again M3 holes incl chamfers
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     
       // Again cylindrical cutout at hinge base for less cable movement
      translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
  }
}

module boom()
{
   if (motor_type == "hk1811sup") arm_1811(1) ;
   if (motor_type == "hk1811") arm_1811(0) ;
   if (motor_type == "bx1306") arm_bx1306() ;
}

module armslots(startw, endw)
{
      cylinder (r=R_Screw, h=20, center=true, $fn=20) ;									// anchor point
   
      for (angle = [startw : 10 : endw-10])												// Long hole
      {
          hull() {
             rotate ([0,0,angle]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
             rotate ([0,0,angle+10]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
          }
      }

      hull() {																			// Rest in long hole...
          rotate ([0,0,endw]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
          rotate ([0,0,endw-10]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
      }
}

module roundcube (x, y, z, rad)
{
    hull() {
      translate ([-x/2+rad, -y/2+rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([-x/2+rad, y/2-rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([x/2-rad, -y/2+rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([x/2-rad, y/2-rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
    }
}

module frame_basis()
{
    difference()
    {
        union()
        {
             cube ([Quad_L-Quad_red, Quad_B-Quad_red, Quad_H], center=true) ;
             translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
         } // union
         
         // 4 slot footprints for the arms
         translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) rotate ([0,0,-90]) armslots (0, Quad_W) ;
         translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) rotate ([0,0,90-Quad_W]) armslots (0, Quad_W) ;
          translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) rotate ([0,0,-90-Quad_W]) armslots (0, Quad_W) ;
         translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) rotate ([0,0,90]) armslots (0, Quad_W) ;
   } // diff
}

module frame_lower()
{
    difference ()
    {
      frame_basis() ;

	 // Cooling / weight reduction holes in the middle under the ESC's
      hull() {
          translate ([ 45/2-16, Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }

      translate ([24,0,0]) cylinder (r=7, h=10, $fn=20, center=true) ;			// weight red holes between arms
      translate ([-24,0,0]) cylinder (r=7, h=10, $fn=20, center=true) ;
    }

   // Battery rubber bolts with 2 sided chamfers
   translate ([20,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r=1.5, h=9, $fn=20, center=true);
   translate ([20+9/2+1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r1=1.5, r2=0.8, h=1.4, $fn=20, center=true);
   translate ([20-9/2-1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r2=1.5, r1=0.8, h=1.4, $fn=20, center=true);
   translate ([-20,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r=1.5, h=9, $fn=20, center=true);
   translate ([-20+9/2+1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r1=1.5, r2=0.8, h=1.4, $fn=20, center=true);
   translate ([-20-9/2-1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r2=1.5, r1=0.8, h=1.4, $fn=20, center=true);

   // Side walls 
   difference ()
   {
     union()
     {
         translate ([0,(Quad_B-Quad_red-LowerWall)/2, Quad_H/2+R_Arm-LowerSlot/2]) 
            cube ([Quad_L-36, LowerWall, 2*R_Arm-LowerSlot], center=true) ;
        translate ([0,-(Quad_B-Quad_red-LowerWall)/2, Quad_H/2+R_Arm-LowerSlot/2]) 
            cube ([Quad_L-36, LowerWall, 2*R_Arm-LowerSlot], center=true) ;
     }

    // Subtract Arms stopper plates for flight position
    translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-180+Quad_W]) translate ([-9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-Quad_W]) translate ([9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,+Quad_W]) translate ([-9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-Quad_W]) translate ([-9, B_Hinge/2-10+StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
   }

   // Flight position Stopper blades cylindrical fill?
   // Create these as intersection of mickey ears with stopper blade hull of one side
   if (StopperFill > 0)
   {
       clen = 12.5 - (Quad_W - 55)/10 ;      // correction of stopper length

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-180+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
                translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-Quad_W]) translate ([-15, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // difference
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-180+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
                translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-Quad_W]) translate ([-15, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,-Quad_W]) translate ([15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,-Quad_W]) translate ([15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection
   } // if 

    // Big wall in the middle with extension to the battery rubber bolts
   translate ([0,0, Quad_H/2]) rotate ([45, 0, 0]) cube ([40, 1.8, 1.8], center=true) ;	// socket chamfer
    hull () {
       translate ([0,0, Quad_H/2+R_Arm-LowerSlot/2]) cube ([22, 1.1, 2*R_Arm-LowerSlot], center=true) ;
       translate ([0,0, Quad_H/2+3/2]) cube ([40, 1.4, 2], center=true) ;
    }

   // Two lower inner walls / bars only for ESC fixation
  translate ([0,Quad_B/4.8, Quad_H/2]) rotate ([45, 0, 0]) cube ([30, 1.8, 1.8], center=true) ;	// socket chamfer
   hull () {
      translate ([0,Quad_B/4.8, Quad_H/2+2/2]) cube ([30, 1.3, 2], center=true) ;
      translate ([0,Quad_B/4.8, Quad_H/2+R_Arm]) cube ([22, 1.2, 1.3*R_Arm], center=true) ;
   }
  translate ([0,-Quad_B/4.8, Quad_H/2]) rotate ([45, 0, 0]) cube ([30, 1.8, 1.8], center=true) ;	// socket chamfer
   hull () {
      translate ([0,-Quad_B/4.8, Quad_H/2+2/2]) cube ([30, 1.4, 2], center=true) ;
      translate ([0,-Quad_B/4.8, Quad_H/2+R_Arm]) cube ([22, 1.2, 1.3*R_Arm], center=true) ;
   }

  // Arms stopper plates for flight position, if not replaced by cylindrical fill
//  if (StopperFill < 2)
  {
    translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-180+Quad_W]) translate ([-11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-Quad_W]) translate ([-11, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-Quad_W]) translate ([11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,+Quad_W]) translate ([-11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
   }
      
   // Arm stopper bars for storage position
   translate ([Quad_L/2-6,Quad_B/2-Armbord-B_Hinge/2-LowerWall, Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([Quad_L/2-6,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall), Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([-Quad_L/2+6,Quad_B/2-Armbord-B_Hinge/2-LowerWall, Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([-Quad_L/2+6,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall), Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ;  
}
module frame_upper_45x45()
{
    difference ()
    {
      frame_basis() ;

	 // Weight reduction holes in the middle
      hull() {
          translate ([ 45/2-12, 45/2-10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
          translate ([-45/2+12,45/2-10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-12, -45/2+10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
          translate ([-45/2+12,-45/2+10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
      }
      
      // Holes for M3 threads
      translate ([+22.5,+22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([+22.5,-22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([-22.5,+22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([-22.5,-22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;	
    } // difference

    // Holder for FC footprint 45x45 (e.g. Crius AIO V2)
   difference() {
      union() {
        translate ([+22.5,+22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;		// Domes for M3 screws
        translate ([+22.5,-22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;
        translate ([-22.5,+22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;
        translate ([-22.5,-22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;

        translate ([+22.5-2.5,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 45, QYbar_H], center=true) ;   // Bars betw FC domes
	    translate ([-22.5+2.5,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 45, QYbar_H], center=true) ;
	    translate ([0,+22.5,     Quad_H/2+QXbar_H/2]) cube ([45, 1.5, QXbar_H], center=true) ;
 	    translate ([0,-22.5,     Quad_H/2+QXbar_H/2]) cube ([45, 1.5, QXbar_H], center=true) ;
      }

      translate ([+22.5,+22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;				// Dome holes for M3 threads
      translate ([+22.5,-22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-22.5,+22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-22.5,-22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;	
   }
}

module frame_upper_blanco()
{
    frame_basis() ;
}


module frame_upper_31x31()
{
    difference ()
    {
      frame_basis() ;

	  // Holes for M3 threads
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;	           

	// Cooling / weight reduction holes in the middle under the ESC's
      hull() {
          translate ([ 45/2-16, Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }

      translate ([25,0,0]) cylinder (r=6, h=10, $fn=30, center=true) ;			// weight red holes between arms
      translate ([-25,0,0]) cylinder (r=6, h=10, $fn=30, center=true) ;     
    } // difference

    // Holder for FC footprint 30.5x30.5 (e.g. Naze32)
   difference() {
      union() {
        translate ([+30.5/2,+30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;		// Domes for M3 screws
        translate ([+30.5/2,-30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;
        translate ([-30.5/2,+30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;
        translate ([-30.5/2,-30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;

	    translate ([+30.5/2,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 30.5, QYbar_H], center=true) ;   // Bars betw FC domes
	    translate ([-30.5/2,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 30.5, QYbar_H], center=true) ;
 	    translate ([0,+30.5/2-1,Quad_H/2+QXbar_H/2]) cube ([30.5, 1.5, QXbar_H], center=true) ;
 	    translate ([0,-30.5/2+1, Quad_H/2+QXbar_H/2]) cube ([30.5, 1.5, QXbar_H], center=true) ;
      } // union
      
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;		// Holes for M3 threads
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;	           
   } // difference
}

module frame_upper ()
{
    if (FC_footprint == "31x31") frame_upper_31x31() ;
    if (FC_footprint == "45x45") frame_upper_45x45() ;
    if (FC_footprint == "none")  frame_upper_blanco() ;
        
    // Jeti RSAT antenna holder on top
    if (ant_holder == 1) translate ([-35,0,Quad_H/2+2.5]) antenna_holder() ;
}

module cover_dome(foot)
{
   // Holder for FC footprint
   difference() {
      union() {
        translate ([0,0,h_dome]) hull() {
            translate ([+foot/2,+foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		// Top plate = Round cube
            translate ([+foot/2,-foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
            translate ([-foot/2,+foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
            translate ([-foot/2,-foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
        } // hull
        translate ([+foot/2,+foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;		// Domes for M3 screws
        translate ([+foot/2,-foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;
        translate ([-foot/2,+foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;
        translate ([-foot/2,-foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;

        translate ([0,+foot/2+radome-1.2/2,h_dome-1.2/2]) cube ([foot, 1.2, kragen], center=true) ;	// Small side wall
        translate ([0,-foot/2-radome+1.2/2,h_dome-1.2/2]) cube ([foot, 1.2, kragen], center=true) ;	
        translate ([+foot/2+radome-1.2/2,0,h_dome-1.2/2]) cube ([1.2,foot, kragen], center=true) ;	
        translate ([-foot/2-radome+1.2/2,0,h_dome-1.2/2]) cube ([1.2,foot, kragen], center=true) ;	
      } // union
      
      translate ([+foot/2,+foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;		// Holes for M3 bolts
      translate ([+foot/2,-foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-foot/2,+foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-foot/2,-foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;	           
   } // difference
}

module dome()
{
   if (FC_footprint == "31x31") cover_dome (30.5) ;
   if (FC_footprint == "45x45") cover_dome (45) ;
}

module spacers_31x31()
{
   h_spc = 2.5;
   kragen = 1.0 ;
    
   // Holder for FC footprint 30.5x30.5 (e.g. Naze32)
   difference() {
      union() {
        translate ([+30.5/2,+30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;		// Domes for M3 screws
        translate ([+30.5/2,-30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;
        translate ([-30.5/2,+30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;
        translate ([-30.5/2,-30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;

        translate ([0,+30.5/2+2.8-1.2/2,h_spc-1.2/2]) cube ([30.5, 1.2, kragen], center=true) ;	// Small side wall
        translate ([0,-30.5/2-2.8+1.2/2,h_spc-1.2/2]) cube ([30.5, 1.2, kragen], center=true) ;	
        translate ([+30.5/2+2.8-1.2/2,0,h_spc-1.2/2]) cube ([1.2,30.5, kragen], center=true) ;	
        translate ([-30.5/2-2.8+1.2/2,0,h_spc-1.2/2]) cube ([1.2,30.5, kragen], center=true) ;	
      } // union
      
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;		// Holes for M3 bolts
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;	           
   } // difference
}

module leg()
{
   translate ([L_Arm-L_Hinge/2,0,-Quad_H-H_leg/2]) rotate ([0, 180, 90]) difference() {
      union() {
         hull() {
	      translate ([0,-7,0]) cylinder (r=W_leg/2, h=H_leg, center=true, $fn=30) ;
	      translate ([0,2,0]) cube ([W_leg, 14, H_leg], center=true) ;
	      translate ([0,2,H_leg/2]) rotate ([6,0,0]) cube ([W_leg, 18, 0.1], center=true) ;
	   }
         hull() {
	      translate ([0,9,0]) rotate ([0,90,0]) cylinder (r=H_leg/2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,4,0]) rotate ([0,90,0]) cylinder (r=H_leg/2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,11,1]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,11,1]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	      translate ([0,10,0.7]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,13,2.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,13,2.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	      translate ([0,15,4.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,15,4.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,17,7]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.0, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,17,7]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.0, h=W_leg, center=true, $fn=20) ;
	      translate ([0,22+0.9*L_leg,14+L_leg]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.2, h=W_leg, center=true, $fn=20) ;
	   }

       // Thread threngthening cylinders for ECO, to drill M3 yourself
       if (legeco == 1) {
          translate ([0,-6,2.5]) cylinder (r2=2.4, r1=4.0, h=5, center=true, $fn=20) ;		
          translate ([0,6,2.5]) cylinder (r2=2.4, r1=4.0, h=5, center=true, $fn=20) ;		
       } // if
      } // union

      // Create M3 through holes with stop nut   OR   M3 core thread hole w/o nut
      if (legeco == 1) {
        translate ([0,-6,0]) cylinder (r=1.2, h=20, center=true, $fn=20) ;		// M3 thread core
        translate ([0,6,0]) cylinder (r=1.2, h=20, center=true, $fn=20) ;		// M3 thread core 
      }
      else {    
        translate ([0,-6,0]) cylinder (r=1.6, h=20, center=true, $fn=20) ;		// M3 screw whole
        translate ([0,-6,2]) cylinder (r=6.5/2, h=5, center=true, $fn=6) ;   	// stop nut hole
        translate ([0,6,0]) cylinder (r=1.6, h=20, center=true, $fn=20) ;		// M3 screw whole
        translate ([0,6,2]) cylinder (r=6.5/2, h=5, center=true, $fn=6) ;     	// stop nut hole
      } // else
   }
}

module motor_1811()
{
   translate ([0,0,0-9.5])   cylinder (r=1, h=30, $fn=10) ;						// Shaft
   translate ([0,0,1.5-9.5]) cylinder (r=3, h=10, $fn=20) ;						// Stator flange
   translate ([0,0,11-9.5]) cylinder (r=17.5/2, h=7.5, $fn=30) ;					// Rotor bell
   translate ([0,0,16.5-9.5]) cylinder (r=5/2, h=5, $fn=20) ;					// Rotor adaptor
   translate ([0,-2,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 1
   translate ([0, 0,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 2
   translate ([0,+2,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 3 
}


module prop_5x3()
{
   translate ([0,0,12.2]) cylinder (r=3, h=6.5, $fn=15) ;						// Flange
   translate ([0,0,15.2]) cylinder (r=D_prop/2, h=1, $fn=30) ;				// Props
}

module plush_6a()
{
   cube ([25.5, 12, 1.3], center=true) ;										// PCB
   translate ([-5,0,3.5]) rotate ([0,90,0]) cylinder (r=2.6, h=12, $fn=15) ;		// Elko
}

module fc_45x45()
{
   difference() {
      cube ([55, 52, 1.6], center=true) ;										// PCB
      translate ([+22.5,+22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;				// Hole for M3 screw
      translate ([+22.5,-22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-22.5,+22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-22.5,-22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}

module fc_31x31()
{
   difference() {
      cube ([35, 35, 1.6], center=true) ;										// PCB
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;			// Hole for M3 screw
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}


module fc()
{
    if (FC_footprint == "31x31") fc_31x31() ;
    if (FC_footprint == "45x45") fc_45x45() ;
}

module fc_flip32mini()
{
   frame = 0.3 ;                                                                            // border around Flip32mini PCB
   mpcb_x = 15.0 ;                                                                        // Flip32 mini PCB dimensions
   mpcb_y = 31.7 ; 

   difference() {
      union() {
         roundcube (36, 36, 1.2, 2) ;										            // instead Naze32 PCB
         translate ([0,0,1]) roundcube (17, 33, 2, 1.5) ;			            // socket for Flip32 mini
      }
      translate ([0,0,1.8]) roundcube (mpcb_x, mpcb_y, 2, 0.5) ;			// PCB cutout for Flip32 mini 
      translate ([0,0,-1]) roundcube (mpcb_x-2*frame, mpcb_y-2*frame, 10, 1.0) ; // hole below PCB

      translate ([+30.5/2,+30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;		// Holes for M3 screw
      translate ([+30.5/2,-30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,+30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,-30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}

module jeti_rsat()
{
      cube ([19, 35, 3], center=true) ;										    // PCB
      // Straight antennas
//      translate ([4, 35/2,0]) rotate ([0,90,60]) cylinder (r=0.7, h=72, $fn=10) ;	            // Antenna 1
//      translate ([-4,35/2,0]) rotate ([0,90,120]) cylinder (r=0.7, h=72, $fn=10) ;            // Antenna 2

      // Bent for antenna holder
      translate ([4, 35/2+14,0]) rotate ([90,0,0]) cylinder (r=0.7, h=14, $fn=10) ;	         // Antenna 1
      translate ([4, 35/2+14,0]) rotate ([0,96,62]) cylinder (r=0.7, h=40, $fn=10) ;

      translate ([-4,35/2+14,0]) rotate ([90,0,0]) cylinder (r=0.7, h=14, $fn=10) ;            // Antenna 2
      translate ([-4,35/2+14,0]) rotate ([0,96,118]) cylinder (r=0.7, h=40, $fn=10) ;
}

module antenna_holder()
{
   difference() {
      hull() {                                                                                             // Fixing Block
          translate ([0,0,-2.2]) cube ([5, 24, 1], center=true) ;
          translate ([0,0,2.2]) cube ([5, 16, 0.1], center=true) ;
       }
      translate ([0,-6,0]) rotate ([0,80,25]) cylinder (r=r_antenna, h=20, $fn=10, center=true) ;   // Antenna 1
      translate ([0,6,0]) rotate ([0,80,-25]) cylinder (r=r_antenna, h=20, $fn=10, center=true) ;   // Antenna 2
       
      hull() {                                                                                          // Weight Reduction
         translate ([0,-3,0]) cylinder (r=1.5, h=20, $fn=20, center=true) ;  
         translate ([0,3,0]) cylinder (r=1.5, h=20, $fn=20, center=true) ;  
      }
   }
}

module neopixel_holder()
{
   difference() {
     translate ([0,0,0]) cube ([4, (Quad_B-Armbord-B_Hinge)/2-1, 2*R_Arm], center=true) ;
    
     // Holes for arm stopper bars in storage position
     translate ([0,Quad_B/2-Armbord-B_Hinge/2-LowerWall-0.2, -R_Arm+Stopper_H/2]) 
	  	 cube ([6, LowerWall, Stopper_H], center=true) ; 
     translate ([0,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall-0.2), -R_Arm+Stopper_H/2]) 
		  cube ([6, LowerWall, Stopper_H], center=true) ;  

     // Rect 5x5mm holes for 2 LEDs
      translate ([-1,-3.8,0]) cube ([2.5, 5, 5], center=true) ;   // Front Frame for LED 1
      translate ([-1,3.8,0])  cube ([2.5, 5, 5], center=true) ;   // for LED 2

      translate ([-0.6,-3.8,0]) cube ([2.0, 5.5, 5.5], center=true) ;   // LED 1
      translate ([-0.6,3.8,0])  cube ([2.0, 5.5, 5.5], center=true) ;   // LED 2

     // Holes for wiring inlay
     hull() {
       translate ([0.5,0,1]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20,center=true) ;
       translate ([0.5,0,2.5]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20,center=true) ;
       translate ([0.5,0,-2.5]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20, center=true) ;
     }
      hull() {
        translate ([0.5,-6.5,2.5]) rotate ([90,0,0]) cylinder (r=0.6, h=3, $fn=20,center=true) ;
        translate ([0.5,-6.5,0]) rotate ([90,0,0]) cylinder (r=0.6, h=3, $fn=20,center=true) ;
      } // hull

      // Cable outlet at backside
      hull() {
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+1.2,2.5]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+1.2,0]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+0.5,2.5]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+0.5,0]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
      } // hull
   } // difference
}

module quadro(angle)
{
  frame_lower() ;
  translate ([0,0,2*R_Arm+1.6]) frame_upper() ;

  translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) { boom() ; leg(); }
  translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) { boom() ; leg(); }
  translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0]) {  boom() ; leg(); }
  translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0])  { boom() ; leg(); }

   if (top_cover == 1) translate ([0,0,Dome_H+2*R_Arm+1.6]) dome() ;
   
   // If selected, show electronic components as ghosts
   if (ghosts == 1)
   {
      // Motors and props 
      translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0])  { %motor_1811() ; %prop_5x3() ; }
      translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0])  {%motor_1811() ; %prop_5x3() ; }
      translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0])  {%motor_1811() ; %prop_5x3() ; }
      translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0])  {%motor_1811() ; %prop_5x3(); }

      // 4 ESCs PLUSH 6A between the frames
      %translate ([1,20.5,3]) rotate ([0,0,180]) plush_6a() ;
      %translate ([2, 7,3]) rotate ([0,0,0]) plush_6a() ;
      %translate ([2,-7,3]) rotate ([0,0,0]) plush_6a() ;
      %translate ([1,-20.5,3]) rotate ([0,0,180]) plush_6a() ;

     // Jeti Duplex RMK receiver sandwiched below FC
     %translate ([0,0,14]) rotate ([0,0,90]) jeti_rsat() ;

     // Flight Controller on top
     %translate ([0,0,11.5+Dome_H]) fc() ;
   } // if 
}

module quadro_exploded(angle)
{
  translate ([0,0,-60]) frame_lower() ;
  translate ([0,0,2*R_Arm]) frame_upper() ;

  translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) 
	  { translate ([0,0,-20])  boom() ; if (ghosts == 1) %motor_1811() ; translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;   translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;   translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;  translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }

   if (top_cover == 1) translate ([0,0,45]) dome() ;

   if (ghosts == 1)
   {
       // 4 ESCs PLUSH 6A between the frames
       %translate ([1,20.5,3 -40]) rotate ([0,0,180]) plush_6a() ;
       %translate ([2, 7,3    -40]) rotate ([0,0,0]) plush_6a() ;
       %translate ([2,-7,3   -40]) rotate ([0,0,0]) plush_6a() ;
       %translate ([1,-20.5,3-40]) rotate ([0,0,180]) plush_6a() ;

       // Jeti Duplex RMK receiver sandwiched below FC
       %translate ([0,0,14+10]) rotate ([0,0,90]) jeti_rsat() ;
 
      // Flight Controller on top
      %translate ([0,0, 15+20]) fc() ;
   } // if
}



if (show == "all") quadro (Quad_W) ;            // 0 = booms in park / Quad_W = in flight
if (show == "exp") quadro_exploded (Quad_W) ;	   // optional: exploded view
if (show == "leg") leg() ;
if (show == "ant") translate ([-35,0,13.5]) antenna_holder() ;         // Jeti RSAT antenna holder
if (show == "neo") translate ([Quad_L/2-8,0,R_Arm]) rotate ([0,0,180]) neopixel_holder() ;
if (show == "boom") boom();
if (show == "bot") frame_lower();
if (show == "top") frame_upper();
if (show == "cov") translate ([0,0,Dome_H+8]) dome();
if (show == "debug") quadro_debug (Quad_W) ;
                ```
                

                Example ID: modular_b66f5e5e
                Score: 0.809
                Description: A design of the frame for a micro fpv drone
                Code:
                ```scad
                module motorHolders(x, diameter, height) {
  motorHolder(x, x, diameter, height); 
  motorHolder(-x, x, diameter, height); 
  motorHolder(x, -x, diameter, height); 
  motorHolder(-x, -x, diameter, height); 
}

module motorHoles(x, diameter, height) {
  motorHole(x, x, diameter, height); 
  motorHole(x, -x, diameter, height); 
  motorHole(-x, x, diameter, height); 
  motorHole(-x, -x, diameter, height); 
}

module motorHolder(x, y, motorDiameter, height = 3) {
  motorRadius = motorDiameter / 2;
  translate([x, y, 0])
  linear_extrude(height)
  circle(motorRadius + 2);
}

module motorHole(x, y, motorDiameter, height = 3) {
  motorRadius = motorDiameter / 2;
  translate([x, y, -1])
  linear_extrude(height + 2)
  circle(motorRadius);
}


module sides(x, sideOffset, h) {
  sideTB(x, sideOffset, 1, h);
  sideTB(x, sideOffset, -1, h);
  sideLR(x, sideOffset, 1, h);
  sideLR(x, sideOffset, -1, h);
}

module sideLR(x, sideOffset, dir, h) {
  p0=[dir * x, x - sideOffset];
  p1=[dir * sideOffset, 0];
  p2=[dir * x, -x + sideOffset];
  linear_extrude(h)
  BezConic( p0, p1, p2, steps=20);
}

module sideTB(x, sideOffset, dir, h) {
  p0=[x - sideOffset, dir * x];
  p1=[0, dir * sideOffset];
  p2=[-x + sideOffset, dir * x];
  linear_extrude(h)
  BezConic( p0, p1, p2, steps=20);
}

module cross(x, sideOffset, dir, h) {
  p0 = [dir * x, x - sideOffset];
  p1 = [dir * (x - sideOffset), x];
  p2 = [dir * -x, -x + sideOffset];
  p3 = [dir * (-x + sideOffset), -x];

  linear_extrude(h)
  polygon([p0, p1, p2, p3]);
}

module centerHole(h) {
  union() {
    translate([-10, -6, -1])
    cube([20, 12, h + 2]);
    translate([-8, -(23.5 / 2) + 1, -1])
    cube([16, 22.5, h + 2]);

    translate([-8, -(23.5 / 2) - 8, -1])
    cube([16, 8, h + 2]);
  }
}

module strapHoles(h) {
  union() {

    translate([-22, 10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([22, 10, -1])
    cylinder(r = 2, h = h + 3);  
  
    translate([-22, -10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([22, -10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([-24, 9.5, -1])
    cylinder(r = 1, h = h + 3);  

    translate([24, 9.5, -1])
    cylinder(r = 1, h = h + 3);  
  
    translate([-24, -9.5, -1])
    cylinder(r = 1, h = h + 3);  

    translate([24, -9.5, -1])
    cylinder(r = 1, h = h + 3);  


  }
}

module BezConic(p0,p1,p2,steps=5) {

	stepsize1 = (p1-p0)/steps;
	stepsize2 = (p2-p1)/steps;

	for (i=[0:steps-1]) {
		assign(point1 = p0+stepsize1*i) 
		assign(point2 = p1+stepsize2*i) 
		assign(point3 = p0+stepsize1*(i+1))
		assign(point4 = p1+stepsize2*(i+1))  {
			assign( bpoint1 = point1+(point2-point1)*(i/steps) )
			assign( bpoint2 = point3+(point4-point3)*((i+1)/steps) ) {
				polygon(points=[bpoint1,bpoint2,p1]);
			}
		}
	}
}

$fn = 30;

motorDistance = 120; // motor to motor distance
motorDiameter = 8.8; // hole size for 8.5mm motor
sideOffset = 3;

motorHolderHeight = 4;
crossHeight = 2;
sideHeight = 2;

x = sqrt(pow(motorDistance / 2, 2) * 2) / 2;

difference() {

  mainBody();

  motorHoles(x, motorDiameter, motorHolderHeight);
  centerHole(crossHeight);

  strapHoles(crossHeight);
}

module mainBody() {

  // motors
  motorHolders(x, motorDiameter, motorHolderHeight); 

  // cross beams
  cross(x, sideOffset, 1, crossHeight);
  cross(x, sideOffset, -1, crossHeight);

  // curved sides
  sides(x, sideOffset, sideHeight);
  
  boardMount(sideHeight);
}

module boardMount(h) {

  union() {
    translate([-12, (23.5 / 2), 0])
    cube([4, 2, h + 2]);

    translate([8, (23.5 / 2), 0])
    cube([4, 2, h + 2]);

    translate([-12, -(23.5 / 2), 0])
    cube([2, 23.5, h + 1]);

    translate([10, -(23.5 / 2), 0])
    cube([2, 23.5, h + 1]);


    translate([-10, - (23.5 / 2) - 10, 0])
    cube([4, 2, h + 2]);

    translate([6, - (23.5 / 2) - 10, 0])
    cube([4, 2, h + 2]);
  }
}
                ```
                

                Example ID: modular_8bed98a0
                Score: 0.809
                Description: I want a propeller of a drone
                Code:
                ```scad
                // Drone Propeller - Parametric OpenSCAD Model
// This model creates an aerodynamic drone propeller with customizable parameters

// ======== CUSTOMIZABLE PARAMETERS ========
// Basic dimensions
prop_diameter = 127;    // Propeller diameter in mm (5 inches)
hub_diameter = 12;      // Hub diameter in mm
hub_height = 6;         // Hub height in mm
shaft_diameter = 5;     // Motor shaft diameter in mm (M5)
num_blades = 2;         // Number of blades

// Blade parameters
blade_chord_max = 14;   // Maximum width of blade in mm
blade_chord_tip = 5;    // Width at blade tip in mm
blade_thickness = 2.5;  // Maximum thickness at blade root in mm
pitch_angle = 15;       // Base pitch angle (degrees)
twist_angle = 12;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.05;  // Airfoil camber ratio (0.0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.7; // Controls how blade width decreases toward tip (0.5-1.0)
efficiency_factor = 1.2;// Multiplier for airfoil lift curve (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution for curved surfaces
blade_segments = 18;    // Number of segments along blade length
profile_resolution = 24;// Number of points in airfoil cross-section

// ======== DERIVED VARIABLES ========
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

// ======== MODULES ========

// Generate an airfoil cross-section profile
module airfoil_profile(chord, thickness, camber, angle) {
    // Create upper and lower curves of the airfoil
    upper_points = [for (i = [0:profile_resolution]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [profile_resolution:-1:0]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments with varying properties from root to tip
    for (i = [0:blade_segments-1]) {
        // Position along blade (normalized 0-1)
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position with non-linear taper
        chord1 = blade_chord_max * (1 - t * (1 - blade_chord_tip/blade_chord_max) * pow(t, tip_taper_factor));
        chord2 = blade_chord_max * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_max) * 
                 pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip for better dynamics)
        thickness1 = blade_thickness * (1 - 0.6 * t);
        thickness2 = blade_thickness * (1 - 0.6 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution for optimal thrust)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment by connecting profiles at z1 and z2
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/3, d1 = hub_diameter, d2 = hub_diameter * 0.6, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/3, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root for structural integrity
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_max * 0.6);
            
            translate([blade_root_offset - blade_chord_max * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_max * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: _15fd3a5c
                Score: 0.732
                Description: I want a blade of propeller
                Code:
                ```scad
                // Propeller Blade Model
// This creates a single aerodynamic propeller blade with airfoil profile
// Parameters can be adjusted to change the blade's size, shape and pitch

/* PARAMETERS */
// Main dimensions
blade_length = 100;     // Length of the blade from hub to tip
blade_chord_root = 25;  // Width of blade at root (near hub)
blade_chord_tip = 15;   // Width of blade at tip
blade_thickness = 3;    // Maximum thickness of the blade

// Airfoil and twist properties
twist_angle = 30;       // Total twist angle from root to tip (degrees)
pitch_angle = 20;       // Base pitch angle (degrees)
camber = 0.06;          // Airfoil camber (curvature)

// Resolution parameters
segments = 30;          // Number of segments along blade length
airfoil_points = 24;    // Points to define airfoil cross-section

/* MODULES */

// NACA-inspired airfoil profile generator
module airfoil_profile(chord, thickness_ratio, camber_ratio, angle) {
    points = [for (i = [0:airfoil_points]) 
        let(
            t = i / airfoil_points,
            x = chord * (1 - cos(t * 180)),
            // Thickness distribution (symmetric part)
            thick = thickness_ratio * chord * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber_ratio * chord * sin(t * 180),
            // Upper and lower surfaces
            upper = [x, yc + thick, 0],
            lower = [x, yc - thick, 0]
        )
        (i <= airfoil_points/2) ? upper : lower
    ];
    
    // Rotate to account for pitch and twist
    rotate([0, 0, angle])
    polygon(points = [for (p = points) [p[0], p[1]]]);
}

// Create a single blade
module propeller_blade() {
    for (i = [0:segments-1]) {
        // Calculate position along blade length
        t = i / (segments - 1);
        z1 = t * blade_length;
        z2 = (i + 1) / (segments - 1) * blade_length;
        
        // Calculate chord at this position (linear taper)
        chord1 = blade_chord_root + t * (blade_chord_tip - blade_chord_root);
        chord2 = blade_chord_root + (i + 1) / (segments - 1) * (blade_chord_tip - blade_chord_root);
        
        // Calculate twist angle at this position (linear twist)
        angle1 = pitch_angle + t * twist_angle;
        angle2 = pitch_angle + (i + 1) / (segments - 1) * twist_angle;
        
        // Calculate thickness ratio (thinner toward tip)
        thickness_ratio1 = blade_thickness / chord1 * (1 - 0.3 * t);
        thickness_ratio2 = blade_thickness / chord2 * (1 - 0.3 * (i + 1) / (segments - 1));
        
        // Create segment by hulling two cross-sections
        hull() {
            translate([0, 0, z1])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness_ratio1, camber, angle1);
                    
            translate([0, 0, z2])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness_ratio2, camber, angle2);
        }
    }
}

// Create blade with root transition
module complete_blade() {
    union() {
        // Main blade
        propeller_blade();
        
        // Root transition to hub (simplified fillet)
        translate([0, 0, 0])
        rotate_extrude(angle = 360)
        polygon([
            [0, 0],
            [0, blade_length * 0.05],
            [blade_chord_root * 0.3, blade_length * 0.02],
            [blade_chord_root * 0.4, 0]
        ]);
    }
}

// Generate the blade
complete_blade();

// Uncomment to see the blade with hub attachment
/*
difference() {
    union() {
        complete_blade();
        // Hub cylinder
        color("gray")
        cylinder(h=10, r=blade_chord_root * 0.5, center=true, $fn=32);
    }
    
    // Hub mounting hole
    color("red")
    cylinder(h=12, r=3, center=true, $fn=32);
}
*/
                ```
                

                Example ID: unknown_9af337fa
                Score: 0.686
                Description: I want a drone propeller with 4 blades, each of it with 6 inches and diameter of 9 inches
                Code:
                ```scad
                //pitch (inches)
PitchI = 6;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 4;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_fdda84c1
                Score: 0.681
                Description: Parametric drone propeller with multiple blades
                Code:
                ```scad
                //Multipropv6-ThgV.scad
//A parametric generator for multiblade propellors.

// Created by Hamish Trolove - Feb 2019
//www.techmonkeybusiness.com

//Licensed under a Creative Commons license - attribution
// share alike. CC-BY-SA

//No extra libraries are required and it works under
//OpenSCAD 2015 and later.  This script will not work
//for older versions of OpenSCAD

//Airfoils:
// Points from naca4412.dat in the archive: http://m-selig.ae.illinois.edu/ads/archives/coord_seligFmt.tar.gz
// Not necessarily in the same order as in: http://m-selig.ae.illinois.edu/ads/coord/naca4412.dat

//pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 5;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_7ae6d851
                Score: 0.640
                Description: I want a blade of a drone propeller
                Code:
                ```scad
                //pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 12;

//Resolution steps between stations
SectRes = 10;  

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Spinner hinge radius at pin
SpinHPinRad = 34;

//Diameter of hinge pin
SpinPinD = 3;

//Blade base diameter
SpinHubD = 6;

//Spinner hinge width
SpinHL = 7;

//Hinge Pin Height Adjuster
SpinHubVTweak = 0.25;

//Holder variables for calculated Blade section parameters.  Ignore these.
Poz1 =0;
Poz2 = 0;
StrtAngi = 0;
EndAngi = 0;
StepLi = 0;
StrtWi = 0;
EndWi = 0; 


// Blade airfoil profile. Change with caution.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];


function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

StubSteps = (Diam/(16*SectL)>SpinHPinRad*1.2)?round(Diam/(16*SectL)):round(SpinHubD*1.1/SectL);

BldStubLn = 0.98*StubSteps * SectL; 
BldStrtPoint = round((SpinHPinRad+BldStubLn+0.5*SpinHubD)/SectL)-1;

function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
    rotate([0,90,0])
    cylinder (r =0.5*SpinHubD, h = SpinHL, center = true, $fn = 100);
}



module Hubcutter()
{
    union()
    {
        // Pin hole
        translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r = 0.5*SpinPinD, h = SpinHL*4, center = true, $fn = 100);
        
        //The two face shavers
        translate([1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 0.6*SpinHubD, r2 = 2.5*SpinHubD, h = SpinHL*2, center = true, $fn = 100);
        
        translate([-1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 5*SpinHubD, r2 = 0.6*SpinHubD, h = SpinHL*2, center = true, $fn = 100);        

    }
}


module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    union()
    {
    for(i = [BldStrtPoint:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module Hinge()
{
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*(SpinHPinRad+BldStubLn+0.5*SpinHubD)/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        EndAngi = atan(Pitch/(2*PI*(SpinHPinRad+BldStubLn+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+BldStubLn+0.5*SpinHubD);
        StrtAngi = atan(Pitch/(2*PI*(SpinHPinRad+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+0.5*SpinHubD);
        

            translate([0,-SpinHPinRad-0.5*SpinHubD,0])        
            rotate([90,0,0])
            Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);

    }
}


translate([0,SpinHPinRad,0])
difference()
{
    union()
    {
        Hinge();
        rotate([90,0,0])BladeBuilder();
    }
    Hubcutter();
}
                ```
                

                Example ID: modern_d16f0c88
                Score: 0.623
                Description: I want a drone propeller
                Code:
                ```scad
                // Aerodynamic Drone Propeller
// Parametric design with optimized airfoil profile and balanced structure

/* CUSTOMIZABLE PARAMETERS */
// Basic dimensions
prop_diameter = 100;    // Propeller diameter (mm)
hub_diameter = 10;      // Hub diameter (mm)
hub_height = 8;         // Hub height (mm)
num_blades = 3;         // Number of blades
shaft_diameter = 5;     // Motor shaft diameter (mm)

// Blade parameters
blade_chord_root = 15;  // Width at blade root (mm)
blade_chord_tip = 6;    // Width at blade tip (mm)
blade_max_thickness = 2;// Maximum thickness (mm)
pitch_angle = 25;       // Base pitch angle (degrees)
twist_angle = 15;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.04;  // Airfoil camber (0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.8; // Controls how quickly the blade tapers (0.5-1.0)
lift_efficiency = 1.2;  // Multiplier for lift curvature shape (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution
blade_segments = 20;    // Number of segments along blade length
airfoil_resolution = 24;// Points in airfoil cross-section

/* DERIVED VARIABLES */
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

/* MODULES */

// Airfoil profile generator
module airfoil_section(chord, thickness, camber, angle) {
    // Create upper and lower curves of airfoil
    upper_points = [for (i = [0:airfoil_resolution]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [airfoil_resolution:-1:0]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments
    for (i = [0:blade_segments-1]) {
        // Position along blade
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position (non-linear taper for better efficiency)
        chord1 = blade_chord_root * (1 - t * (1 - blade_chord_tip/blade_chord_root) * pow(t, tip_taper_factor));
        chord2 = blade_chord_root * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_root) * pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip)
        thickness1 = blade_max_thickness * (1 - 0.7 * t);
        thickness2 = blade_max_thickness * (1 - 0.7 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/4, d1 = hub_diameter, d2 = hub_diameter * 0.7, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/4, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_root * 0.6);
            
            translate([blade_root_offset - blade_chord_root * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_root * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: unknown_0c41abcf
                Score: 0.612
                Description: I want a propeller
                Code:
                ```scad
                // Propeller Design
// Parameters for customization
$fn = 100;  // Resolution for circular objects

// Main parameters
num_blades = 3;         // Number of propeller blades
hub_radius = 10;        // Radius of central hub
hub_height = 15;        // Height of central hub
shaft_radius = 3;       // Radius of shaft hole
blade_length = 50;      // Length of each blade
blade_width = 15;       // Maximum width of blade
blade_thickness = 3;    // Maximum thickness at blade root
twist_angle = 30;       // Twist angle from root to tip (degrees)
airfoil_camber = 0.1;   // Camber ratio for airfoil shape

// Module for creating a single propeller blade with twist and airfoil profile
module blade() {
    linear_extrude(height = blade_length, twist = -twist_angle, slices = 40, scale = 0.5) {
        union() {
            // Airfoil shape
            translate([-blade_width/4, 0, 0])
                scale([1, blade_thickness/blade_width, 1])
                    ellipse(blade_width/2, blade_width/2);
                
            // Add slight camber for improved aerodynamics
            translate([0, -blade_thickness * airfoil_camber, 0])
                scale([0.8, 0.2, 1])
                    circle(blade_width/2);
        }
    }
}

// Module for creating an ellipse
module ellipse(width, height) {
    scale([width, height, 1]) circle(1);
}

// Module for creating the central hub with shaft hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(r1 = hub_radius, r2 = hub_radius * 0.8, h = hub_height);
            
            // Hub base (for strength)
            cylinder(r = hub_radius * 1.2, h = hub_height * 0.2);
            
            // Hub top cap
            translate([0, 0, hub_height])
                cylinder(r1 = hub_radius * 0.8, r2 = hub_radius * 0.5, h = hub_height * 0.2);
        }
        
        // Shaft hole through center
        translate([0, 0, -1])
            cylinder(r = shaft_radius, h = hub_height + 2);
            
        // Setscrew hole
        translate([0, 0, hub_height/2])
            rotate([0, 90, 0])
                cylinder(r = shaft_radius/2, h = hub_radius + 1);
    }
}

// Assemble the propeller
module propeller() {
    // Central hub
    color("SlateGray") hub();
    
    // Blades
    color("LightSteelBlue")
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades])
            translate([hub_radius * 0.8, 0, hub_height * 0.6])
                rotate([0, 90, 0])
                    blade();
    }
}

// Create the propeller
propeller();
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Structural integrity to withstand flight forces while minimizing weight
- Strategic component placement for balanced weight distribution and stability
- Material selection balancing strength-to-weight ratio and durability
- Aerodynamic design to minimize drag and improve flight efficiency
- Modularity to allow for easy repair, maintenance, and component upgrades
- Vibration dampening to protect sensitive electronics and improve flight stability
- Heat dissipation capabilities for motor and electronic components
- Protection of internal components from environmental factors
- Code Structure: module structure
- Code Structure: algorithms
- Implementation Technique: extrude
- Implementation Technique: translate
- Implementation Technique: union
- Implementation Technique: minkowski
                    
                    SHAPE COMPONENTS:
                    - Center hub (main body) for housing electronics, battery, and flight controller
- Arms extending from the center hub for motor mounting
- Motor mounts at the ends of arms for propulsion system attachment
- Landing gear or supports for ground protection
- Top and bottom plates/covers for component protection and structural rigidity
- Internal mounting points for electronic components and accessories
- Cable routing channels for organized wiring
- Reinforcement structures at stress points (arm joints, motor mounts)
                    
                    IMPLEMENTATION STEPS:
                    1. Define drone specifications (size, payload capacity, flight characteristics)
2. Create initial concept sketches focusing on component placement and overall geometry
3. Develop 3D model of the center hub with consideration for electronics placement
4. Design arms with appropriate length and cross-section for strength and weight requirements
5. Add motor mounts with proper sizing and attachment mechanisms
6. Incorporate landing gear or supports with shock absorption considerations
7. Design protective covers and access points for maintenance
8. Add internal mounting structures for components (flight controller, battery, etc.)
9. Create cable routing channels and management systems
10. Apply structural reinforcements at critical stress points
11. Perform weight optimization while maintaining structural integrity
12. Validate design through structural analysis simulations
13. Create prototypes for physical testing (consider 3D printing for rapid iteration)
14. Refine design based on prototype testing results
15. Finalize 3D model with complete assembly and component integration

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "utility" type. Here's a suggested structure:
                
                ```scad
                
        module frame(height=10, width=20, depth=15, wall_thickness=2) {
            // Utility object with functional features
            difference() {
                union() {
                    // Add your code here
                    // Add your code here
                }
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
frame_size = 250; // The overall size of the drone frame in mm (measured diagonally from motor to motor)
frame_height = 50; // Height of the drone frame in mm
frame_width = 70; // Width of the central body in mm
arm_thickness = 4; // Thickness of the arms in mm, affecting structural rigidity and weight
motor_mount_diameter = 16; // Diameter of motor mounting holes in mm
fc_mounting_pattern = 30.5; // Flight controller mounting pattern in mm (common sizes: 16, 20, 30.5, 45)
include_top_plate = true; // Whether to include a protective top plate
battery_compartment_length = 80; // Length of battery compartment in mm
arm_length = 100; // Length of each arm extending from center hub in mm
center_hub_diameter = 50; // Diameter of the center hub in mm for housing electronics
motor_mount_width = 16; // Width of motor mounting areas in mm, based on standard motor dimensions
wall_thickness = 2.5; // Thickness of frame walls in mm, affecting overall structural integrity


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: Novel Drone Design Using an Optimization Software with 3D Model ...
Content: The drone frame consists of four main parts, which are the center top cover (50 g), the side top cover (10 g), the middle cover (30 g), and the
---

Title: Assembling procedure for the different drone components.
Content: The 3D drone layout design, accomplished using SOLIDWORKS, enhances understanding by showcasing all three different configurations of PULSAR's structure.
---

Title: Drone Frame Evolution - LinkedIn
Content: The primary function of frames is to protect all of the components of a drone. Types of Drone Frames. Drone frames come in a range of
---

Title: [PDF] Modeling And 3D Printing Of Drone Frame - iarjset
Content: 8.066Peer-reviewed / Refereed journalVol. 11, Issue 10, October 2024 DOI: 10.17148/IARJSET.2024.111029  IARJSET This work is licensed under a Creative Commons Attribution 4.0 International License 193 ISSN (O) 2393-8021, ISSN (P) 2394-1588 3.2 Problem Statement Requirement Definition: Establish objectives and constraints for the drone frame, including frame size, weight, material, and payload capacity. Conceptual Design: Create a conceptual layout incorporating motor placement, propeller [...] printing allows for the creation of complex geometries that would be impossible or expensive to produce using traditional manufacturing methods. Additionally, the ability to test and iterate drone frame designs quickly using 3D printing ensures better design optimization, reducing production time and costs. The application of advanced materials such as carbon fiber reinforced filaments, PLA, ABS, and PETG also enhances the durability, strength, and performance of 3D-printed drone frames. By [...] The future scope of modeling and 3D printing of drone frames is promising, with several advancements on the horizon: 1. Material Innovations: The development of new, stronger, and lighter 3D printing materials is expected to improve the overall performance and durability of drone frames. For example, incorporating nanomaterials or carbon fiber composites could lead to drones that are both lighter and more resistant to impact, temperature extremes, and wear. 2. Multi-Material Printing: Future
---

Title: Novel Drone Design Using an Optimization Software with 3D Model ...
Content: The drone frame consists of four main parts, which are the center top cover (50 g), the side top cover (10 g), the middle cover (30 g), and the
---


USER REQUEST:
frame drone

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a frame of a drone
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: unknown_9af337fa
                Score: 0.700
                Description: I want a drone propeller with 4 blades, each of it with 6 inches and diameter of 9 inches
                Code:
                ```scad
                //pitch (inches)
PitchI = 6;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 4;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_fdda84c1
                Score: 0.698
                Description: Parametric drone propeller with multiple blades
                Code:
                ```scad
                //Multipropv6-ThgV.scad
//A parametric generator for multiblade propellors.

// Created by Hamish Trolove - Feb 2019
//www.techmonkeybusiness.com

//Licensed under a Creative Commons license - attribution
// share alike. CC-BY-SA

//No extra libraries are required and it works under
//OpenSCAD 2015 and later.  This script will not work
//for older versions of OpenSCAD

//Airfoils:
// Points from naca4412.dat in the archive: http://m-selig.ae.illinois.edu/ads/archives/coord_seligFmt.tar.gz
// Not necessarily in the same order as in: http://m-selig.ae.illinois.edu/ads/coord/naca4412.dat

//pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 5;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_7ae6d851
                Score: 0.654
                Description: I want a blade of a drone propeller
                Code:
                ```scad
                //pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 12;

//Resolution steps between stations
SectRes = 10;  

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Spinner hinge radius at pin
SpinHPinRad = 34;

//Diameter of hinge pin
SpinPinD = 3;

//Blade base diameter
SpinHubD = 6;

//Spinner hinge width
SpinHL = 7;

//Hinge Pin Height Adjuster
SpinHubVTweak = 0.25;

//Holder variables for calculated Blade section parameters.  Ignore these.
Poz1 =0;
Poz2 = 0;
StrtAngi = 0;
EndAngi = 0;
StepLi = 0;
StrtWi = 0;
EndWi = 0; 


// Blade airfoil profile. Change with caution.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];


function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

StubSteps = (Diam/(16*SectL)>SpinHPinRad*1.2)?round(Diam/(16*SectL)):round(SpinHubD*1.1/SectL);

BldStubLn = 0.98*StubSteps * SectL; 
BldStrtPoint = round((SpinHPinRad+BldStubLn+0.5*SpinHubD)/SectL)-1;

function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
    rotate([0,90,0])
    cylinder (r =0.5*SpinHubD, h = SpinHL, center = true, $fn = 100);
}



module Hubcutter()
{
    union()
    {
        // Pin hole
        translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r = 0.5*SpinPinD, h = SpinHL*4, center = true, $fn = 100);
        
        //The two face shavers
        translate([1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 0.6*SpinHubD, r2 = 2.5*SpinHubD, h = SpinHL*2, center = true, $fn = 100);
        
        translate([-1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 5*SpinHubD, r2 = 0.6*SpinHubD, h = SpinHL*2, center = true, $fn = 100);        

    }
}


module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    union()
    {
    for(i = [BldStrtPoint:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module Hinge()
{
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*(SpinHPinRad+BldStubLn+0.5*SpinHubD)/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        EndAngi = atan(Pitch/(2*PI*(SpinHPinRad+BldStubLn+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+BldStubLn+0.5*SpinHubD);
        StrtAngi = atan(Pitch/(2*PI*(SpinHPinRad+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+0.5*SpinHubD);
        

            translate([0,-SpinHPinRad-0.5*SpinHubD,0])        
            rotate([90,0,0])
            Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);

    }
}


translate([0,SpinHPinRad,0])
difference()
{
    union()
    {
        Hinge();
        rotate([90,0,0])BladeBuilder();
    }
    Hubcutter();
}
                ```
                

                Example ID: modular_099c3391
                Score: 0.631
                Description: A frame of drone with 4 arms
                Code:
                ```scad
                // Globals

motorDiameter = 16;
motorLength   = 40;

baseLength    = 180;
baseWidth     = 100;
baseThick     = 3;
ridgeThick    = 5;

droneColor    = [0, .75, 0, 1]; // Green
    
armLength     = 160;
armWidth      = 30;
armXOffset    = 20;
armYOffset    = 70;
armAngle      = 20;
armRidgeShort = 44;

legHeight     = 30;
// Run

main();

// Code

module main() {
    union() {
        color(droneColor) {

            base();
            // Arms
            arm(armLength, armWidth, armXOffset, armYOffset, armAngle);
            arm(armLength, armWidth, armXOffset, -armYOffset, -armAngle);
            arm(armLength, armWidth, -armXOffset, armYOffset, 180 - armAngle);
            arm(armLength, armWidth, -armXOffset, -armYOffset, 180 + armAngle);

        }    
    }
}

module base() 
{
    
//    arm(armLength, armWidth, 0, 0, 0);
/**/
    union(){
        difference() {
            // Base
            cube(
                [baseWidth, baseLength, baseThick],
                center = true
            );

            // Leg hole
            translate([baseWidth/2 - 12, baseLength/2  - motorDiameter - 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };

            // Leg hole
            translate([-baseWidth/2 + 12, baseLength/2 - motorDiameter - 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };

            // Leg hole
            translate([baseWidth/2 - 12, -baseLength/2  + motorDiameter + 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };
            
            // Leg hole
            translate([-baseWidth/2 + 12, -baseLength/2  + motorDiameter + 16, 0]){
                cylinder(motorLength, motorDiameter/4, motorDiameter/4, center = true);
            };
            
            // Cable Hole
            translate([0, baseLength/2 - 20, 0]){
                cylinder(motorLength, motorDiameter/2, motorDiameter/2, center = true);
            };

        }
        
        // Stiffeners 
        translate([0, baseLength/2 - 8, ridgeThick/2]) {
            cube([baseWidth, ridgeThick, ridgeThick], center = true);
        }
        translate([0, -baseLength/2 + 8, ridgeThick/2]) {
            cube([baseWidth, ridgeThick, ridgeThick], center = true);
        }

        translate([baseWidth/2-4, 0, ridgeThick/2]) {
            cube([ridgeThick, baseLength - 8, ridgeThick], center = true);
        }
        translate([-baseWidth/2+4, 0, ridgeThick/2]) {
            cube([ridgeThick, baseLength - 8, ridgeThick], center = true);
        }
            
    
    }
/**/
}

module arm(len, wid, x, y, deg) 
{
    union() {
        translate([cos(deg)*len/2 + x, sin(deg)*len/2 + y, 0]) {
            rotate(deg) {
                union() {
                    
                    // Plate with hole
                    difference() {
                        cube(
                            [len, wid, baseThick],
                            center = true
                        );
                        translate([len/2 - motorDiameter, 0, 0]){
                            cylinder(motorLength, motorDiameter/2, motorDiameter/2, center = true);
                        };
                    }

                    
                    translate([-1.2*motorDiameter+2, 0, baseThick]) {
                        union() {
                            // Motor Support
                            translate([(len-motorDiameter)/2 - motorLength/2, 0, (motorLength*.75)/2-2]) {
                                difference() {
                                    cube ([motorLength, ridgeThick*2, motorLength*.75], center = true);
                                    translate([motorLength-motorDiameter*1.7, 0, -motorLength*.1]){
                                        rotate([90,0,0]) {
                                            cylinder(50, motorDiameter/4, motorDiameter/4, center = true);
                                        }
                                    };
                                    translate([motorLength-motorDiameter*1.7, 0, motorLength*.2]){
                                        rotate([90,0,0]) {
                                            cylinder(50, motorDiameter/4, motorDiameter/4, center = true);
                                        }
                                    };
                                    
                                }
                            }
                            // Plate Stiffner
                            cube ([len-motorDiameter*2 - armRidgeShort, ridgeThick, ridgeThick], center = true);
                        }
                    }

                }
            }
        }
    }
    
}
                ```
                

                Example ID: modular_e755671c
                Score: 0.630
                Description: A frame for a foldable nano drone
                Code:
                ```scad
                // Select object to show / print
show = "all" ; 

// Show additional electronic components
ghosts = 0 ; // [0:w/o electronic parts, 1:With ghost components]

// Select flight controller footprint
FC_footprint = "31x31" ; // ["31x31":Naze32 30.5x30.5mm, "45x45":MultiWii 45x45mm, "none":No footprint]

/* [Frame Dimensions] */
// Frame Basic Length
Quad_L = 90 ;	// [80:150]

// Frame Basic Width
Quad_B = 70 ;	 // [65:100]

// Boom Flight Position Angle
Quad_W = 50 ; // [45:65]

// Jeti RSAT antenna holder on top
ant_holder = 1 ; // [0:w/o antenna holder, 1:with antenna holder]

// Cover dome on top
top_cover = 1 ; // [0:w/o top cover, 1:with top cover]

// Height of 4 Flight Controller screw domes
Dome_H = 6 ;  // [3:0.5:10]

// Geometry of Flight Position Stoppers 
StopperFill = 1 ; // [0:No fill-only stopper blades, 1:Side blades filled]

/* [Boom Dimensions] */
// Motor type
motor_type = "hk1811sup" ; // ["hk1811sup":HK1811 with support, "hk1811":HK1811 without support, "bx1306":BX1306]

// Height of rotor bell
H_Rotor = 7.5 ; // [7.5:7.5 for HK1811 Motor, 10.0:10 Low for BX1306, 12.0:12 High for BX1306]

// Inner radius of motor holder around rotor bell
R_Rotor = 9.7 ; // [9.7:9.7 for HK1811 Motor, 10.0:10.0 for BX1306 Motor]

// Length of boom tube (to motor center, 5" prop: 85, 4" prop: 75) 
L_Arm = 85 ; // [60:120]

// Outer Radius of Boom Cylinder
R_Arm = 4.5 ; // [4.0:0.1:5.0]

// Wall thickness of boom tube
Wall_Arm = 0.9 ; // [0.7:0.1:1.2]

// Ovality factor of boom (H to W ratio in %)
Q_Arm   = 105 ; // [90:120]

// Chamfers at BX1306 motor fixing holes
Hole_chamfers = 1 ; // [0:No chamfers, 1:Chamfers]

// Wall thickness around rotor bell
Wall_Rotor = 1.2 ; // [0.9:0.1:1.5]

// Wall thickness at motor holder socket
Wall_Sockel = 1.5 ; 

/* [Leg dimensions] */
// Wideness of leg
 W_leg = 8.5 ; // [7.5:0.1:12]

// Material thickness of leg
H_leg = 3.2 ; // [2.5:0.1:4.0]

// Length extension of leg
 L_leg = 0 ;  // [0:15] 
 
// Use stop nuts or cut thread yourself
legeco = 0 ; // [1:Thread core hole, 0:M3 stop nut hole]

/* [Top cover  parameters] */
// Cover dome height
h_dome = 7; // [4:15]

// Dome cylinder radius
radome = 3.0 ; // [2:0.1:3.8]

// Border frame height
kragen = 1.5 ; // [1:0.1:3]

/* [Further internal parameters] */
// Height of chamfer below
H_Rotfase = 1 ;				
// Height of cone at lower side of motor holder
H_Rotkegel = 3 ;				
// Motor flange radius 1
R_hold1 = 4.5 ;				
// Motor flange radius 2
R_hold2 = 6 ;
// Motor flange height
H_hold = 8.8 ;				
// Lower flange outside radius (for stiff motor fixing)
R_Naussen = 5.2 ;
// Hole radius for "simple holder"
R_Nabe = 3.0 ;
// Position of M2.5 Motor fixing thread
MFix_z = 2.0 ; // [1.5:0.1:2.5]
// Radius cable channel inside boom
R_cable = 2.9;				
// Propeller Diameter (5"=127, 4"=102, 3"=76)
D_prop = 126 ; // [76:152]
// Hinge length
L_Hinge  = 20; // [18:22]		
// Hinge width
B_Hinge  = 14 ; // [12:16]	
// M3-Screw hole radius
R_Screw = 1.53 ;	 // [1.4:0.05:1.65]
// M3-Screw thread core hole
R_M3core = 1.2 ;
// axial length of chamfer hinge -> boom tube
H_HFase = 3.54 ;				
// axial backstand of internal bar in hinge
stegbak  = 1.0 ;				
// axial length of nose bar in hinge
stegovl  = 5 ;				
// Plate size reduction towards "mickey ears"
Quad_red = 11 ;	
// Thickness of lower frame plate
Quad_H = 1.6;	 // [1.3:0.1:2.0]
// Distance of Arm-End to Frame-Outline
Armbord = 18 ; // [15:18]
// Radius of Mickey Ears 
Quadmic_R = 18.0 ; // [17:20]
// Side walls thickness in lower frame
LowerWall = 1.4 ; // [1.0:0.1:2.0]
// Gap between lower side wall and upper frame
LowerSlot = 0.2 ;	 // [0.15:0.05:0.25]	
// Width of flight position stopper 
StopperWall = 1.6 ; // [1.3:0.1:2.0]
// Gap of flight position stopper to boom
StopperGap = 0.4 ; // [0.1:0.1:0.6]
// Height of storage position stopper 
Stopper_H = 3 ;  // [2.0:0.1:4.0]
// Height of strengthening X-dir bars around FC
QXbar_H = Dome_H*0.65 ; 
// Height of strengthening Y-dir bars around FC (w space for RX)
QYbar_H = 0.5 ;				
// Antenna hole radius
r_antenna = 1.2 ; // [1.2:0.1:1.5]

module arm_1811(support)
{
    // Hollow motor holder
    difference() {
       union() {
          translate ([0,0,H_Rotfase]) 
			cylinder (r=R_Rotor+Wall_Rotor, h=H_Rotor+Wall_Sockel-H_Rotfase, $fn=60) ;

	    // Cone below rotor bell
          translate ([0,0,-H_Rotkegel/2-H_Rotfase/2]) 
          		cylinder (r2=R_Rotor+Wall_Rotor, r1=R_Naussen, h=H_Rotkegel, $fn=40) ;

          // Flange tube holder with chamfer
          translate ([0,0,-H_hold]) cylinder (r1=R_Naussen, r2=R_Naussen+1, h=H_hold-H_Rotfase, $fn=40) ;
          translate ([0,0,-H_hold-1]) cylinder (r1=R_Naussen-1, r2=R_Naussen, h=1, $fn=40) ;

	    // Cylinder for flange fix screws
          translate ([0,0,-H_hold/2+MFix_z]) rotate ([90,0,0]) scale ([1.4,1,1]) cylinder (r=2.3, h=2*R_Naussen+3, $fn=20, center=true) ;  

          // Oval boom
          scale ([1,Q_Arm/100,1]) translate ([0,0,R_Arm]) rotate ([0,90,0]) cylinder (r=R_Arm, h=L_Arm, $fn=40) ;

          // Hinge block
          translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;

          // Chamfer between hinge and boom
          hull() {
             translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;
             scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge-H_HFase,0,R_Arm]) rotate ([0,90,0]) 
			cylinder (r=R_Arm, h=0.1, center=true, $fn=30) ;          
          }

	     // Cable tube below motor holder (outside)
         translate ([9.5,0,+0.2]) rotate ([0,-110,0]) scale ([1.1,1.33*Q_Arm/112,1]) cylinder (r = R_cable+0.9, h=24, $fn=40, center=true) ;
       }
      
       translate ([0,0,Wall_Sockel]) cylinder (r=R_Rotor, h=H_Rotor+0.05, $fn=40) ;			// Around rotor 
       translate ([0,0,-1.85]) cylinder (r2=R_Rotor, r1=R_Nabe-2, h=3.4, $fn=40) ;			// Below rotor, conic hole
       cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								// flange hole

       scale ([1,Q_Arm/100,1]) translate ([R_Rotor+Wall_Arm,0,R_Arm]) rotate ([0,90,0]) 			// boom tube hollow with end cap
			cylinder (r=R_Arm-Wall_Arm, h=L_Arm+0.1, $fn=30) ;

      // Cable tube at rotor, rotated part (inside)
      translate ([12.7,0,+0.0]) rotate ([0,-110,0]) scale ([0.72,1.2,1]) cylinder (r = R_cable, h=18, $fn=20, center=true) ;
	 // Cable tube, horizontal part
      translate ([6,0,-0.0]) rotate ([0,91,0]) scale ([0.8,1.3,1]) cylinder (r = 2.2, h=9.5, $fn=20, center=true) ;
      translate ([6.8,0,-0.6]) rotate ([0,91,0]) scale ([1.0,1.3,1]) cylinder (r = 2.2, h=6, $fn=20, center=true) ;

	// Hole for motor fixing screws M2.5
      translate ([0,0,-H_hold/2+MFix_z]) rotate ([90,0,0]) cylinder (r = 0.7, h=30, $fn=20, center=true) ;

	 // 50% wider hole in boom within hinge block, with chamfer
       hull() {
         scale ([1,1.50*Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2+stegbak,0,R_Arm]) rotate ([0,90,0])
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
         scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2-H_HFase/3-1.6,0,R_Arm]) rotate ([0,90,0]) 	
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
       }

       // M3 holes in hinge
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
    
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;

	 // 4 Chamfers at hinge block
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 2*R_Arm]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 2*R_Arm]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 0]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 0]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;    

       // Cylindrical cutout at hinge base for less cable movement when folding
       translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
    }

    // Vertical bar with screw holes in hinge block
   difference() { 
     hull() {
       translate ([L_Arm-L_Hinge/2+stegbak/2, 0, R_Arm]) cube ([L_Hinge-stegbak, 1+2*R_Screw, 2*R_Arm-0.5], center=true) ;
       translate ([L_Arm-L_Hinge/2-stegovl, 0, R_Arm]) cube ([L_Hinge, 0.5, 2*R_Arm-0.5], center=true) ;
     }

     // Again 4 M3 screw holes incl chamfers
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
  } 

  // Strengthening tube in motor dome (only possible together with support tube)
  if (support == 1) 
  {
    difference() { 
       union() {
         translate ([0,0,-1.5]) cylinder (r=R_Nabe+1.5, h=2, $fn=30) ;		    // Strenghtening tube
         translate ([0,0,-0.5]) cylinder (r1=R_Nabe+3, r2=R_Nabe+1.0, h=2, $fn=30) ;  // chamfer
       }
       cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								    // Flange hole
       translate ([R_Nabe+1.4,0,0]) scale ([1.3,0.95,1]) cylinder (r=R_cable, h=10, center=true, $fn=30) ;	            // Cable hole
    } // difference 

    // Support-tube in motor dome (can be broken away after print)
    difference() { 
        translate ([0,0,1]) cylinder (r=R_Nabe+0.8, h=H_Rotor+Wall_Sockel-1, $fn=30) ;	// Thin tube
        cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								        // Flange hole
        translate ([0,0,0.3]) rotate ([0,0,30]) cube ([10,2.5,4], center = true) ;				// 3 x 2 cutouts
	    translate ([0,0,0.3]) rotate ([0,0,90]) cube ([10,2.5,4], center = true) ;		
	    translate ([0,0,0.3]) rotate ([0,0,150]) cube ([10,2.5,4], center = true) ;
    } // difference

  } // if
}

module arm_bx1306()
{
    // Hollow Boom
    difference() {
       union() {
          translate ([0,0,H_Rotfase]) 
			 cylinder (r=R_Rotor+Wall_Rotor, h=H_Rotor+Wall_Sockel-H_Rotfase, $fn=60) ;
          translate ([0,0,H_Rotfase+H_Rotor+0.5]) 
			 cylinder (r1=R_Rotor+Wall_Rotor, r2=R_Rotor+Wall_Rotor-0.6, h=0.6, $fn=60) ;
          cylinder (r1=R_Rotor+Wall_Rotor-H_Rotfase, r2=R_Rotor+Wall_Rotor, h=H_Rotfase, $fn=50) ;
 
          // Strengthening fin between boom and motor dome
          hull() {
              translate ([R_Rotor,0,H_Rotor+1]) rotate ([0,90+36,0]) cylinder (r=0.8, h=10, $fn=10) ;
              translate ([R_Rotor,0,3]) rotate ([0,90,0]) cylinder (r=1.5, h=10, $fn=10) ;
          }
           
          // Oval boom tube
         scale ([1,Q_Arm/100,1]) translate ([0,0,R_Arm]) rotate ([0,90,0]) cylinder (r=R_Arm, h=L_Arm, $fn=40) ;

          // Hinge block
          translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;

          // Chamfer between hinge and boom
          hull() {
             translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;
             scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge-H_HFase,0,R_Arm]) rotate ([0,90,0]) 
			cylinder (r=R_Arm, h=0.1, center=true, $fn=30) ;          
          } // hull
       } // union
      
       translate ([0,0,Wall_Sockel]) cylinder (r=R_Rotor, h=H_Rotor+1.01, $fn=30) ;		// rotor hole
       translate ([0,0,0.5]) cylinder (r=5.5/2, h=2, $fn=30) ;	                                    // center groove
       scale ([1,Q_Arm/100,1]) translate ([8,0,R_Arm]) rotate ([0,90,0]) 						    // tube boom hole
			cylinder (r=R_Arm-Wall_Arm, h=L_Arm+0.1, $fn=30) ;
       scale ([1,Q_Arm/100,1]) translate ([8-6+0.1,0,R_Arm]) rotate ([0,90,0]) 					// tube boom hole
			cylinder (r2=R_Arm-Wall_Arm, r1=R_Arm-Wall_Arm-1.5, h=6, $fn=30) ;

       // 4 holes in boom bottom for fixing screws, with optional chamfers
       for (i= [0:3]) {
           assign (rot = i*90) rotate ([0,0,45+rot]) 
           {
             translate ([12/2, 0, -1]) cylinder (r=2.3/2, h=10, $fn=20) ;                         // hole
             if (Hole_chamfers == 1)
                 translate ([12/2, 0, -0.1]) cylinder (r2=2.3/2, r1=2.3/2+1, h=1, $fn=20) ;     // chamfer
           } // rotate
       } // for

	 // 50% wider hole in hinge block
       hull() {
         scale ([1,1.50*Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2+stegbak,0,R_Arm]) rotate ([0,90,0])
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
         scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2-H_HFase/3,0,R_Arm]) rotate ([0,90,0]) 	
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
       }

       // M3 holes
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

       // M3 chamfers
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;

	 // 4 Hinge chamfers
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 2*R_Arm]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 2*R_Arm]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 0]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 0]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       
       // Cylindrical cutout at hinge base for less cable movement when folding
       translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
    }

    // Vertical bar in hinge block
   difference() { 
     hull() {
       translate ([L_Arm-L_Hinge/2+stegbak/2, 0, R_Arm]) cube ([L_Hinge-stegbak, 1+2*R_Screw, 2*R_Arm-0.5], center=true) ;
       translate ([L_Arm-L_Hinge/2-stegovl, 0, R_Arm]) cube ([L_Hinge, 0.5, 2*R_Arm-0.5], center=true) ;
     }

     // Again M3 holes incl chamfers
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     
       // Again cylindrical cutout at hinge base for less cable movement
      translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
  }
}

module boom()
{
   if (motor_type == "hk1811sup") arm_1811(1) ;
   if (motor_type == "hk1811") arm_1811(0) ;
   if (motor_type == "bx1306") arm_bx1306() ;
}

module armslots(startw, endw)
{
      cylinder (r=R_Screw, h=20, center=true, $fn=20) ;									// anchor point
   
      for (angle = [startw : 10 : endw-10])												// Long hole
      {
          hull() {
             rotate ([0,0,angle]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
             rotate ([0,0,angle+10]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
          }
      }

      hull() {																			// Rest in long hole...
          rotate ([0,0,endw]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
          rotate ([0,0,endw-10]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
      }
}

module roundcube (x, y, z, rad)
{
    hull() {
      translate ([-x/2+rad, -y/2+rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([-x/2+rad, y/2-rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([x/2-rad, -y/2+rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([x/2-rad, y/2-rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
    }
}

module frame_basis()
{
    difference()
    {
        union()
        {
             cube ([Quad_L-Quad_red, Quad_B-Quad_red, Quad_H], center=true) ;
             translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
         } // union
         
         // 4 slot footprints for the arms
         translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) rotate ([0,0,-90]) armslots (0, Quad_W) ;
         translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) rotate ([0,0,90-Quad_W]) armslots (0, Quad_W) ;
          translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) rotate ([0,0,-90-Quad_W]) armslots (0, Quad_W) ;
         translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) rotate ([0,0,90]) armslots (0, Quad_W) ;
   } // diff
}

module frame_lower()
{
    difference ()
    {
      frame_basis() ;

	 // Cooling / weight reduction holes in the middle under the ESC's
      hull() {
          translate ([ 45/2-16, Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }

      translate ([24,0,0]) cylinder (r=7, h=10, $fn=20, center=true) ;			// weight red holes between arms
      translate ([-24,0,0]) cylinder (r=7, h=10, $fn=20, center=true) ;
    }

   // Battery rubber bolts with 2 sided chamfers
   translate ([20,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r=1.5, h=9, $fn=20, center=true);
   translate ([20+9/2+1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r1=1.5, r2=0.8, h=1.4, $fn=20, center=true);
   translate ([20-9/2-1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r2=1.5, r1=0.8, h=1.4, $fn=20, center=true);
   translate ([-20,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r=1.5, h=9, $fn=20, center=true);
   translate ([-20+9/2+1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r1=1.5, r2=0.8, h=1.4, $fn=20, center=true);
   translate ([-20-9/2-1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r2=1.5, r1=0.8, h=1.4, $fn=20, center=true);

   // Side walls 
   difference ()
   {
     union()
     {
         translate ([0,(Quad_B-Quad_red-LowerWall)/2, Quad_H/2+R_Arm-LowerSlot/2]) 
            cube ([Quad_L-36, LowerWall, 2*R_Arm-LowerSlot], center=true) ;
        translate ([0,-(Quad_B-Quad_red-LowerWall)/2, Quad_H/2+R_Arm-LowerSlot/2]) 
            cube ([Quad_L-36, LowerWall, 2*R_Arm-LowerSlot], center=true) ;
     }

    // Subtract Arms stopper plates for flight position
    translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-180+Quad_W]) translate ([-9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-Quad_W]) translate ([9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,+Quad_W]) translate ([-9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-Quad_W]) translate ([-9, B_Hinge/2-10+StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
   }

   // Flight position Stopper blades cylindrical fill?
   // Create these as intersection of mickey ears with stopper blade hull of one side
   if (StopperFill > 0)
   {
       clen = 12.5 - (Quad_W - 55)/10 ;      // correction of stopper length

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-180+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
                translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-Quad_W]) translate ([-15, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // difference
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-180+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
                translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-Quad_W]) translate ([-15, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,-Quad_W]) translate ([15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,-Quad_W]) translate ([15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection
   } // if 

    // Big wall in the middle with extension to the battery rubber bolts
   translate ([0,0, Quad_H/2]) rotate ([45, 0, 0]) cube ([40, 1.8, 1.8], center=true) ;	// socket chamfer
    hull () {
       translate ([0,0, Quad_H/2+R_Arm-LowerSlot/2]) cube ([22, 1.1, 2*R_Arm-LowerSlot], center=true) ;
       translate ([0,0, Quad_H/2+3/2]) cube ([40, 1.4, 2], center=true) ;
    }

   // Two lower inner walls / bars only for ESC fixation
  translate ([0,Quad_B/4.8, Quad_H/2]) rotate ([45, 0, 0]) cube ([30, 1.8, 1.8], center=true) ;	// socket chamfer
   hull () {
      translate ([0,Quad_B/4.8, Quad_H/2+2/2]) cube ([30, 1.3, 2], center=true) ;
      translate ([0,Quad_B/4.8, Quad_H/2+R_Arm]) cube ([22, 1.2, 1.3*R_Arm], center=true) ;
   }
  translate ([0,-Quad_B/4.8, Quad_H/2]) rotate ([45, 0, 0]) cube ([30, 1.8, 1.8], center=true) ;	// socket chamfer
   hull () {
      translate ([0,-Quad_B/4.8, Quad_H/2+2/2]) cube ([30, 1.4, 2], center=true) ;
      translate ([0,-Quad_B/4.8, Quad_H/2+R_Arm]) cube ([22, 1.2, 1.3*R_Arm], center=true) ;
   }

  // Arms stopper plates for flight position, if not replaced by cylindrical fill
//  if (StopperFill < 2)
  {
    translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-180+Quad_W]) translate ([-11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-Quad_W]) translate ([-11, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-Quad_W]) translate ([11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,+Quad_W]) translate ([-11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
   }
      
   // Arm stopper bars for storage position
   translate ([Quad_L/2-6,Quad_B/2-Armbord-B_Hinge/2-LowerWall, Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([Quad_L/2-6,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall), Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([-Quad_L/2+6,Quad_B/2-Armbord-B_Hinge/2-LowerWall, Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([-Quad_L/2+6,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall), Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ;  
}
module frame_upper_45x45()
{
    difference ()
    {
      frame_basis() ;

	 // Weight reduction holes in the middle
      hull() {
          translate ([ 45/2-12, 45/2-10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
          translate ([-45/2+12,45/2-10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-12, -45/2+10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
          translate ([-45/2+12,-45/2+10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
      }
      
      // Holes for M3 threads
      translate ([+22.5,+22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([+22.5,-22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([-22.5,+22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([-22.5,-22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;	
    } // difference

    // Holder for FC footprint 45x45 (e.g. Crius AIO V2)
   difference() {
      union() {
        translate ([+22.5,+22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;		// Domes for M3 screws
        translate ([+22.5,-22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;
        translate ([-22.5,+22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;
        translate ([-22.5,-22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;

        translate ([+22.5-2.5,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 45, QYbar_H], center=true) ;   // Bars betw FC domes
	    translate ([-22.5+2.5,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 45, QYbar_H], center=true) ;
	    translate ([0,+22.5,     Quad_H/2+QXbar_H/2]) cube ([45, 1.5, QXbar_H], center=true) ;
 	    translate ([0,-22.5,     Quad_H/2+QXbar_H/2]) cube ([45, 1.5, QXbar_H], center=true) ;
      }

      translate ([+22.5,+22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;				// Dome holes for M3 threads
      translate ([+22.5,-22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-22.5,+22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-22.5,-22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;	
   }
}

module frame_upper_blanco()
{
    frame_basis() ;
}


module frame_upper_31x31()
{
    difference ()
    {
      frame_basis() ;

	  // Holes for M3 threads
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;	           

	// Cooling / weight reduction holes in the middle under the ESC's
      hull() {
          translate ([ 45/2-16, Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }

      translate ([25,0,0]) cylinder (r=6, h=10, $fn=30, center=true) ;			// weight red holes between arms
      translate ([-25,0,0]) cylinder (r=6, h=10, $fn=30, center=true) ;     
    } // difference

    // Holder for FC footprint 30.5x30.5 (e.g. Naze32)
   difference() {
      union() {
        translate ([+30.5/2,+30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;		// Domes for M3 screws
        translate ([+30.5/2,-30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;
        translate ([-30.5/2,+30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;
        translate ([-30.5/2,-30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;

	    translate ([+30.5/2,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 30.5, QYbar_H], center=true) ;   // Bars betw FC domes
	    translate ([-30.5/2,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 30.5, QYbar_H], center=true) ;
 	    translate ([0,+30.5/2-1,Quad_H/2+QXbar_H/2]) cube ([30.5, 1.5, QXbar_H], center=true) ;
 	    translate ([0,-30.5/2+1, Quad_H/2+QXbar_H/2]) cube ([30.5, 1.5, QXbar_H], center=true) ;
      } // union
      
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;		// Holes for M3 threads
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;	           
   } // difference
}

module frame_upper ()
{
    if (FC_footprint == "31x31") frame_upper_31x31() ;
    if (FC_footprint == "45x45") frame_upper_45x45() ;
    if (FC_footprint == "none")  frame_upper_blanco() ;
        
    // Jeti RSAT antenna holder on top
    if (ant_holder == 1) translate ([-35,0,Quad_H/2+2.5]) antenna_holder() ;
}

module cover_dome(foot)
{
   // Holder for FC footprint
   difference() {
      union() {
        translate ([0,0,h_dome]) hull() {
            translate ([+foot/2,+foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		// Top plate = Round cube
            translate ([+foot/2,-foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
            translate ([-foot/2,+foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
            translate ([-foot/2,-foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
        } // hull
        translate ([+foot/2,+foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;		// Domes for M3 screws
        translate ([+foot/2,-foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;
        translate ([-foot/2,+foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;
        translate ([-foot/2,-foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;

        translate ([0,+foot/2+radome-1.2/2,h_dome-1.2/2]) cube ([foot, 1.2, kragen], center=true) ;	// Small side wall
        translate ([0,-foot/2-radome+1.2/2,h_dome-1.2/2]) cube ([foot, 1.2, kragen], center=true) ;	
        translate ([+foot/2+radome-1.2/2,0,h_dome-1.2/2]) cube ([1.2,foot, kragen], center=true) ;	
        translate ([-foot/2-radome+1.2/2,0,h_dome-1.2/2]) cube ([1.2,foot, kragen], center=true) ;	
      } // union
      
      translate ([+foot/2,+foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;		// Holes for M3 bolts
      translate ([+foot/2,-foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-foot/2,+foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-foot/2,-foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;	           
   } // difference
}

module dome()
{
   if (FC_footprint == "31x31") cover_dome (30.5) ;
   if (FC_footprint == "45x45") cover_dome (45) ;
}

module spacers_31x31()
{
   h_spc = 2.5;
   kragen = 1.0 ;
    
   // Holder for FC footprint 30.5x30.5 (e.g. Naze32)
   difference() {
      union() {
        translate ([+30.5/2,+30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;		// Domes for M3 screws
        translate ([+30.5/2,-30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;
        translate ([-30.5/2,+30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;
        translate ([-30.5/2,-30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;

        translate ([0,+30.5/2+2.8-1.2/2,h_spc-1.2/2]) cube ([30.5, 1.2, kragen], center=true) ;	// Small side wall
        translate ([0,-30.5/2-2.8+1.2/2,h_spc-1.2/2]) cube ([30.5, 1.2, kragen], center=true) ;	
        translate ([+30.5/2+2.8-1.2/2,0,h_spc-1.2/2]) cube ([1.2,30.5, kragen], center=true) ;	
        translate ([-30.5/2-2.8+1.2/2,0,h_spc-1.2/2]) cube ([1.2,30.5, kragen], center=true) ;	
      } // union
      
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;		// Holes for M3 bolts
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;	           
   } // difference
}

module leg()
{
   translate ([L_Arm-L_Hinge/2,0,-Quad_H-H_leg/2]) rotate ([0, 180, 90]) difference() {
      union() {
         hull() {
	      translate ([0,-7,0]) cylinder (r=W_leg/2, h=H_leg, center=true, $fn=30) ;
	      translate ([0,2,0]) cube ([W_leg, 14, H_leg], center=true) ;
	      translate ([0,2,H_leg/2]) rotate ([6,0,0]) cube ([W_leg, 18, 0.1], center=true) ;
	   }
         hull() {
	      translate ([0,9,0]) rotate ([0,90,0]) cylinder (r=H_leg/2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,4,0]) rotate ([0,90,0]) cylinder (r=H_leg/2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,11,1]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,11,1]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	      translate ([0,10,0.7]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,13,2.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,13,2.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	      translate ([0,15,4.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,15,4.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,17,7]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.0, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,17,7]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.0, h=W_leg, center=true, $fn=20) ;
	      translate ([0,22+0.9*L_leg,14+L_leg]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.2, h=W_leg, center=true, $fn=20) ;
	   }

       // Thread threngthening cylinders for ECO, to drill M3 yourself
       if (legeco == 1) {
          translate ([0,-6,2.5]) cylinder (r2=2.4, r1=4.0, h=5, center=true, $fn=20) ;		
          translate ([0,6,2.5]) cylinder (r2=2.4, r1=4.0, h=5, center=true, $fn=20) ;		
       } // if
      } // union

      // Create M3 through holes with stop nut   OR   M3 core thread hole w/o nut
      if (legeco == 1) {
        translate ([0,-6,0]) cylinder (r=1.2, h=20, center=true, $fn=20) ;		// M3 thread core
        translate ([0,6,0]) cylinder (r=1.2, h=20, center=true, $fn=20) ;		// M3 thread core 
      }
      else {    
        translate ([0,-6,0]) cylinder (r=1.6, h=20, center=true, $fn=20) ;		// M3 screw whole
        translate ([0,-6,2]) cylinder (r=6.5/2, h=5, center=true, $fn=6) ;   	// stop nut hole
        translate ([0,6,0]) cylinder (r=1.6, h=20, center=true, $fn=20) ;		// M3 screw whole
        translate ([0,6,2]) cylinder (r=6.5/2, h=5, center=true, $fn=6) ;     	// stop nut hole
      } // else
   }
}

module motor_1811()
{
   translate ([0,0,0-9.5])   cylinder (r=1, h=30, $fn=10) ;						// Shaft
   translate ([0,0,1.5-9.5]) cylinder (r=3, h=10, $fn=20) ;						// Stator flange
   translate ([0,0,11-9.5]) cylinder (r=17.5/2, h=7.5, $fn=30) ;					// Rotor bell
   translate ([0,0,16.5-9.5]) cylinder (r=5/2, h=5, $fn=20) ;					// Rotor adaptor
   translate ([0,-2,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 1
   translate ([0, 0,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 2
   translate ([0,+2,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 3 
}


module prop_5x3()
{
   translate ([0,0,12.2]) cylinder (r=3, h=6.5, $fn=15) ;						// Flange
   translate ([0,0,15.2]) cylinder (r=D_prop/2, h=1, $fn=30) ;				// Props
}

module plush_6a()
{
   cube ([25.5, 12, 1.3], center=true) ;										// PCB
   translate ([-5,0,3.5]) rotate ([0,90,0]) cylinder (r=2.6, h=12, $fn=15) ;		// Elko
}

module fc_45x45()
{
   difference() {
      cube ([55, 52, 1.6], center=true) ;										// PCB
      translate ([+22.5,+22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;				// Hole for M3 screw
      translate ([+22.5,-22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-22.5,+22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-22.5,-22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}

module fc_31x31()
{
   difference() {
      cube ([35, 35, 1.6], center=true) ;										// PCB
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;			// Hole for M3 screw
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}


module fc()
{
    if (FC_footprint == "31x31") fc_31x31() ;
    if (FC_footprint == "45x45") fc_45x45() ;
}

module fc_flip32mini()
{
   frame = 0.3 ;                                                                            // border around Flip32mini PCB
   mpcb_x = 15.0 ;                                                                        // Flip32 mini PCB dimensions
   mpcb_y = 31.7 ; 

   difference() {
      union() {
         roundcube (36, 36, 1.2, 2) ;										            // instead Naze32 PCB
         translate ([0,0,1]) roundcube (17, 33, 2, 1.5) ;			            // socket for Flip32 mini
      }
      translate ([0,0,1.8]) roundcube (mpcb_x, mpcb_y, 2, 0.5) ;			// PCB cutout for Flip32 mini 
      translate ([0,0,-1]) roundcube (mpcb_x-2*frame, mpcb_y-2*frame, 10, 1.0) ; // hole below PCB

      translate ([+30.5/2,+30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;		// Holes for M3 screw
      translate ([+30.5/2,-30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,+30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,-30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}

module jeti_rsat()
{
      cube ([19, 35, 3], center=true) ;										    // PCB
      // Straight antennas
//      translate ([4, 35/2,0]) rotate ([0,90,60]) cylinder (r=0.7, h=72, $fn=10) ;	            // Antenna 1
//      translate ([-4,35/2,0]) rotate ([0,90,120]) cylinder (r=0.7, h=72, $fn=10) ;            // Antenna 2

      // Bent for antenna holder
      translate ([4, 35/2+14,0]) rotate ([90,0,0]) cylinder (r=0.7, h=14, $fn=10) ;	         // Antenna 1
      translate ([4, 35/2+14,0]) rotate ([0,96,62]) cylinder (r=0.7, h=40, $fn=10) ;

      translate ([-4,35/2+14,0]) rotate ([90,0,0]) cylinder (r=0.7, h=14, $fn=10) ;            // Antenna 2
      translate ([-4,35/2+14,0]) rotate ([0,96,118]) cylinder (r=0.7, h=40, $fn=10) ;
}

module antenna_holder()
{
   difference() {
      hull() {                                                                                             // Fixing Block
          translate ([0,0,-2.2]) cube ([5, 24, 1], center=true) ;
          translate ([0,0,2.2]) cube ([5, 16, 0.1], center=true) ;
       }
      translate ([0,-6,0]) rotate ([0,80,25]) cylinder (r=r_antenna, h=20, $fn=10, center=true) ;   // Antenna 1
      translate ([0,6,0]) rotate ([0,80,-25]) cylinder (r=r_antenna, h=20, $fn=10, center=true) ;   // Antenna 2
       
      hull() {                                                                                          // Weight Reduction
         translate ([0,-3,0]) cylinder (r=1.5, h=20, $fn=20, center=true) ;  
         translate ([0,3,0]) cylinder (r=1.5, h=20, $fn=20, center=true) ;  
      }
   }
}

module neopixel_holder()
{
   difference() {
     translate ([0,0,0]) cube ([4, (Quad_B-Armbord-B_Hinge)/2-1, 2*R_Arm], center=true) ;
    
     // Holes for arm stopper bars in storage position
     translate ([0,Quad_B/2-Armbord-B_Hinge/2-LowerWall-0.2, -R_Arm+Stopper_H/2]) 
	  	 cube ([6, LowerWall, Stopper_H], center=true) ; 
     translate ([0,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall-0.2), -R_Arm+Stopper_H/2]) 
		  cube ([6, LowerWall, Stopper_H], center=true) ;  

     // Rect 5x5mm holes for 2 LEDs
      translate ([-1,-3.8,0]) cube ([2.5, 5, 5], center=true) ;   // Front Frame for LED 1
      translate ([-1,3.8,0])  cube ([2.5, 5, 5], center=true) ;   // for LED 2

      translate ([-0.6,-3.8,0]) cube ([2.0, 5.5, 5.5], center=true) ;   // LED 1
      translate ([-0.6,3.8,0])  cube ([2.0, 5.5, 5.5], center=true) ;   // LED 2

     // Holes for wiring inlay
     hull() {
       translate ([0.5,0,1]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20,center=true) ;
       translate ([0.5,0,2.5]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20,center=true) ;
       translate ([0.5,0,-2.5]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20, center=true) ;
     }
      hull() {
        translate ([0.5,-6.5,2.5]) rotate ([90,0,0]) cylinder (r=0.6, h=3, $fn=20,center=true) ;
        translate ([0.5,-6.5,0]) rotate ([90,0,0]) cylinder (r=0.6, h=3, $fn=20,center=true) ;
      } // hull

      // Cable outlet at backside
      hull() {
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+1.2,2.5]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+1.2,0]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+0.5,2.5]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+0.5,0]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
      } // hull
   } // difference
}

module quadro(angle)
{
  frame_lower() ;
  translate ([0,0,2*R_Arm+1.6]) frame_upper() ;

  translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) { boom() ; leg(); }
  translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) { boom() ; leg(); }
  translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0]) {  boom() ; leg(); }
  translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0])  { boom() ; leg(); }

   if (top_cover == 1) translate ([0,0,Dome_H+2*R_Arm+1.6]) dome() ;
   
   // If selected, show electronic components as ghosts
   if (ghosts == 1)
   {
      // Motors and props 
      translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0])  { %motor_1811() ; %prop_5x3() ; }
      translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0])  {%motor_1811() ; %prop_5x3() ; }
      translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0])  {%motor_1811() ; %prop_5x3() ; }
      translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0])  {%motor_1811() ; %prop_5x3(); }

      // 4 ESCs PLUSH 6A between the frames
      %translate ([1,20.5,3]) rotate ([0,0,180]) plush_6a() ;
      %translate ([2, 7,3]) rotate ([0,0,0]) plush_6a() ;
      %translate ([2,-7,3]) rotate ([0,0,0]) plush_6a() ;
      %translate ([1,-20.5,3]) rotate ([0,0,180]) plush_6a() ;

     // Jeti Duplex RMK receiver sandwiched below FC
     %translate ([0,0,14]) rotate ([0,0,90]) jeti_rsat() ;

     // Flight Controller on top
     %translate ([0,0,11.5+Dome_H]) fc() ;
   } // if 
}

module quadro_exploded(angle)
{
  translate ([0,0,-60]) frame_lower() ;
  translate ([0,0,2*R_Arm]) frame_upper() ;

  translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) 
	  { translate ([0,0,-20])  boom() ; if (ghosts == 1) %motor_1811() ; translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;   translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;   translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;  translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }

   if (top_cover == 1) translate ([0,0,45]) dome() ;

   if (ghosts == 1)
   {
       // 4 ESCs PLUSH 6A between the frames
       %translate ([1,20.5,3 -40]) rotate ([0,0,180]) plush_6a() ;
       %translate ([2, 7,3    -40]) rotate ([0,0,0]) plush_6a() ;
       %translate ([2,-7,3   -40]) rotate ([0,0,0]) plush_6a() ;
       %translate ([1,-20.5,3-40]) rotate ([0,0,180]) plush_6a() ;

       // Jeti Duplex RMK receiver sandwiched below FC
       %translate ([0,0,14+10]) rotate ([0,0,90]) jeti_rsat() ;
 
      // Flight Controller on top
      %translate ([0,0, 15+20]) fc() ;
   } // if
}



if (show == "all") quadro (Quad_W) ;            // 0 = booms in park / Quad_W = in flight
if (show == "exp") quadro_exploded (Quad_W) ;	   // optional: exploded view
if (show == "leg") leg() ;
if (show == "ant") translate ([-35,0,13.5]) antenna_holder() ;         // Jeti RSAT antenna holder
if (show == "neo") translate ([Quad_L/2-8,0,R_Arm]) rotate ([0,0,180]) neopixel_holder() ;
if (show == "boom") boom();
if (show == "bot") frame_lower();
if (show == "top") frame_upper();
if (show == "cov") translate ([0,0,Dome_H+8]) dome();
if (show == "debug") quadro_debug (Quad_W) ;
                ```
                

                Example ID: modular_b66f5e5e
                Score: 0.632
                Description: A design of the frame for a micro fpv drone
                Code:
                ```scad
                module motorHolders(x, diameter, height) {
  motorHolder(x, x, diameter, height); 
  motorHolder(-x, x, diameter, height); 
  motorHolder(x, -x, diameter, height); 
  motorHolder(-x, -x, diameter, height); 
}

module motorHoles(x, diameter, height) {
  motorHole(x, x, diameter, height); 
  motorHole(x, -x, diameter, height); 
  motorHole(-x, x, diameter, height); 
  motorHole(-x, -x, diameter, height); 
}

module motorHolder(x, y, motorDiameter, height = 3) {
  motorRadius = motorDiameter / 2;
  translate([x, y, 0])
  linear_extrude(height)
  circle(motorRadius + 2);
}

module motorHole(x, y, motorDiameter, height = 3) {
  motorRadius = motorDiameter / 2;
  translate([x, y, -1])
  linear_extrude(height + 2)
  circle(motorRadius);
}


module sides(x, sideOffset, h) {
  sideTB(x, sideOffset, 1, h);
  sideTB(x, sideOffset, -1, h);
  sideLR(x, sideOffset, 1, h);
  sideLR(x, sideOffset, -1, h);
}

module sideLR(x, sideOffset, dir, h) {
  p0=[dir * x, x - sideOffset];
  p1=[dir * sideOffset, 0];
  p2=[dir * x, -x + sideOffset];
  linear_extrude(h)
  BezConic( p0, p1, p2, steps=20);
}

module sideTB(x, sideOffset, dir, h) {
  p0=[x - sideOffset, dir * x];
  p1=[0, dir * sideOffset];
  p2=[-x + sideOffset, dir * x];
  linear_extrude(h)
  BezConic( p0, p1, p2, steps=20);
}

module cross(x, sideOffset, dir, h) {
  p0 = [dir * x, x - sideOffset];
  p1 = [dir * (x - sideOffset), x];
  p2 = [dir * -x, -x + sideOffset];
  p3 = [dir * (-x + sideOffset), -x];

  linear_extrude(h)
  polygon([p0, p1, p2, p3]);
}

module centerHole(h) {
  union() {
    translate([-10, -6, -1])
    cube([20, 12, h + 2]);
    translate([-8, -(23.5 / 2) + 1, -1])
    cube([16, 22.5, h + 2]);

    translate([-8, -(23.5 / 2) - 8, -1])
    cube([16, 8, h + 2]);
  }
}

module strapHoles(h) {
  union() {

    translate([-22, 10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([22, 10, -1])
    cylinder(r = 2, h = h + 3);  
  
    translate([-22, -10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([22, -10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([-24, 9.5, -1])
    cylinder(r = 1, h = h + 3);  

    translate([24, 9.5, -1])
    cylinder(r = 1, h = h + 3);  
  
    translate([-24, -9.5, -1])
    cylinder(r = 1, h = h + 3);  

    translate([24, -9.5, -1])
    cylinder(r = 1, h = h + 3);  


  }
}

module BezConic(p0,p1,p2,steps=5) {

	stepsize1 = (p1-p0)/steps;
	stepsize2 = (p2-p1)/steps;

	for (i=[0:steps-1]) {
		assign(point1 = p0+stepsize1*i) 
		assign(point2 = p1+stepsize2*i) 
		assign(point3 = p0+stepsize1*(i+1))
		assign(point4 = p1+stepsize2*(i+1))  {
			assign( bpoint1 = point1+(point2-point1)*(i/steps) )
			assign( bpoint2 = point3+(point4-point3)*((i+1)/steps) ) {
				polygon(points=[bpoint1,bpoint2,p1]);
			}
		}
	}
}

$fn = 30;

motorDistance = 120; // motor to motor distance
motorDiameter = 8.8; // hole size for 8.5mm motor
sideOffset = 3;

motorHolderHeight = 4;
crossHeight = 2;
sideHeight = 2;

x = sqrt(pow(motorDistance / 2, 2) * 2) / 2;

difference() {

  mainBody();

  motorHoles(x, motorDiameter, motorHolderHeight);
  centerHole(crossHeight);

  strapHoles(crossHeight);
}

module mainBody() {

  // motors
  motorHolders(x, motorDiameter, motorHolderHeight); 

  // cross beams
  cross(x, sideOffset, 1, crossHeight);
  cross(x, sideOffset, -1, crossHeight);

  // curved sides
  sides(x, sideOffset, sideHeight);
  
  boardMount(sideHeight);
}

module boardMount(h) {

  union() {
    translate([-12, (23.5 / 2), 0])
    cube([4, 2, h + 2]);

    translate([8, (23.5 / 2), 0])
    cube([4, 2, h + 2]);

    translate([-12, -(23.5 / 2), 0])
    cube([2, 23.5, h + 1]);

    translate([10, -(23.5 / 2), 0])
    cube([2, 23.5, h + 1]);


    translate([-10, - (23.5 / 2) - 10, 0])
    cube([4, 2, h + 2]);

    translate([6, - (23.5 / 2) - 10, 0])
    cube([4, 2, h + 2]);
  }
}
                ```
                

                Example ID: modular_8bed98a0
                Score: 0.632
                Description: I want a propeller of a drone
                Code:
                ```scad
                // Drone Propeller - Parametric OpenSCAD Model
// This model creates an aerodynamic drone propeller with customizable parameters

// ======== CUSTOMIZABLE PARAMETERS ========
// Basic dimensions
prop_diameter = 127;    // Propeller diameter in mm (5 inches)
hub_diameter = 12;      // Hub diameter in mm
hub_height = 6;         // Hub height in mm
shaft_diameter = 5;     // Motor shaft diameter in mm (M5)
num_blades = 2;         // Number of blades

// Blade parameters
blade_chord_max = 14;   // Maximum width of blade in mm
blade_chord_tip = 5;    // Width at blade tip in mm
blade_thickness = 2.5;  // Maximum thickness at blade root in mm
pitch_angle = 15;       // Base pitch angle (degrees)
twist_angle = 12;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.05;  // Airfoil camber ratio (0.0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.7; // Controls how blade width decreases toward tip (0.5-1.0)
efficiency_factor = 1.2;// Multiplier for airfoil lift curve (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution for curved surfaces
blade_segments = 18;    // Number of segments along blade length
profile_resolution = 24;// Number of points in airfoil cross-section

// ======== DERIVED VARIABLES ========
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

// ======== MODULES ========

// Generate an airfoil cross-section profile
module airfoil_profile(chord, thickness, camber, angle) {
    // Create upper and lower curves of the airfoil
    upper_points = [for (i = [0:profile_resolution]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [profile_resolution:-1:0]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments with varying properties from root to tip
    for (i = [0:blade_segments-1]) {
        // Position along blade (normalized 0-1)
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position with non-linear taper
        chord1 = blade_chord_max * (1 - t * (1 - blade_chord_tip/blade_chord_max) * pow(t, tip_taper_factor));
        chord2 = blade_chord_max * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_max) * 
                 pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip for better dynamics)
        thickness1 = blade_thickness * (1 - 0.6 * t);
        thickness2 = blade_thickness * (1 - 0.6 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution for optimal thrust)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment by connecting profiles at z1 and z2
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/3, d1 = hub_diameter, d2 = hub_diameter * 0.6, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/3, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root for structural integrity
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_max * 0.6);
            
            translate([blade_root_offset - blade_chord_max * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_max * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: _15fd3a5c
                Score: 0.501
                Description: I want a blade of propeller
                Code:
                ```scad
                // Propeller Blade Model
// This creates a single aerodynamic propeller blade with airfoil profile
// Parameters can be adjusted to change the blade's size, shape and pitch

/* PARAMETERS */
// Main dimensions
blade_length = 100;     // Length of the blade from hub to tip
blade_chord_root = 25;  // Width of blade at root (near hub)
blade_chord_tip = 15;   // Width of blade at tip
blade_thickness = 3;    // Maximum thickness of the blade

// Airfoil and twist properties
twist_angle = 30;       // Total twist angle from root to tip (degrees)
pitch_angle = 20;       // Base pitch angle (degrees)
camber = 0.06;          // Airfoil camber (curvature)

// Resolution parameters
segments = 30;          // Number of segments along blade length
airfoil_points = 24;    // Points to define airfoil cross-section

/* MODULES */

// NACA-inspired airfoil profile generator
module airfoil_profile(chord, thickness_ratio, camber_ratio, angle) {
    points = [for (i = [0:airfoil_points]) 
        let(
            t = i / airfoil_points,
            x = chord * (1 - cos(t * 180)),
            // Thickness distribution (symmetric part)
            thick = thickness_ratio * chord * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber_ratio * chord * sin(t * 180),
            // Upper and lower surfaces
            upper = [x, yc + thick, 0],
            lower = [x, yc - thick, 0]
        )
        (i <= airfoil_points/2) ? upper : lower
    ];
    
    // Rotate to account for pitch and twist
    rotate([0, 0, angle])
    polygon(points = [for (p = points) [p[0], p[1]]]);
}

// Create a single blade
module propeller_blade() {
    for (i = [0:segments-1]) {
        // Calculate position along blade length
        t = i / (segments - 1);
        z1 = t * blade_length;
        z2 = (i + 1) / (segments - 1) * blade_length;
        
        // Calculate chord at this position (linear taper)
        chord1 = blade_chord_root + t * (blade_chord_tip - blade_chord_root);
        chord2 = blade_chord_root + (i + 1) / (segments - 1) * (blade_chord_tip - blade_chord_root);
        
        // Calculate twist angle at this position (linear twist)
        angle1 = pitch_angle + t * twist_angle;
        angle2 = pitch_angle + (i + 1) / (segments - 1) * twist_angle;
        
        // Calculate thickness ratio (thinner toward tip)
        thickness_ratio1 = blade_thickness / chord1 * (1 - 0.3 * t);
        thickness_ratio2 = blade_thickness / chord2 * (1 - 0.3 * (i + 1) / (segments - 1));
        
        // Create segment by hulling two cross-sections
        hull() {
            translate([0, 0, z1])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness_ratio1, camber, angle1);
                    
            translate([0, 0, z2])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness_ratio2, camber, angle2);
        }
    }
}

// Create blade with root transition
module complete_blade() {
    union() {
        // Main blade
        propeller_blade();
        
        // Root transition to hub (simplified fillet)
        translate([0, 0, 0])
        rotate_extrude(angle = 360)
        polygon([
            [0, 0],
            [0, blade_length * 0.05],
            [blade_chord_root * 0.3, blade_length * 0.02],
            [blade_chord_root * 0.4, 0]
        ]);
    }
}

// Generate the blade
complete_blade();

// Uncomment to see the blade with hub attachment
/*
difference() {
    union() {
        complete_blade();
        // Hub cylinder
        color("gray")
        cylinder(h=10, r=blade_chord_root * 0.5, center=true, $fn=32);
    }
    
    // Hub mounting hole
    color("red")
    cylinder(h=12, r=3, center=true, $fn=32);
}
*/
                ```
                

                Example ID: modern_d16f0c88
                Score: 0.410
                Description: I want a drone propeller
                Code:
                ```scad
                // Aerodynamic Drone Propeller
// Parametric design with optimized airfoil profile and balanced structure

/* CUSTOMIZABLE PARAMETERS */
// Basic dimensions
prop_diameter = 100;    // Propeller diameter (mm)
hub_diameter = 10;      // Hub diameter (mm)
hub_height = 8;         // Hub height (mm)
num_blades = 3;         // Number of blades
shaft_diameter = 5;     // Motor shaft diameter (mm)

// Blade parameters
blade_chord_root = 15;  // Width at blade root (mm)
blade_chord_tip = 6;    // Width at blade tip (mm)
blade_max_thickness = 2;// Maximum thickness (mm)
pitch_angle = 25;       // Base pitch angle (degrees)
twist_angle = 15;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.04;  // Airfoil camber (0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.8; // Controls how quickly the blade tapers (0.5-1.0)
lift_efficiency = 1.2;  // Multiplier for lift curvature shape (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution
blade_segments = 20;    // Number of segments along blade length
airfoil_resolution = 24;// Points in airfoil cross-section

/* DERIVED VARIABLES */
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

/* MODULES */

// Airfoil profile generator
module airfoil_section(chord, thickness, camber, angle) {
    // Create upper and lower curves of airfoil
    upper_points = [for (i = [0:airfoil_resolution]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [airfoil_resolution:-1:0]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments
    for (i = [0:blade_segments-1]) {
        // Position along blade
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position (non-linear taper for better efficiency)
        chord1 = blade_chord_root * (1 - t * (1 - blade_chord_tip/blade_chord_root) * pow(t, tip_taper_factor));
        chord2 = blade_chord_root * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_root) * pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip)
        thickness1 = blade_max_thickness * (1 - 0.7 * t);
        thickness2 = blade_max_thickness * (1 - 0.7 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/4, d1 = hub_diameter, d2 = hub_diameter * 0.7, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/4, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_root * 0.6);
            
            translate([blade_root_offset - blade_chord_root * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_root * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Structural integrity to withstand flight forces and protect internal components
- Weight optimization to maximize flight time and maneuverability
- Aerodynamic considerations to reduce drag and improve stability
- Modularity for easy assembly, repair, and component replacement
- Vibration dampening to protect sensitive electronics and improve flight stability
- Thermal management for electronic components
- Crash resistance and impact absorption capabilities
- Code Structure: module structure
- Code Structure: algorithms for structural analysis
- Implementation Technique: pattern
- Implementation Technique: translate
- Implementation Technique: scale
- Implementation Technique: union
- Implementation Technique: extrude
                    
                    SHAPE COMPONENTS:
                    - Center hub/body for housing main electronics and battery
- Arms extending from center hub to support motors and propellers
- Motor mounts at arm ends with specific mounting patterns
- Landing gear or skids for takeoff/landing protection
- Top and bottom plates/covers for component protection
- Internal mounting points for flight controller, ESCs, and other electronics
- Cable management channels and routing pathways
- Propeller guards (optional for safety)
                    
                    IMPLEMENTATION STEPS:
                    1. Define technical specifications (dimensions, weight targets, payload capacity)
2. Select appropriate materials based on strength-to-weight requirements
3. Create basic frame layout with proper motor-to-motor distances
4. Design the central hub with mounting provisions for electronics
5. Model the arms with appropriate cross-sectional geometry for strength
6. Incorporate motor mounts with standardized mounting patterns
7. Design and integrate landing gear/skids
8. Add internal mounting features for electronics and battery
9. Implement cable routing and management solutions
10. Create protective covers for electronics compartments
11. Optimize design through iterative structural analysis
12. Prepare final model for 3D printing with appropriate tolerances
13. Validate design through physical prototyping and testing

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "utility" type. Here's a suggested structure:
                
                ```scad
                
        module frame(height=10, width=20, depth=15, wall_thickness=2) {
            // Utility object with functional features
            difference() {
                union() {
                    // Add your code here
                    // Add your code here
                }
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
frameSize = 250; // Total diagonal motor-to-motor distance in mm (standard sizes are 150, 180, 210, 250, 350)
armLength = 160; // Length of each arm extending from the center in mm
armWidth = 30; // Width of each arm in mm
baseWidth = 100; // Width of the central frame body in mm
baseLength = 180; // Length of the central frame body in mm
baseThickness = 3; // Thickness of the frame plates in mm
motorMountDiameter = 16; // Diameter of the motor mounting holes in mm
FC_mountingPattern = 30.5; // Flight controller mounting pattern in mm (common values: 20, 30.5, 35)
frame_diameter = 220; // Overall diameter of the drone frame in millimeters (measured from motor to motor diagonally)
arm_thickness = 4.5; // Thickness of the frame arms in millimeters, affects structural rigidity and weight
center_hub_diameter = 50; // Diameter of the central hub that houses electronics and battery in millimeters
motor_mount_size = 16; // Dimension in millimeters for the motor mounting pattern (standard sizes include 16x16mm, 19x19mm, etc.)
arm_profile = round; // Shape profile of the arms (options: round, square, h_beam, i_beam)
prop_size_max = 5; // Maximum propeller size in inches the frame is designed to accommodate


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: Novel Drone Design Using an Optimization Software with 3D Model ...
Content: The drone frame consists of four main parts, which are the center top cover (50 g), the side top cover (10 g), the middle cover (30 g), and the
---

Title: Assembling procedure for the different drone components.
Content: The 3D drone layout design, accomplished using SOLIDWORKS, enhances understanding by showcasing all three different configurations of PULSAR's structure.
---

Title: Drone Frame Evolution - LinkedIn
Content: The primary function of frames is to protect all of the components of a drone. Types of Drone Frames. Drone frames come in a range of
---

Title: [PDF] Modeling And 3D Printing Of Drone Frame - iarjset
Content: 8.066Peer-reviewed / Refereed journalVol. 11, Issue 10, October 2024 DOI: 10.17148/IARJSET.2024.111029  IARJSET This work is licensed under a Creative Commons Attribution 4.0 International License 193 ISSN (O) 2393-8021, ISSN (P) 2394-1588 3.2 Problem Statement Requirement Definition: Establish objectives and constraints for the drone frame, including frame size, weight, material, and payload capacity. Conceptual Design: Create a conceptual layout incorporating motor placement, propeller [...] printing allows for the creation of complex geometries that would be impossible or expensive to produce using traditional manufacturing methods. Additionally, the ability to test and iterate drone frame designs quickly using 3D printing ensures better design optimization, reducing production time and costs. The application of advanced materials such as carbon fiber reinforced filaments, PLA, ABS, and PETG also enhances the durability, strength, and performance of 3D-printed drone frames. By [...] The future scope of modeling and 3D printing of drone frames is promising, with several advancements on the horizon: 1. Material Innovations: The development of new, stronger, and lighter 3D printing materials is expected to improve the overall performance and durability of drone frames. For example, incorporating nanomaterials or carbon fiber composites could lead to drones that are both lighter and more resistant to impact, temperature extremes, and wear. 2. Multi-Material Printing: Future
---

Title: Novel Drone Design Using an Optimization Software with 3D Model ...
Content: The drone frame consists of four main parts, which are the center top cover (50 g), the side top cover (10 g), the middle cover (30 g), and the
---


USER REQUEST:
frame of a drone

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a sword
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: pirate_886ada52
                Score: 0.707
                Description: I want a pirate sword please
                Code:
                ```scad
                // Pirate Cutlass Model
// Units are in mm

// Blade parameters
blade_length = 80;
blade_width_base = 5;
blade_width_tip = 3;
blade_thickness = 1.2;
blade_curve = 15;  // How much the blade curves
edge_bevel = 0.4;  // Sharpness of the blade edge

// Guard parameters
guard_width = 20;
guard_height = 8;
guard_thickness = 3;
guard_curve = 4;   // Curvature of the guard

// Grip parameters
grip_length = 18;
grip_diameter = 3.5;
grip_taper = 0.9;  // Slight taper for the grip

// Pommel parameters
pommel_diameter = 5;
pommel_height = 3;

// Detail parameters
$fn = 40;  // Smoothness of curved surfaces

// Module for curved blade
module cutlass_blade() {
    // Main blade shape with curve
    difference() {
        union() {
            // Create curved blade profile
            for (i = [0:1:blade_length]) {
                // Calculate curved position
                x_offset = pow(i/blade_length, 2) * blade_curve;
                
                // Calculate blade width at this point (tapers toward tip)
                current_width = blade_width_base - (blade_width_base - blade_width_tip) * (i/blade_length);
                
                // Place a segment of the blade
                translate([x_offset, 0, i])
                    cube([blade_thickness, current_width, 1.01], center=true);
            }
        }
        
        // Edge bevel (on one side only - single-edged cutlass)
        for (i = [0:1:blade_length]) {
            x_offset = pow(i/blade_length, 2) * blade_curve;
            current_width = blade_width_base - (blade_width_base - blade_width_tip) * (i/blade_length);
            
            translate([x_offset, (current_width/2) - edge_bevel, i])
                rotate([0, 0, 45])
                    cube([edge_bevel*2, edge_bevel*2, 1.1], center=true);
        }
        
        // Fuller (blood groove) along part of the blade
        for (i = [5:1:blade_length*0.7]) {
            x_offset = pow(i/blade_length, 2) * blade_curve;
            translate([x_offset, -0.5, i])
                rotate([0, 0, 0])
                    cylinder(h=1.1, r=0.5, center=true);
        }
    }
}

// Module for basket hand guard (simplified for OpenSCAD)
module guard() {
    difference() {
        union() {
            // Main guard
            translate([0, 0, 0])
                difference() {
                    // Outer shell
                    scale([1, 1, 0.4])
                        sphere(r=guard_width/2);
                    
                    // Cut the bottom half
                    translate([0, 0, -guard_width/2])
                        cube([guard_width+1, guard_width+1, guard_width], center=true);
                    
                    // Cut the back
                    translate([-guard_width/2, 0, 0])
                        cube([guard_width, guard_width+1, guard_width+1], center=true);
                    
                    // Hollow inside
                    scale([0.8, 0.8, 0.35])
                        sphere(r=guard_width/2);
                }
            
            // Crossguard piece
            rotate([0, 90, 0])
                cylinder(h=guard_width*0.8, d=guard_thickness, center=true);
        }
        
        // Slot for the blade
        translate([blade_thickness/2, 0, guard_height/4])
            cube([blade_thickness+0.5, blade_width_base+0.5, guard_height], center=true);
        
        // Slot for the grip
        translate([0, 0, -guard_height/4])
            cylinder(h=guard_height, d=grip_diameter+0.5, center=true);
    }
}

// Module for the grip with texture
module grip() {
    difference() {
        // Basic grip cylinder with taper
        cylinder(h=grip_length, d1=grip_diameter, d2=grip_diameter*grip_taper);
        
        // Texture pattern (spiral wrapping)
        for (i = [0:15:360*3]) {
            rotate([0, 0, i])
                translate([grip_diameter/2, 0, i/45])
                    rotate([0, 90, 0])
                        cylinder(h=0.5, d=0.8, center=true);
        }
    }
}

// Module for the pommel
module pommel() {
    union() {
        // Main pommel body
        sphere(d=pommel_diameter);
        
        // Decorative top piece
        translate([0, 0, pommel_diameter/2 - 0.5])
            cylinder(h=pommel_height/2, d1=pommel_diameter*0.6, d2=pommel_diameter*0.3);
            
        // Decorative bottom ring
        translate([0, 0, -pommel_diameter/4])
            rotate_extrude()
                translate([pommel_diameter/2-0.2, 0, 0])
                    circle(d=1);
    }
}

// Assemble the pirate sword (cutlass)
module pirate_sword() {
    // Blade
    color("silver")
        translate([blade_thickness/2, 0, grip_length + guard_height/2])
            cutlass_blade();
    
    // Guard
    color("gold")
        translate([0, 0, grip_length])
            guard();
    
    // Grip
    color("brown")
        grip();
    
    // Pommel
    color("gold")
        translate([0, 0, 0])
            pommel();
}

// Render the pirate sword
pirate_sword();
                ```
                

                Example ID: sword_a112e8f9
                Score: 0.650
                Description: I want a sword
                Code:
                ```scad
                // Medieval Sword Model
// This model creates a basic sword with blade, crossguard, grip and pommel

// Sword dimensions
blade_length = 70;
blade_width = 4;
blade_thickness = 0.8;
blade_taper = 0.7;  // How much the blade tapers toward the tip

crossguard_width = 15;
crossguard_height = 2;
crossguard_thickness = 1.5;

grip_length = 12;
grip_diameter = 3;
grip_taper = 0.9;   // Slight taper for the grip

pommel_diameter = 4;
pommel_height = 2;

fuller_depth = 0.2;
fuller_width = 1.5;
fuller_length = blade_length * 0.7;

// Module for the blade with fuller (blood groove)
module blade() {
    difference() {
        // Main blade shape with taper
        hull() {
            translate([0, 0, 0])
                cube([blade_width, blade_thickness, 0.01], center=true);
            
            translate([0, 0, blade_length])
                cube([blade_width * blade_taper, blade_thickness * blade_taper, 0.01], center=true);
        }
        
        // Fuller (blood groove)
        translate([0, 0, blade_length * 0.2])
            scale([fuller_width, fuller_depth, fuller_length])
                rotate([90, 0, 0])
                    cylinder(h=3, r=1, center=true, $fn=30);
    }
    
    // Blade edge bevels
    difference() {
        hull() {
            translate([0, 0, 0])
                cube([blade_width, blade_thickness, 0.01], center=true);
            
            translate([0, 0, blade_length])
                cube([blade_width * blade_taper, blade_thickness * blade_taper, 0.01], center=true);
        }
        
        // Side bevels
        hull() {
            translate([0, 0, 0])
                cube([blade_width - 0.5, blade_thickness - 0.4, 0.01], center=true);
            
            translate([0, 0, blade_length])
                cube([(blade_width - 0.5) * blade_taper, 
                     (blade_thickness - 0.4) * blade_taper, 0.01], center=true);
        }
    }
}

// Module for the crossguard
module crossguard() {
    difference() {
        // Main crossguard body
        cube([crossguard_width, crossguard_thickness, crossguard_height], center=true);
        
        // Slot for the blade
        cube([blade_width + 0.2, blade_thickness + 0.2, crossguard_height + 1], center=true);
    }
}

// Module for the grip with texture
module grip() {
    difference() {
        // Basic grip cylinder with taper
        hull() {
            cylinder(h=0.01, d=grip_diameter, center=true, $fn=30);
            translate([0, 0, grip_length])
                cylinder(h=0.01, d=grip_diameter * grip_taper, center=true, $fn=30);
        }
        
        // Texture pattern (diagonal grooves)
        for (i = [-20:4:20]) {
            rotate([0, 0, i])
                translate([0, 0, grip_length/2])
                    rotate([0, 2, 0])
                        cube([grip_diameter * 2, 0.2, grip_length * 1.2], center=true);
        }
    }
}

// Module for the pommel
module pommel() {
    union() {
        // Main pommel body
        sphere(d=pommel_diameter, $fn=30);
        
        // Pommel cap
        translate([0, 0, pommel_diameter/2 - 0.2])
            cylinder(h=pommel_height/2, d1=pommel_diameter, d2=pommel_diameter * 0.8, $fn=30);
    }
}

// Assemble the sword
module sword() {
    // Blade
    color("silver")
        translate([0, 0, crossguard_height/2 + grip_length + pommel_height])
            blade();
    
    // Crossguard
    color("gold")
        translate([0, 0, grip_length + pommel_height])
            crossguard();
    
    // Grip
    color("brown")
        translate([0, 0, pommel_height])
            grip();
    
    // Pommel
    color("gold")
        pommel();
}

// Render the sword
sword();
                ```
                

                Example ID: unknown_7ae6d851
                Score: 0.400
                Description: I want a blade of a drone propeller
                Code:
                ```scad
                //pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 12;

//Resolution steps between stations
SectRes = 10;  

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Spinner hinge radius at pin
SpinHPinRad = 34;

//Diameter of hinge pin
SpinPinD = 3;

//Blade base diameter
SpinHubD = 6;

//Spinner hinge width
SpinHL = 7;

//Hinge Pin Height Adjuster
SpinHubVTweak = 0.25;

//Holder variables for calculated Blade section parameters.  Ignore these.
Poz1 =0;
Poz2 = 0;
StrtAngi = 0;
EndAngi = 0;
StepLi = 0;
StrtWi = 0;
EndWi = 0; 


// Blade airfoil profile. Change with caution.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];


function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

StubSteps = (Diam/(16*SectL)>SpinHPinRad*1.2)?round(Diam/(16*SectL)):round(SpinHubD*1.1/SectL);

BldStubLn = 0.98*StubSteps * SectL; 
BldStrtPoint = round((SpinHPinRad+BldStubLn+0.5*SpinHubD)/SectL)-1;

function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
    rotate([0,90,0])
    cylinder (r =0.5*SpinHubD, h = SpinHL, center = true, $fn = 100);
}



module Hubcutter()
{
    union()
    {
        // Pin hole
        translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r = 0.5*SpinPinD, h = SpinHL*4, center = true, $fn = 100);
        
        //The two face shavers
        translate([1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 0.6*SpinHubD, r2 = 2.5*SpinHubD, h = SpinHL*2, center = true, $fn = 100);
        
        translate([-1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 5*SpinHubD, r2 = 0.6*SpinHubD, h = SpinHL*2, center = true, $fn = 100);        

    }
}


module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    union()
    {
    for(i = [BldStrtPoint:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module Hinge()
{
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*(SpinHPinRad+BldStubLn+0.5*SpinHubD)/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        EndAngi = atan(Pitch/(2*PI*(SpinHPinRad+BldStubLn+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+BldStubLn+0.5*SpinHubD);
        StrtAngi = atan(Pitch/(2*PI*(SpinHPinRad+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+0.5*SpinHubD);
        

            translate([0,-SpinHPinRad-0.5*SpinHubD,0])        
            rotate([90,0,0])
            Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);

    }
}


translate([0,SpinHPinRad,0])
difference()
{
    union()
    {
        Hinge();
        rotate([90,0,0])BladeBuilder();
    }
    Hubcutter();
}
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Balance between form and function (weight distribution, center of gravity)
- Historical accuracy vs. artistic interpretation
- Scale and proportions relative to intended use
- Material representation (metal reflectivity, texture mapping)
- Edge geometry (bevels, cutting surfaces)
- Structural integrity in the 3D mesh
- Code Structure: module structures
- Code Structure: algorithms for mesh optimization
- Code Structure: parametric modeling techniques
- Implementation Technique: pattern
- Implementation Technique: scale
- Implementation Technique: rotate
- Implementation Technique: difference
- Implementation Technique: mirror
- Implementation Technique: union
- Implementation Technique: minkowski
                    
                    SHAPE COMPONENTS:
                    - Blade (primary cutting/thrusting surface)
- Guard/Crossguard (hand protection)
- Grip/Handle (ergonomic holding area)
- Pommel (counterweight at the end of the handle)
- Tang (internal structure connecting blade to handle)
- Fuller/Blood groove (weight reduction channel)
- Point/Tip (piercing end)
- Ricasso (unsharpened portion near the guard)
                    
                    IMPLEMENTATION STEPS:
                    1. Research specific sword type/style (medieval, katana, rapier, etc.)
2. Create reference collection (blueprints, photographs, measurements)
3. Model the basic blade profile using polygon modeling techniques
4. Develop the guard and handle components
5. Add the pommel and decorative elements
6. Create proper edge geometry with bevels and sharpening
7. Apply appropriate material properties (metallic shaders, reflectivity)
8. Add surface details (engravings, wear patterns, patina)
9. Optimize mesh topology for animation or game engine if needed
10. Test renders from multiple angles to verify proportions and details

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "mechanical" type. Here's a suggested structure:
                
                ```scad
                
        module sword(height=10, width=20, depth=15, wall_thickness=2) {
            union() {
                // Base shape based on: Blade (primary cutting/thrusting surface), Guard/Crossguard (hand protection), Grip/Handle (ergonomic holding area), Pommel (counterweight at the end of the handle), Tang (internal structure connecting blade to handle), Fuller/Blood groove (weight reduction channel), Point/Tip (piercing end), Ricasso (unsharpened portion near the guard)
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
blade_length = 750; // Length of the blade in millimeters, affects overall reach and weight distribution
blade_width = 40; // Width of the blade at its widest point in millimeters, affects cutting capability and weight
blade_taper = 0.7; // How much the blade tapers toward the tip (0.0-1.0, where 1.0 means no taper)
blade_thickness = 1.0; // Thickness of the blade in mm
blade_curve = 0; // Curvature of the blade in degrees (0 for straight blade, positive for curved)
crossguard_width = 18; // Width of the crossguard in mm
grip_length = 150; // Length of the handle/grip in millimeters, affects hand placement and wielding style
pommel_diameter = 4; // Diameter of the pommel (end cap of the handle) in mm
guard_width = 160; // Width of the crossguard in millimeters, determining hand protection area
sword_style = medieval; // Overall style of the sword (options: medieval, katana, rapier, etc.)
pommel_size = 50; // Diameter of the pommel in millimeters, affects balance and aesthetics


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: Sword Parts For Assembly by Meowsteria | Download free STL model
Content: You can print these sword parts and assemble your own sword. NOTE: This is mainly meant to be decorative. DO NOT SIT ON. | Download free 3D printable STL
---

Title: What makes a sword? Length? Purpose? What? - BladeForums.com
Content: Finally, there is no way to get around this: The design function of a sword is to cleave human flesh and bone. It may be repugnant to
---

Title: Glamdring Sword 3D Model - FlatPyramid
Content: Specifications  Vertices: 25349  Polygons: 25042  Geometry: NURBS  Animated: No  Materials: Yes  Rigged: No  Textures: Yes  File-formats: 3D
---


USER REQUEST:
blade profile with guard and handle, metal material, sharp edge geometry

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a camera
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: unknown_65b1e79a
                Score: 0.622
                Description: I want a camera lens
                Code:
                ```scad
                // Camera Lens Model
// Author: OpenSCAD Expert
// Description: A parametric DSLR camera lens with realistic details

// Main parameters
lens_diameter = 70;      // Outer diameter of the lens barrel
lens_length = 100;       // Total length of the lens
mount_diameter = 65;     // Diameter of the lens mount
front_element_diameter = 58; // Diameter of the front glass element
focus_ring_width = 25;   // Width of the focus ring
focus_ring_depth = 3;    // Depth of the knurling on the focus ring
aperture_ring_width = 15; // Width of the aperture ring
aperture_ring_depth = 2; // Depth of the knurling on the aperture ring
knurl_count = 60;        // Number of knurls around the rings

// Colors
color_barrel = [0.2, 0.2, 0.2];    // Black lens barrel
color_ring = [0.25, 0.25, 0.25];   // Dark gray rings
color_glass = [0.8, 0.9, 0.95, 0.6]; // Slightly blue transparent glass
color_mount = [0.3, 0.3, 0.3];     // Dark gray mount
color_red = [0.8, 0.2, 0.2];       // Red accent color for lens markings

// Module for creating the lens barrel
module lens_barrel() {
    color(color_barrel)
    difference() {
        cylinder(h=lens_length, d=lens_diameter, $fn=100);
        translate([0, 0, -1])
            cylinder(h=lens_length+2, d=lens_diameter-4, $fn=100);
    }
}

// Module for lens glass elements
module lens_element(diameter, curvature, thickness) {
    color(color_glass)
    translate([0, 0, 0])
    union() {
        // Main cylindrical part of the element
        cylinder(h=thickness, d=diameter, $fn=100);
        
        // Convex front part
        translate([0, 0, thickness])
            scale([1, 1, curvature])
            sphere(d=diameter, $fn=100);
    }
}

// Module for creating knurled rings (focus and aperture)
module knurled_ring(diameter, width, depth, knurls) {
    color(color_ring)
    difference() {
        cylinder(h=width, d=diameter, $fn=100);
        
        // Create the knurling pattern
        for(i = [0 : knurls - 1]) {
            rotate([0, 0, i * (360 / knurls)])
            translate([diameter/2 - depth/2, 0, -1])
            rotate([0, 0, 45])
            cube([depth, depth, width+2]);
        }
        
        // Hollow out the inside
        translate([0, 0, -1])
            cylinder(h=width+2, d=diameter-8, $fn=100);
    }
}

// Module for lens mount (bayonet style)
module lens_mount() {
    color(color_mount)
    difference() {
        cylinder(h=10, d=mount_diameter, $fn=100);
        
        // Hollow out the inside
        translate([0, 0, -1])
            cylinder(h=12, d=mount_diameter-8, $fn=100);
        
        // Create bayonet notches
        for(i = [0 : 2]) {
            rotate([0, 0, i * 120])
            translate([mount_diameter/2 - 4, 0, 5])
            cube([10, 8, 5], center=true);
        }
    }
    
    // Add mounting pins
    for(i = [0 : 2]) {
        rotate([0, 0, i * 120 + 60])
        translate([mount_diameter/2 - 5, 0, 3])
        rotate([90, 0, 0])
        cylinder(h=3, d=4, center=true, $fn=20);
    }
}

// Module for front lens cap
module lens_cap() {
    color([0.15, 0.15, 0.15])
    difference() {
        union() {
            cylinder(h=3, d=lens_diameter+2, $fn=100);
            cylinder(h=8, d=front_element_diameter+6, $fn=100);
        }
        
        translate([0, 0, -1])
            cylinder(h=10, d=front_element_diameter+2, $fn=100);
    }
}

// Module for branding details
module branding() {
    // Red dot (brand logo)
    color(color_red)
    translate([lens_diameter/2 - 1.5, 0, lens_length - 15])
    rotate([0, 90, 0])
    cylinder(h=3, d=5, $fn=20);
    
    // Lens markings (simplified)
    color([0.9, 0.9, 0.9])
    for(i = [0 : 5]) {
        rotate([0, 0, i * 60])
        translate([lens_diameter/2 - 0.5, 0, lens_length - focus_ring_width - 10])
        cube([1, 1, 3]);
    }
}

// Module for aperture label
module aperture_label() {
    color([0.9, 0.9, 0.9])
    for(i = [0 : 4]) {
        angle = i * 20;
        rotate([0, 0, angle])
        translate([lens_diameter/2 - 0.5, 0, 50])
        cube([1, 1.5, 2]);
        
        // f-numbers
        rotate([0, 0, angle + 10])
        translate([lens_diameter/2 - 0.5, 0, 50])
        cube([1, 0.5, 2]);
    }
}

// Assemble the complete lens
module camera_lens() {
    // Main components
    lens_barrel();
    
    // Front glass element
    translate([0, 0, lens_length - 5])
        lens_element(front_element_diameter, 0.2, 3);
    
    // Secondary glass element
    translate([0, 0, lens_length - 20])
        lens_element(front_element_diameter - 10, -0.15, 2);
    
    // Focus ring
    translate([0, 0, lens_length - focus_ring_width - 20])
        knurled_ring(lens_diameter, focus_ring_width, focus_ring_depth, knurl_count);
    
    // Aperture ring
    translate([0, 0, lens_length - focus_ring_width - aperture_ring_width - 25])
        knurled_ring(lens_diameter - 5, aperture_ring_width, aperture_ring_depth, knurl_count);
    
    // Lens mount at the back
    translate([0, 0, 0])
        lens_mount();
    
    // Branding and labels
    branding();
    aperture_label();
}

// Render the lens
camera_lens();

// Uncomment to show the lens cap
// translate([0, 0, lens_length])
//     lens_cap();
                ```
                

                Example ID: unknown_0c41abcf
                Score: 0.424
                Description: I want a propeller
                Code:
                ```scad
                // Propeller Design
// Parameters for customization
$fn = 100;  // Resolution for circular objects

// Main parameters
num_blades = 3;         // Number of propeller blades
hub_radius = 10;        // Radius of central hub
hub_height = 15;        // Height of central hub
shaft_radius = 3;       // Radius of shaft hole
blade_length = 50;      // Length of each blade
blade_width = 15;       // Maximum width of blade
blade_thickness = 3;    // Maximum thickness at blade root
twist_angle = 30;       // Twist angle from root to tip (degrees)
airfoil_camber = 0.1;   // Camber ratio for airfoil shape

// Module for creating a single propeller blade with twist and airfoil profile
module blade() {
    linear_extrude(height = blade_length, twist = -twist_angle, slices = 40, scale = 0.5) {
        union() {
            // Airfoil shape
            translate([-blade_width/4, 0, 0])
                scale([1, blade_thickness/blade_width, 1])
                    ellipse(blade_width/2, blade_width/2);
                
            // Add slight camber for improved aerodynamics
            translate([0, -blade_thickness * airfoil_camber, 0])
                scale([0.8, 0.2, 1])
                    circle(blade_width/2);
        }
    }
}

// Module for creating an ellipse
module ellipse(width, height) {
    scale([width, height, 1]) circle(1);
}

// Module for creating the central hub with shaft hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(r1 = hub_radius, r2 = hub_radius * 0.8, h = hub_height);
            
            // Hub base (for strength)
            cylinder(r = hub_radius * 1.2, h = hub_height * 0.2);
            
            // Hub top cap
            translate([0, 0, hub_height])
                cylinder(r1 = hub_radius * 0.8, r2 = hub_radius * 0.5, h = hub_height * 0.2);
        }
        
        // Shaft hole through center
        translate([0, 0, -1])
            cylinder(r = shaft_radius, h = hub_height + 2);
            
        // Setscrew hole
        translate([0, 0, hub_height/2])
            rotate([0, 90, 0])
                cylinder(r = shaft_radius/2, h = hub_radius + 1);
    }
}

// Assemble the propeller
module propeller() {
    // Central hub
    color("SlateGray") hub();
    
    // Blades
    color("LightSteelBlue")
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades])
            translate([hub_radius * 0.8, 0, hub_height * 0.6])
                rotate([0, 90, 0])
                    blade();
    }
}

// Create the propeller
propeller();
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Form follows function - design must accommodate all camera components (lens, sensor, processor)
- Ergonomics and user interaction - comfortable grip, intuitive button placement
- Visual fidelity - balance between polygon count and performance
- Level of Detail (LOD) management - higher detail for close-up views, lower for distant views
- Material properties - reflective surfaces, textured grips, transparent elements
- Scale accuracy - maintaining proper proportions relative to human hands
- Code Structure: module structure
- Code Structure: algorithms
- Implementation Technique: minkowski
- Implementation Technique: union
- Implementation Technique: mirror
- Implementation Technique: translate
- Implementation Technique: scale
                    
                    SHAPE COMPONENTS:
                    - Main body - rectangular prism with rounded edges for the camera body
- Lens assembly - cylindrical protrusion with concentric rings and glass elements
- Viewfinder - small rectangular or circular element on top/back
- Control elements - buttons, dials, and switches with proper affordances
- Display screen - flat rectangular surface on the back
- Battery compartment - rectangular section with access panel
- Grip area - ergonomic curved surface with textured material
- Flash unit - small rectangular or rounded element on top
                    
                    IMPLEMENTATION STEPS:
                    1. Create reference collection - gather photos and technical specifications of real cameras
2. Block out primary shapes - establish basic proportions and overall silhouette
3. Refine major components - develop lens, body, grip, and display with appropriate geometry
4. Add secondary details - buttons, dials, ports, and other interface elements
5. Implement proper edge flow - ensure topology supports deformation and detail where needed
6. Create UV maps - prepare for proper texturing with unwrapped coordinates
7. Apply materials and textures - assign appropriate shaders for different camera components
8. Optimize polygon count - create LOD versions for different viewing distances
9. Rig movable parts - add articulation to buttons, dials, and opening compartments
10. Test in intended environment - verify appearance and performance in final application context

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "electronic" type. Here's a suggested structure:
                
                ```scad
                
        module camera(height=10, width=20, depth=15, wall_thickness=2) {
            // Electronic device with case and features
            union() {
                // Add your code here
                // Add your code here
            }
            // Cutouts for buttons, ports, etc.
            difference() {
                // Add your code here
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
body_width = 150; // Width of the camera body in mm
body_height = 90; // Height of the camera body in mm
body_depth = 70; // Depth/thickness of the camera body in mm
lens_diameter = 42; // Diameter of the lens assembly in mm
lens_protrusion = 30; // How far the lens protrudes from the camera body in mm
grip_depth = 15; // Depth of the ergonomic grip on the side of the camera in mm
rounded_corners = 8; // Radius of rounded corners on the camera body in mm
include_viewfinder = true; // Whether to include a viewfinder on top of the camera
body_dimensions = [120, 70, 40]; // Dimensions [width, height, depth] in mm of the main camera body
corner_radius = 5; // Radius for rounded edges of the camera body in mm
viewfinder_size = [25, 20]; // Dimensions [width, height] in mm of the viewfinder element


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: Basic geometric shapes in 3d modeling - CGTyphoon
Content: The basic shapes are square, triangle and circle. Let's have a look at the most common shapes using in 3d modeling. Triangle (3 sides). It is a simple geometric
---

Title: 3D model of the camera structure. - ResearchGate
Content: mechanical structure of the camera that holds all the components together has been designed with computer aided design (CAD) software and prototyped using a 3D
---

Title: Digital SLR Cameras Explained: Design Innovations and User ...
Content: Key considerations include the size and weight of the camera, which affect portability; the placement of control buttons, which influences
---

Title: Polygon Count Reduction 3d Models Decimate Remesh Modifiers ...
Content: The demand in sectors like gaming, virtual reality, simulation, and film for complex detailed models with 3D modeling and rendering technologies has grown very high. While making a high resolution model gives highly realistic and immersive experiences, it leads to significant technical issues due to huge polygon counts. A polygon count is that number of triangles, quads, or other polygons forming its structure for a model; in other words, it forms the main determining factor concerning system [...] level of visual quality in areas where it matters most while reducing system resources usage.Employing Level of Detail (LOD): The LOD changes the polygon count according to how far the object is from the camera. Like in case of character models, for near shots it contains high poly detailed models and a stoschek of low poly when it's at a larger distance where the camera focuses on this point. This is greatly utilized in games and in VR as it saves all those processing requirements while [...] some key concepts in polygon count optimization will be provided with definitions, impacts, and the difference between high-poly and low-poly models.3.1 Definition of Polygon Count and Its Resource Dependence on the SystemPolygon Count: This means the count of polygons-mostly triangles or quads-used to describe the surface of your 3D model. One of the easiest ways to describe how detailed a model is, this directly relates to its geometry.Importance of Polygon Count in 3D Graphics: A model with
---


USER REQUEST:
camera digital

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a drone propeller
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: unknown_9af337fa
                Score: 0.785
                Description: I want a drone propeller with 4 blades, each of it with 6 inches and diameter of 9 inches
                Code:
                ```scad
                //pitch (inches)
PitchI = 6;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 4;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_fdda84c1
                Score: 0.776
                Description: Parametric drone propeller with multiple blades
                Code:
                ```scad
                //Multipropv6-ThgV.scad
//A parametric generator for multiblade propellors.

// Created by Hamish Trolove - Feb 2019
//www.techmonkeybusiness.com

//Licensed under a Creative Commons license - attribution
// share alike. CC-BY-SA

//No extra libraries are required and it works under
//OpenSCAD 2015 and later.  This script will not work
//for older versions of OpenSCAD

//Airfoils:
// Points from naca4412.dat in the archive: http://m-selig.ae.illinois.edu/ads/archives/coord_seligFmt.tar.gz
// Not necessarily in the same order as in: http://m-selig.ae.illinois.edu/ads/coord/naca4412.dat

//pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 5;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: _15fd3a5c
                Score: 0.719
                Description: I want a blade of propeller
                Code:
                ```scad
                // Propeller Blade Model
// This creates a single aerodynamic propeller blade with airfoil profile
// Parameters can be adjusted to change the blade's size, shape and pitch

/* PARAMETERS */
// Main dimensions
blade_length = 100;     // Length of the blade from hub to tip
blade_chord_root = 25;  // Width of blade at root (near hub)
blade_chord_tip = 15;   // Width of blade at tip
blade_thickness = 3;    // Maximum thickness of the blade

// Airfoil and twist properties
twist_angle = 30;       // Total twist angle from root to tip (degrees)
pitch_angle = 20;       // Base pitch angle (degrees)
camber = 0.06;          // Airfoil camber (curvature)

// Resolution parameters
segments = 30;          // Number of segments along blade length
airfoil_points = 24;    // Points to define airfoil cross-section

/* MODULES */

// NACA-inspired airfoil profile generator
module airfoil_profile(chord, thickness_ratio, camber_ratio, angle) {
    points = [for (i = [0:airfoil_points]) 
        let(
            t = i / airfoil_points,
            x = chord * (1 - cos(t * 180)),
            // Thickness distribution (symmetric part)
            thick = thickness_ratio * chord * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber_ratio * chord * sin(t * 180),
            // Upper and lower surfaces
            upper = [x, yc + thick, 0],
            lower = [x, yc - thick, 0]
        )
        (i <= airfoil_points/2) ? upper : lower
    ];
    
    // Rotate to account for pitch and twist
    rotate([0, 0, angle])
    polygon(points = [for (p = points) [p[0], p[1]]]);
}

// Create a single blade
module propeller_blade() {
    for (i = [0:segments-1]) {
        // Calculate position along blade length
        t = i / (segments - 1);
        z1 = t * blade_length;
        z2 = (i + 1) / (segments - 1) * blade_length;
        
        // Calculate chord at this position (linear taper)
        chord1 = blade_chord_root + t * (blade_chord_tip - blade_chord_root);
        chord2 = blade_chord_root + (i + 1) / (segments - 1) * (blade_chord_tip - blade_chord_root);
        
        // Calculate twist angle at this position (linear twist)
        angle1 = pitch_angle + t * twist_angle;
        angle2 = pitch_angle + (i + 1) / (segments - 1) * twist_angle;
        
        // Calculate thickness ratio (thinner toward tip)
        thickness_ratio1 = blade_thickness / chord1 * (1 - 0.3 * t);
        thickness_ratio2 = blade_thickness / chord2 * (1 - 0.3 * (i + 1) / (segments - 1));
        
        // Create segment by hulling two cross-sections
        hull() {
            translate([0, 0, z1])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness_ratio1, camber, angle1);
                    
            translate([0, 0, z2])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness_ratio2, camber, angle2);
        }
    }
}

// Create blade with root transition
module complete_blade() {
    union() {
        // Main blade
        propeller_blade();
        
        // Root transition to hub (simplified fillet)
        translate([0, 0, 0])
        rotate_extrude(angle = 360)
        polygon([
            [0, 0],
            [0, blade_length * 0.05],
            [blade_chord_root * 0.3, blade_length * 0.02],
            [blade_chord_root * 0.4, 0]
        ]);
    }
}

// Generate the blade
complete_blade();

// Uncomment to see the blade with hub attachment
/*
difference() {
    union() {
        complete_blade();
        // Hub cylinder
        color("gray")
        cylinder(h=10, r=blade_chord_root * 0.5, center=true, $fn=32);
    }
    
    // Hub mounting hole
    color("red")
    cylinder(h=12, r=3, center=true, $fn=32);
}
*/
                ```
                

                Example ID: modern_d16f0c88
                Score: 0.707
                Description: I want a drone propeller
                Code:
                ```scad
                // Aerodynamic Drone Propeller
// Parametric design with optimized airfoil profile and balanced structure

/* CUSTOMIZABLE PARAMETERS */
// Basic dimensions
prop_diameter = 100;    // Propeller diameter (mm)
hub_diameter = 10;      // Hub diameter (mm)
hub_height = 8;         // Hub height (mm)
num_blades = 3;         // Number of blades
shaft_diameter = 5;     // Motor shaft diameter (mm)

// Blade parameters
blade_chord_root = 15;  // Width at blade root (mm)
blade_chord_tip = 6;    // Width at blade tip (mm)
blade_max_thickness = 2;// Maximum thickness (mm)
pitch_angle = 25;       // Base pitch angle (degrees)
twist_angle = 15;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.04;  // Airfoil camber (0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.8; // Controls how quickly the blade tapers (0.5-1.0)
lift_efficiency = 1.2;  // Multiplier for lift curvature shape (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution
blade_segments = 20;    // Number of segments along blade length
airfoil_resolution = 24;// Points in airfoil cross-section

/* DERIVED VARIABLES */
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

/* MODULES */

// Airfoil profile generator
module airfoil_section(chord, thickness, camber, angle) {
    // Create upper and lower curves of airfoil
    upper_points = [for (i = [0:airfoil_resolution]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [airfoil_resolution:-1:0]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments
    for (i = [0:blade_segments-1]) {
        // Position along blade
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position (non-linear taper for better efficiency)
        chord1 = blade_chord_root * (1 - t * (1 - blade_chord_tip/blade_chord_root) * pow(t, tip_taper_factor));
        chord2 = blade_chord_root * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_root) * pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip)
        thickness1 = blade_max_thickness * (1 - 0.7 * t);
        thickness2 = blade_max_thickness * (1 - 0.7 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/4, d1 = hub_diameter, d2 = hub_diameter * 0.7, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/4, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_root * 0.6);
            
            translate([blade_root_offset - blade_chord_root * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_root * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: functional_a7864989
                Score: 0.535
                Description: Realistic propeller, repeller (e.g. used for wind turbines) and wing designs lead to highly organic shapes
                Code:
                ```scad
                // ShortCuts.scad 
// Autor: Rudolf Huttary, Berlin 2015
// last update 2019.07
//
//$fn = 60; 

//show_examples(); 

module show_examples()
	place_in_rect(30, 30)
	{
		Cy(10, 10);  // Cy(r=10, h=10, center=true)
		CyH(h = 10); // half cylinder
		CyH(d=20, h=10); // 
		CyS(h = 10);  // cylinder segment
		CyS(h = 10, w1 = 25, w2 = 75); 
		Cu(10);     // cube(10, center = true)
		Ri(h = 10);  // ring
		RiH(h = 10); // half ring
		RiS(h = 10, w1 = 10); // ring segment
		RiS(h = 10, w1 = 30, w2 = 300); // ring segment 
		Sp();   // sphere
		SpH(10, 30, 30); // half sphere
	}
help(); 

module help() help_shortcuts(); 
module help_ShortCuts() help_shortcuts(); 
  
module help_shortcuts()
{
  h = str("shortcuts.scad\n by Rudolf Huttary\n, 2018.01\n", 
  "help(): shows this help\n",
  "help_shortcuts(): shows this help\n",
  "show_examples(): shows some examples\n",
  "place_in_rect(dx =20, dy=20): places children objects in grid\n",
  "measure(s=10, x=undef, y=undef, z=undef): half transparent cube of given size \n",
  "*Transformations:*\n",
  "module T(x=0, y=0, z=0): translate by [x,y,z]; alternatively T([x,y,z]) allowed \n",
  "module Tx(x=0): translate along x axis\n",
  "module Ty(y=0): translate along y axis\n",
  "module Tz(z=0): translate along z axis\n",
  "module R(x=0, y=0, z=0): rotation by [x,y,z]; alternatively R([x,y,z]) allowed \n",
  "module Rx(x=0): rotate around x axis\n",
  "module Ry(y=0): rotate around y axis\n", 
  "module Rz(z=0): rotate around z axis\n",
  "module S(x=1, y=1, z=1): scale by [x,y,z]; alternatively S([x,y,z]) allowed \n",
  "module Sx(x=1): scale along x axis\n",
  "module Sy(y=1): scale along y axis\n",
  "module Sz(z=1): scale along z axis\n",
  "module Skew(x=0, y=0, z=0, a=0, b=0, c=0): skew operation\n",
  "module skew(x=0, y=0, z=0, a=0, b=0, c=0): skew operation\n",
  "module SkewX(x=0): skew along x axis \n",
  "module SkX(x=0): skew along x axis \n",
  "module SkewY(y=0): skew along y axis \n", 
  "module SkY(y=0): skew along y axis \n",
  "module SkewZ(z=0): skew along z axis \n", 
  "module SkZ(z=0): skew along z axis \n",
  "*Logical*\n",
  "module D(): difference operation\n",
  "U(): union operation\n",
  "I(): intersection operation\n",
  "*Useful*\n",
  "module rotN(r=10, N=4, offs=0, M=undef): place N instances of children around circle with radius r. If M given, only M of N instances\n",
  "module forX(dx = 10, N=4): operator places N instances of children centered along X with instance distance dx\n",
  "module forY(dy = 10, M=4): operator places M instances of children centered along Y with instance distance dy\n",
  "module forZ(dz = 10, M=4): operator places M instances of children centered along Z with instance distance dz\n",
  "module forXY(dx, N=4, dy = 10, M=4): operator places NxM instances of children in centered XY grid with width [dx, dy]\n",
  "module C(r,g,b,t) or C(string,t): color operator; alternatively C([r,g,b], t) and C(\"colorname\",t) allowed  \n",
  "function Rg(N=10): generates int range (0:1:N-1)\n",
  "module measure(s=10, x=undef, y=undef, z=undef): draw transparent 2D square(s) of size s, translated by x,y,z orthogonal to axis x,y,z\n",
  "*Primitives*\n",
  "module Ci(r=10, d=undef): circle with radius r or diameter d\n",
  "module CiH(r=10, w=0, d=undef) or circle_half(...): half circle rotated by w\n",
  "module circle_half(...): CiH(...)\n",
  "module CiS(r=10, w1=0, w2=90, d=undef)or circle_sector(...): circle sector from angle w1 to w2\n",
  "module circle_sector(...): CiS(...)\n",
  "module CiR(R=10, r=5, w1=0, w2=360, D=undef, d=undef): Ring 2D\n",
  "module circle_ring(...): CiR(...)\n",
  "module Sq(x=10, y=undef, center=true)): rect with x,y or square with sides x\n",
  "module Cy(r=10, h=1, center=true, r1=undef, r2=undef, d=undef): cylinder\n",
  "module CyH(r=10, w=0, d=undef) or cylinder_half(...) half cylinder rotated by w\n",
  "module cylinder_half(...): CyH(...)\n",
  "module CyS(r=10, h=1, w1=0, w2=90,center=true, d=undef) or Pie(...) or cylinder_sector(...): cylinder sector from angle w1 to w2\n",
  "module cylinder_sector(...): CyS(...)\n",
  "module CyR(r=10, h=10, r_=1, d=undef, r1=undef, r2=undef, d1=undef, d2=undef, center=false) or cylinder_rounded(...): like cylinder() with rounded end faces \n",
  "module cylinder_ring(...): see CyR(...)\n",
  "module Cu(x=10, y=undef, z=undef, center=true): a cube with sides x,y,z; alternatively cube_rounded([x,y,z], r) and cube_rounded(x, y, z, r) allowed\n",
  "module CuR(x=10, y=20, z=30, r=1, center=true): cube with rounded vertices\n",
  "module cube_rounded(...): see CuR(...)\n",
  "module CuB(x=2, y=10, z=5, dx=1, dy=1, dz=1, center=true): cube bevelled, alternatively cube_bevelled([x,y,z], [dx,dy,dz]) allowed \n",
  "module cube_bevel(...): CuB(...)\n",
  "module Le(h=1, center = true, convexity=1, twist=0, slices=undef, scale=1) linear_extrude\n",
  "module Re(angle = 360): rotate_extrude procrusting\n",
  "module Re2(angle = 360): rotate_extrude non-procrusting (union of 2 rotate_extrude objects)\n",
  "module Ri(R=10, r=5, h=1, center=true, D=undef, d=undef): ring\n",
  "module Ring(...): see Ri(...)\n",
  "module ring(...): see Ri(...)\n",
  "module RiH(R=10, r=5, h=1, w=0 center=true, D=undef, d=undef) half ring rotated by w\n",
  "module ring_half(...) see RiH(...)",
  "module RiS(R=10, r=5, h=1, w1=0, w2=90, center=true, D=undef, d=undef) or ring_sector(): ring sector from w1 to w2\n",
  "module ring_sector(...) see RiS(...)",
  "module Sp(r=10): sphere(r)\n",
  "module SpH(r=10, w1 = 0, w2 = 0):  half sphere rotated with angle w\n",
  "module sphere_half(...) see SpH(...)\n",
  "module To(R=10, r=1, w1=0, w2=360): torus(...): torus from angle w1 to angle w2\n",
  "module torus(...) see To(...)\n");
  echo(h); 
}


// Euclidean Transformations

module T(x=0, y=0, z=0){
  translate(x[0]==undef?[x, y, z]:x)children(); }
  
module Tx(x) { translate([x, 0, 0])children(); }
module Ty(y) { translate([0, y, 0])children(); }
module Tz(z) { translate([0, 0, z])children(); }


module R(x=0, y=0, z=0){rotate(x[0]==undef?[x, y, z]:x) children();}
module Rx(x=90){rotate([x, 0, 0]) children();}
module Ry(y=90){rotate([0, y, 0]) children();}
module Rz(z=90){rotate([0, 0, z]) children();}
module M(x=0, y=0, z=0) mirror(x[0]==undef?[x, y, z]:x) children(); 
module Mx() mirror([1, 0, 0]) children(); 
module My() mirror([0, 1, 0]) children(); 
module Mz() mirror([0, 0, 1]) children(); 

module S(x=1, y=undef, z=undef){ scale(x[0]==undef?[x, y?y:x, z?z:y?1:x]:x) children();}
module Sx(x=1){scale([x, 1, 1]) children();}
module Sy(y=1){scale([1, y, 1]) children();}
module Sz(z=1){scale([1, 1, z]) children();}


module Skew(x=0, y=0, z=0, a=0, b=0, c=0)
  multmatrix([[1, a, x], [b, 1, y], [z, c, 1]]) children(); 
module skew(x=0, y=0, z=0, a=0, b=0, c=0) 
  Skew(x, y, z, a, b, c) children();  
module SkX(x=0) Skew(x=x) children(); 
module SkY(y=0) Skew(y=y) children(); 
module SkZ(z=0) Skew(z=z) children(); 
module SkewX(x=0) Skew(x=x) children(); 
module SkewY(y=0) Skew(y=y) children(); 
module SkewZ(z=0) Skew(z=z) children(); 


// Booleans
module D() if($children >1) difference(){children(0); children([1:$children-1]);} else children(); 
module U() children([0:$children-1]);
module I() intersection_for(n=[0:$children-1]) children(n); 

// rotates N instances of children around z axis
module rotN(r=10, N=4, offs=0, M=undef) for($i=[0:(M?M-1:N-1)])  rotate([0,0,offs+$i*360/N])  translate([r,0,0]) children();
module forN(r=10, N=4, offs=0, M=undef) rotN(r, N, offs, M) children();
module forX(dx = 10, N=4) for($i=[0:N-1]) T(-((N-1)/2-$i)*dx) children(); 
module forY(dy = 10, M=4) for($i=[0:M-1]) Ty(-((M-1)/2-$i)*dy) children(); 
module forZ(dz = 10, M=4) for($i=[0:M-1]) Tz(-((M-1)/2-$i)*dz) children(); 
module forXY(dx = 10, N=4, dy = 10, M=4) forX(dx, N) forY(dy, M) children(); 

// $i Counter, $j= $i-th list element of P
module forI(P, Q=undef,step=1) // P="hi there" | P=[1,3,4] | P=[0:2:12] | P=0, Q=9
{
  X = Q==undef?(is_list(P)?P:
                [for(i=P) i]): 
      is_num(P)?[for(i=[P:step:Q]) i]:
        echo("error") undef; 
  for($i=[0:len(X)-1]) let($j=X[$i]) children(); 
}

module Le(h=10, convexity=4, scale=1, center=true, twist=0, slices=undef)
  linear_extrude(height=h, convexity=convexity, scale=scale, center=center, twist=twist, slices=slices) children(); 

module Re(angle = 360)
{
  rotate_extrude(angle = angle)
  intersection() 
  {
    translate([0, -1e5])square([1e5, 2e5]); 
    children(); 
  }
}

module Re2(angle = 360)
{
  rotate_extrude(angle = angle)
  intersection() 
  {
    translate([1e5, 0])square([2e5, 1e5], center = true); 
    children(); 
  }
  rotate_extrude(angle = angle)
  intersection() 
  {
    translate([-1e5, 0])square([2e5, 1e5], center = true); 
    children(); 
  }
}


// primitives - 2D

module Sq(x =10, y = undef, center = true)
{
  x = x[0]?x:[x, y?y:x]; 
		square(x, center = center); 
}
module Ci(r = 10, d=undef) circle(d?d/2:r); 

// derived primitives - 2d
module CiH(r = 10, w = 0, d=undef)
  circle_half(r, w, d); 

//module CiS(r = 10, w1 = 0, w2 = 90, d=undef, center = true)
//  circle_sector(r, w1, w2, d, center=center); 

module CiR(R=10, r=5, w1=undef, w2=undef, D=undef, d=undef)
{
  if(w1!=undef && w2!=undef)
  D()
  {
    CiS(R, w1, w2, D); 
    CiS(r, w1, w2, d); 
  }
  else
  D()
  {
    Ci(R, D); 
    Ci(r, d); 
  }
}

module CiS(r=10, w1=0, w2=90, d=undef) 
{
  r = d==undef?r: d/2; 
  polygon(pie(r, w1, w2)); 
  function pie(r=40, a1=0, a2=150) = 
    let(start = a1%360)
    let(end = (a2%360-start)>=0?a2%360:a2%360+360)
    let(fa = $fn==0?$fa:360/$fn)
    let(step = (end-start)/ceil((end-start)/fa)- 1e-7)
    r*[[0,0], for(i=[start:step:end]) [cos(i), sin(i)]]; 
}
  

// primitives - 3d
module Cy(r = 10, h = 1, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
  if(r1!=undef)
    cylinder(r1=r1, r2=r2?r2:d2/2, h=h, center=center); 
  else if(d!=undef)
    cylinder(r=d/2, h=h, center=center); 
  else if(d1!=undef)
    cylinder(r1=d1/2, r2=r2?r2:d2/2, h=h, center=center); 
  else cylinder(r=r, h=h, center=center); 
    

module Cu(x = 10, y = undef, z = undef, center = true)
  cube(x[0] == undef?[x, y?y:x, y?z?z:1:x]:x, center=center); 

CuR(x=2, y=10, z=5, r=1, center=true)
  cube_rounded(x, y, z, r, center); 
  
module CuR(x = 10, y = 20, z = 30, r = 1, center = true)
  cube_rounded(x, y, z, r, center); 

module CuB (x=2, y=10, z=5, dx=1, dy=1, dz=1, center=true)
  cube_bevel(x, y, z, dx, dy, dz, center); 
  
module CyR(r = 10, h=10, r_=1, d = undef, r1=undef, r2=undef, d1 = undef, d2 = undef, center=false)  
  cylinder_rounded(r, h, r, d, r1, r2, d1, d2, center); 

// derived primitives - 3d
module CyH(r = 10, h = 1, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
  cylinder_half(r=r, h=h, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2); 

module CyS(r = 10, h = 1, w1 = 0, w2 = 90, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
  cylinder_sector(r=r, h=h, w1=w1, w2=w2, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2); 

module Ri(R = 10, r = 5, h = 1, center = true, D=undef, d=undef)
  ring(R, r, h, center, D, d); 

module RiS(R = 10, r = 5, h = 1, w1 = 0, w2 = 90, center = true, D=undef, d=undef)
   ring_sector(R, r, h, w1, w2, center, D, d); 

module RiH(R = 10, r=5, h = 1, w = 0, center = true, D=undef, d=undef)
   ring_half(R, r, h, w, center, D, d); 
module Pie(r = 10, h = 1, w1 = 0, w2 = 90, center = true, d=undef)
  cylinder_sector(r, h, w1, w2, center, d);  
module Sp(r = 10)
  sphere(r); 
module SpH(r = 10, w1 = 0, w2 = 0)
  sphere_half(r, w1, w2); 
module To(R=10, r=1, r1 = undef, w=0, w1=0, w2=360, fn = undef) torus(R=R, r=r, r1=r1, w=w,w1=w1, w2=w2, fn=fn);  

module C(r=1, g=1, b=1, t=1) 
{
  if(r!=undef)
  if(len(r)) 
    color(r, g) children(); 
  else
    color([r,g,b], t) children(); 
  else
    children();
}

module red(t=1) color("red", t) children(); 
module green(t=1) color("green", t) children(); 
module blue(t=1) color("blue", t) children(); 
module black(t=1) color("black", t) children(); 
module white(t=1) color("white", t) children(); 
module yellow(t=1) color("yellow", t) children(); 
module lightblue(t=1) color("lightblue", t) children(); 
module gray(t=1) color("gray", t) children(); 
module lightgray(t=1) color("lightgray", t) children(); 
module orange(t=1) color("orange", t) children(); 
module darkgray(t=1) color("darkgray", t) children(); 

function Rg(rg) = let(x=rg[2]+.00001?rg:[0:1:rg-1])  
[for(i=[x[0]:x[1]:x[2]]) i]; 

//


// clear text definitions

module cube_rounded(x=10, y=20, z=30, r=1, center=true)
{
  sz = is_list(x)?x:[x,y,z]; 
  r = is_list(x)?y:r; 
  echo(x, y, z, r, sz); 
  ce = is_list(center)?center:[center, center, center]; 
  r_ = min(abs(r), abs(sz.x/2), abs(sz.y/2), abs(sz.z/2)); 
  translate([ce.x?-sz.x/2:0,ce.y?-sz.y/2:0, ce.z?-sz.z/2:0])
  if(r)
    hull() 
    {
      translate([r_, r_, r_]) sphere(r_); 
      translate([r_, r_, sz.z-r_]) sphere(r_); 
      translate([r_, sz.y-r_, r_]) sphere(r_); 
      translate([r_, sz.y-r_, sz.z-r_]) sphere(r_); 
      translate([sz.x-r_, r_, r_]) sphere(r_); 
      translate([sz.x-r_, r_, sz.z-r_]) sphere(r_); 
      translate([sz.x-r_, sz.y-r_, r_]) sphere(r_); 
      translate([sz.x-r_, sz.y-r_, sz.z-r_]) sphere(r_); 
    }
  else 
    cube(size); 
}

module cube_bevel(x=2, y=10, z=5, dx=1, dy=1, dz=1, center=true)
{
  S = is_list(x)?x:[x,y,z]; 
  D_ = is_list(y)?y:[dx,dy,dz];
  D=[min(S[0]/2, D_[0]), 
     min(S[1]/2, D_[1]), 
     min(S[2]/2, D_[2])]; 
  translate(center?[0,0,0]:[S[0]/2+dx, S[1]/2+dy, S[2]/2+dz])
  hull()
  {
   cube(S + [2*D[0], 0, 0], center = true); 
   cube(S + [0, 2*D[1], 0], center = true); 
   cube(S + [0, 0, 2*D[2]], center = true); 
  }
}


module circle_half(r = 10, w = 0, d = undef)
{
  R= d?d/2:r;
	difference()
	{
		circle(R); 
     rotate([0, 0, w-90])
     translate([0, -R])
		square([R, 2*R], center = false); 
	}
}

module circle_sector(r = 10, w1 = 0, w2 = 90, d = undef)
{
  R = d?d/2:r; 
  W2 = (w1>w2)?w2+360:w2; 
  diff = abs(W2-w1);
  if (diff < 180)
    intersection()
		{
       circle_half(R, w1); 
       circle_half(R, W2-180); 
 		}
	else if(diff>=360)
    circle(R); 
  else
		{
       circle_half(R, w1); 
       circle_half(R, W2-180); 
 		}
}

module cylinder_half(r = 10, h = 1, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
{
  R = max(d?d/2:r, r1?r1:0, r2?r2:0, d1?d1/2:0, d2?d2/2:0);
  difference()
  {
    Cy(r=r, h=h, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2);
    Ty(-(R+1)/2)
    Cu(2*R+1, R+1, h+1, center = center); 
  }
//  linear_extrude(height = h, center = center)
//  circle_half(r=r, w=w, d=d); 
} 

module cylinder_sector(r = 10, h = 1, w1 = 0, w2 = 90, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
{
  R = max(d?d/2:r, r1?r1:0, r2?r2:0, d1?d1/2:0, d2?d2/2:0);
    intersection()
    {
      Cy(r=r, h=h, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2);
      cylinder_sector_(r=R, h=h, w1=w1, w2=w2, center=center);
    }
}

module cylinder_sector_(r = 10, h = 1, w1 = 0, w2 = 90, center = true)
  linear_extrude(height = h, center = center, convexity = 2)
  circle_sector(r=r, w1=w1, w2=w2); 

module cylinder_rounded(r=10, h=10, r_=1, d=undef, r1=undef, r2=undef, d1=undef, d2=undef, center=true)
{
  r1 = r1==undef?d1==undef?d==undef?r:d/2:d1/2:r1;
  r2 = r2==undef?d2==undef?d==undef?r:d/2:d2/2:r2;
  r_ = min(abs(h/4), abs(r1), abs(r2), abs(r_));
  h = abs(h);
  Tz(center?-h/2:0) rotate_extrude() I()
  {
    offset(r_)offset(-r_) polygon([[-2*r_,0], [r1, 0], [r2, h], [0,h], [-2*r_,h]] );
    Sq(max(r1,r2), h, 0);
  }
} 

module Ring(R1 = 12, R2 = 10, r1 = 6, r2 = 5, h = 10, center = true)
	difference()
	{
    Cy(r1=R1, r2=r1, h=h, center = center); 
    Tz(-.001)Cy(r1=R2, r2=r2, h=h+1,center = center); 
	}


module ring(R = 10, r = 5, h = 1, center = true, D=undef, d=undef)
  linear_extrude(height = h, center = center, convexity = 2)
	difference()
	{
    Ci(r = D?D/2:R); 
    Ci(r = d?d/2:r); 
	}


module ring_half(R = 10, r = 5, h = 1, w = 0, center = true, D=undef, d=undef)
  linear_extrude(height = h, center = center, convexity = 2)
  Rz(w)
	difference()
	{
    CiH(r = D?D/2:R); 
    Ci(r = d?d/2:r); 
	}

module ring_sector(R = 10, r = 5, h = 1, w1 = 0, w2 = 90, center = true, D=undef, d=undef)
  linear_extrude(height = h, center = center, convexity = 2)
	difference()
	{
    CiS(r = D?D/2:R, w1 = w1, w2 = w2); 
    Ci(r = d?d/2:r); 
	}


module sphere_half(r = 10, w1 = 0, w2 = 0)
  R(w1, w2)
	intersection()
	{
   	sphere(r); 
     	translate([-r, -r, 0])
		cube([2*r, 2*r, r]); 
	}

module torus(R=10, r=1, r1 = undef, w=0, w1=0, w2=360, fn = undef)
{
  if (r1)
    D(){
      To(R=R, r=r, w=w, w1=w1, w2=w2, fn=fn); 
      To(R=R, r=r1, w=w, w1=w1-1, w2=w2+1, fn=fn); 
    }
  else
    Rz(w1)
    rotate_extrude(angle = w2-w1)
    T(R)
    Rz(w) ci(); 
 module ci()
    if(fn!=undef) circle(r, $fn=fn); else circle(r); 
}

// additional code
module place_in_rect(dx =20, dy=20)
{
  cols = ceil(sqrt($children)); 
  rows = floor(sqrt($children)); 
  for(i = [0:$children-1])
	{ 
	  T(dx*(-cols/2+(i%cols)+.5), dy*(rows/2-floor(i/cols)-.5))
		 children(i); 
	}
}

module measure(s=10, x=undef, y=undef, z=undef)
{
  p=[[s, s, 0], [-s, s, 0], [-s, -s, 0], [s, -s, 0]]; 
  C("black",.5)
  {
    if(z) Tz(z) polyhedron(p, [[0,1,2,3]]); 
    if(x) Tx(x) Ry(90)polyhedron(p, [[0,1,2,3]]); 
    if(y) Ty(y) Rx(90) polyhedron(p, [[0,1,2,3]]); 
  }
}

// Naca4_sweep.scad - sweep library
// Code: Rudolf Huttary, Berlin 
// 1st release : June 2015
// last update: 2020.04.10
// commercial use prohibited

// use <naca4.scad>

//example1(); 
//rotate([80, 180, 130])
//example(); 

// sweep from NACA1480 to NACA6480 (len = 230 mm, winding y,z = 80
module example()
{
  N = 40; 
  sweep(gen_dat(N=5, dz=1,N=N), showslices = false); 
//  sweep(gen_dat(N=5, dz=1,N=N), showslices = true); 
  
  // specific generator function
  function gen_dat(M=10,dz=.1,N=10) = [for (i=[1:dz:M])   
    let( L = length(i))
    let( af = vec3D(
        airfoil_data([.1,.5,thickness(i)], L=length(i), N = N)))
    T_(-L/2, 0, (i+1)*2, af)];  // translate airfoil
  
  function thickness(i) = .5*sin(i*i)+.1; 
  function length(i) = (60+sin(12*(i-3))*30); 
}

module help() help_Naca_sweep(); 
module help_Naca_sweep()
{
  echo(str("\n\n<b>Naca4_sweep library - by Rudolf Huttary, Berlin</b>\n",
  "module sweep(dat, convexity = 5, showslices = false, close = false, planar_caps = false)  // dat - vec of vec3-polygons\n", 
  "module skin(dat, showslices = false, close = false, planar_caps = true, convexity = 5) // like sweep \n",
  "module sweeps(Dat, convexity = 5) // lazy union of multiple sweeps\n",
  "module sweep_multihole(outer, holes, convexity = 5) // sweep with multiple holes\n",
  "module sweep_path(path, shape, close = false) // sweep shape along path\n",
  "function sweep(dat, close = false, planar_caps = true) // dat - vec of vec3-polygons \n",
  "function sweeps(Dat) = // lazy union sweep\n",
  "function sweep_path(path, shape) // sweep shape along path\n",
  "\n<b>Some matrix/vector operations </b>\n",
  "function rotate_from_to(a,b) = // matrix for rotation from normal a to normal b\n",
  "function transpose(A)\n",
  "function normal(a,b,c)\n, // a can be vector ",
  "function unit(a)  // unify a to length 1\n",
  "\n<b>Affine operations</b> \n=================\n",
  "function vec3D(v, z=0)  // expand vec2 to vec3",
  "function vec3(v, z=0)  // expand vec2 to vec3",
  "function T(x=0, y=0, z=0, v) and function T_(x=0, y=0, z=0, v) // translates vec of vec3, x may be vector\n", 
  "function Tx(x=0, v) and function Tx_(x=0, v) // x-translates vec of vec3\n", 
  "function Ty(y=0, v) and function Ty_(y=0, v) // y-translates vec of vec3\n", 
  "function Tz(z=0, v) and function Tz_(z=0, v) // z-translates vec of vec3\n", 
  "function R(x=0, y=0, z=0, v) and function R_(x=0, y=0, z=0, v) // rotates vec of vec3\n", 
  "function Rx(x=0, v) and function Rx_(x=0, v) // x-rotates vec of vec3\n", 
  "function Ry(y=0, v) and function Ry_(y=0, v) // y-rotates vec of vec3\n", 
  "function Rz(z=0, v) and function Rz_(z=0, v) // z-rotates vec of vec3\n", 
  "function S(x=0, y=0, z=0, v) and function S_(x=0, y=0, z=0, v) // scales vec of vec3\n", 
  "function Sx(x=0, v) and function Sx_(x=0, v) // x-translates vec of vec3\n", 
  "function Sy(x=0, v)and function Sy_(x=0, v) // y-translates vec of vec3\n", 
  "function Sz(x=0, v) and function Sz_(x=0, v) // z-translates vec of vec3\n",
  "function count(a, b) // sequence a to b as list\n",
  "function subdiv(path, maxlen = 10) // subdivide 3D point path segments, if longer than maxlen\n",
  "=================\n")); 
}

// Calculates a polyhedron based extrusion. 
// Expects a dataset defined as *non-selfintersecting* sequence of polygons that describes a extrusion trajectory
//  interchangable with skin()
// dat := vector of simple polygons, with polygon := vec of vec3, minimum 3 points per polygon expected
// use "planar_caps = true" only if triangulation of OpenSCAD works flawlessly
module sweep(dat, showslices = false, close = false, planar_caps = true, convexity = 5) 
{
  n = len(dat);     // # datasets
  l = len(dat[0]);  // points per dataset 
  if(l<3) echo("ERROR: sweep() expects more than 3 points per dataset"); 
  if (showslices)  for(i=dat) poly(i);
  else
  {
    obj = sweep(dat, close=close, planar_caps=planar_caps); 
    polyhedron(obj[0], obj[1], convexity = convexity); 
  }
}

module poly(p)
{
  p_ = (len(p[0])==2)?vec3D(p):p;
  polyhedron(p_, [count(0,len(p)-1)]); 
}

module skin(dat, showslices = false, close = false, planar_caps = true, convexity = 5) 
 sweep(dat, showslices, close, planar_caps, convexity); 

module sweep_path(path, shape, close = false) // usage: sweep_path(circle(r=100), circle(r=30), close=true); 
  sweep(sweep_path(path, shape, close=close), close = close); 
 
function sweep_path(path, shape, close = false) = 
  [for(i=0, n=path[1]-path[0], 
    m=-normal(shape),
    R=rotate_from_to(n, m); 
    i<len(path); 
    m=n, i=i+1, 
    n=i<len(path)-1?path[i+1]-path[i]:close?path[0]-path[i-1]:n,
    R=R*rotate_from_to(n, m))   echo(i, n)
      T(path[i], shape*R)];

function normal(a,b,c) = a[0]==undef?unit(cross(a-b,b-c)): unit(cross(a[0]-a[1],a[1]-a[2])); 

function rotate_from_to(a,b) = // matrix for rotation from normal a to normal b
        let( axis = unit(cross(a,b)) )
        axis*axis >= 0.99 ? 
           transpose([unit(b), axis, cross(axis, unit(b))]) * [unit(a), axis, cross(axis, unit(a))] : 
            [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
function transpose(A) = [for(i=[0:2])[for(j=[0:2]) A[j][i]]]; 
function unit(a) = a/norm(a); 
function rotate_from_to(a,b) =  
let( axis = unit(cross(a,b)) )
 axis*axis >= 0.99 ? 
  transpose([unit(b), -axis, cross(-axis, unit(b))]) * [unit(a), -axis, cross(-axis, unit(a))] : 
  [[1, 0, 0], [0, 1, 0], [0, 0, 1]];


module sweep_multihole(outer, holes, convexity = 5)
  difference()
  { 
    sweep(outer, convexity = convexity); 
    sweeps(holes, convexity = convexity); 
  }
  

// sweeps generates a single polyhedron from multiple datasets
module sweeps(Dat, convexity = 5) // lazy union sweep
{
  soup = sweeps(Dat); 
  polyhedron(soup[0], soup[1], convexity = convexity);  
}

function sweeps(Dat) = // lazy union sweep
  let(sweeps = [for(S=Dat) sweep(S)])              // do all the sweeps
  let(offs = sweepsNewoffs([for(S=sweeps) len(S[0])]))  // calc indices for face shifts
  let(faces = [for(i=[0:len(sweeps)-1]) each sweepsShiftFaces(sweeps[i][1], offs[i])])  // shift faces indices 
  let(points = [for(S=sweeps) each S[0]])  
    [points, faces]; 

  function sweepsShiftFaces(faces, N) = // helper: calcs face shift indices
    [for(x=faces) [for(y=x) y+N]]; 
    
  function sweepsNewoffs(L, o=0, i=0) = // helper: calcs acculumlated offsets 
      i<len(L)?concat([o], sweepsNewoffs(L, o+L[i], i+1)):[];

function sweep(dat, close = false, planar_caps = true) = // main sweep function
  let(n=len(dat), l=len(dat[0]))
  let(first = planar_caps?[count(l-1, 0)]: facerev(earcut(dat[0])))
  let(last = planar_caps?[count((n-1)*l,(n)*l-1)]: faces_shift((n-1)*l, (earcut(dat[0])))) 
  let(faces = close?faces_sweep(l,n, close) :concat(first, last, faces_sweep(l,n))) 
  let(points = [for (i=[0:n-1], j=[0:l-1]) dat[i][j]]) // flatten points vector
[points, faces]; 

function count(a, b) = [for (i=[a:(a<b?1:-1):b]) i];  // helper
function faces_shift(d, dat) = [for (i=[0:len(dat)-1]) dat[i] + [d, d, d]]; // helper
  
//// knit polyhedron
  function faces_sweep(l, n=1, close = false) = 
      let(M = n*l, n1=close?n+1:n) 
      concat([[0,l,l-1]],   // first face
             [for (i=[0:l*(n1-1)-2], j = [0,1])
                j==0? [i, i+1, (i+l)%M] 
                    : [i+1, (i+l+1)%M, (i+l)%M]
             ]
             ,[[(n1*l-1)%M, (n1-1)*l-1, ((n1-1)*l)%M]
             ]); // last face
      ;
    
function facerev(dat) = [for (i=[0:len(dat)-1]) [dat[i][0],dat[i][2],dat[i][1]]]; 

//// vector and vector set operation stuff ///////////////////////
//// Expand 2D vector into 3D
function vec3(v,z=0) = v[0][0]==undef?[v[0],v[1],z]:[for(a=v) vec3D(a, z)]; 
function vec2(v) = v[0][0]==undef?[v[0], v[1]]:[for(a=v) vec2(a)]; 
function vec3D(v,z=0) = vec3(v, z); 

// Translation - 1D, 2D, 3D point vector //////////////////////////
//   recursive! operates over vectors, lists of vectors, lists of lists ... 
function T_(x=0, y=0, z=0, v) = let(il=x[0]!=undef?len(x)==3:false)
  let(v = il?y:v, x = il?x:[x, y, z]) v[0][0]!=undef?[for (i=v) T_(x,i)]:v+x; 
function T(x=0, y=0, z=0, v) = T_(x,y,z,v); // synonym
/// translate along one axis
function Tx_(x=0, v=undef) = v[0][0]!=undef?[for (i=v) Tx_(x,i)]:v+[x,0,0]; 
function Tx(x=0, v=undef) = Tx_(x,v); // synonym
function Ty_(y=0, v) = v[0][0]!=undef?[for (i=v) Ty_(y,i)]:v+[0,y,0];  
function Ty(y=0, v) = Ty_(y,v); // synonym
function Tz_(z=0, v) = v[0][0]!=undef?[for (i=v) Tz_(z,i)]:v+[0,0,z]; 
function Tz(z=0, v) = Tz_(z,v); // synonym

//// Rotation - 2D, 3D point vector ///////////////////////////////////
//   recursive! operates over vectors, lists of vectors, lists of lists ... 
// 2D vectors allowed 
function R_(x=0, y=0, z=0, v) = let(len_x_eq_3= x[0]!=undef?len(x)==3:false) 
  let(v = len_x_eq_3?y:v, x=len_x_eq_3?x:[x, y, z])
  v[0][0]!=undef? [for(i=v) R_(x,i)]:Rz_(x[2], Ry(x[1], Rx_(x[0], v)));  
function R(x=0, y=0, z=0, v) = R_(x,y,z,v); // synonym
// rotate around one axis
function Rx_(x, A) = A[0][0]!=undef?[for(i=A) Rx_(x, i)]:
    A*[[1, 0, 0], [0, cos(x), sin(x)], [0, -sin(x), cos(x)]]; 
function Rx(x, A) = Rx_(x, A); // synonym
function Ry_(y, A) = A[0][0]!=undef?[for(i=A) Ry_(y, i)]:
    A*[[cos(y), 0, sin(y)], [0, 1, 0], [-sin(y), 0, cos(y)]]; 
function Ry(y, A) = Ry_(y, A); // synonym
function Rz_(z, A) = let(lenA0is2=A[0]!=undef?len(A)==2:false) 
    A[0][0]!=undef? 
    [for(i=A) Rz_(z, i)]: 
    lenA0is2? 
    A*[[cos(z), sin(z)], [-sin(z), cos(z)]]: 
    A*[[cos(z), sin(z), 0], [-sin(z), cos(z), 0], [0, 0, 1]]; 
function Rz(z, A) = Rz_(z, A); // synonym


//// Scale - 2D, 3D point vectors ///////////////////////////////////
//   recursive! operates over vectors, lists of vectors, lists of lists ... 
function S_(x=1, y=1, z=1, v) = let(len_x_eq_3=x[0]!=undef?len(x)==3:false)
  let(v = len_x_eq_3? y:v, x = len_x_eq_3? x:[x, y, z])
    v[0][0]!=undef?
//    echo(v=v,x=x)
      [for (i=v) S_(x,i)]:
        [for (i=[0:len(v)-1]) v[i]*x[i] ];
function S(x=1, y=1, z=1, v) = S_(x,y,z,v);     
// scale along one axis
function Sx_(x=0, v) = S_(x=x, v=v); 
function Sx(x=1, v) = Sx_(x,v); // synonym    
function Sy_(y=0, v) = S_(y=y, v=v); 
function Sy(y=1, v) = Sy_(y,v); // synonym    
function Sz_(z=0, v) = S_(z=z, v=v); 
function Sz(z=1, v) = Sz_(z,v); // synonym   

// usage example: 
// skin(LinearPathExtrude(subdiv(Sq(100), 20))); 
// function LinearPathExtrude(path, h=10, twist = 90, slices=10) = 
//   [for(i=[0:n])  Rz(w/n*i, Tz(h/slices*i, path)) ]; 
function subdiv(path, maxlen = 10) = // subdivide path segments if larger than maxlen
let(L = len(path)) 
[for(i=[0:L-1])
  let (unit = path[i]-path[(i+1)%L])
  let (l = norm(unit))
  if(l>maxlen) 
    let(n = ceil(echo(l/(maxlen)) l/maxlen))
    each[ for(j=[0:n-1]) path[i]-j*unit/(n)]
  else
   path[i]]; 


module airfoil(naca=12, L = 100, N = 81, h = 1, open = false)
{
  linear_extrude(height = h)
  polygon(points = airfoil_data(naca, L, N, open)); 
}

// this is the main function providing the airfoil data
function airfoil_data(naca=12, L = 100, N = 81, open = false) = 
  let(Na = naca[0]!=undef?naca:NACA(naca))
  let(A = [.2969, -0.126, -.3516, .2843, open?-0.1015:-0.1036])
  [for (b=[-180:360/(N):179.99]) 
    let (x = (1-cos(b))/2)  
    let(yt = sign(b)*Na[2]/.2*(A*[sqrt(x), x, x*x, x*x*x, x*x*x*x])) 
    Na[0]==0?L*[x, yt]:L*camber(x, yt, Na[0], Na[1], sign(b))];  

// helper functions
function NACA(naca) = 
  let (M = floor(naca/1000))
  let (P = floor((naca-M*1000)/100)) 
  [M/100, P/10, floor(naca-M*1000-P*100)/100];  

function camber(x, y, M, P, upper) = 
  let(yc = (x<P)?M/P/P*(2*P*x-x*x): M/(1-P)/(1-P)*(1 - 2*P + 2*P*x -x*x))
  let(dy = (x<P)?2*M/P/P*(P-x):2*M/(1-P)/(1-P)*(P-x))
  let(th = atan(dy))
  [upper ? x - y*sin(th):x + y*sin(th), upper ? yc + y*cos(th):yc - y*cos(th)];

////////////////////////////////////////////////////
// splines.scad - library for mulivariate splines
// Implementation: Rudolf Huttary (c), Berlin 
//  November 2015
//  commercial use prohibited
//
//  usage scheme - n-dimensional natural cubic spline interpolation 
//    A = [[...],[...],[...]]; // define Mxn matrix, M>2, n>1
//    B = nSplines(A, N);      // get interpolated Nxn matrix
//    C = gen_dat(B);          // interpret data and transform into trajectory
//    sweep(B);                // render 
//
//  for code examples  see: 
//     http://forum.openscad.org/Rendering-fails-difference-between-F5-and-F6-tp15041p15100.html
//     http://forum.openscad.org/general-extrusion-imperfect-tp14740p14752.html
//     knot() example in this file!
//
///// some information functions to measure diameter and bounding box of an interpolated system
//  usage:   
//    B = nSplines(A); 
//    echo(str("outer diam=",Max(Norm(B)))); 
//    echo(str("bounding box=",Box(B))); 


// testcode 
//A = [ 
//  [-4.3,    .57,   .1,  .3],
//  [-.9,     .32,   1,   .4],
//  [1.5,     .07,   .1,  .5],
//  [2.5,    -1.48,  -1,  1.6],
//  [5.6,    -1.68,  -2,  .7],
//  [6.6,     1 ,    1.5, .4],
//  [4.6,    .5 ,    1,   .3],
//  [-1 ,     -2,    1.3, .7],
//  [-5 ,     -2,    1.5, 1.8]
//  ]*10;


//A= [
//[2*x, 0, 0, 1],
//[x+dx, dy, 0, 1],
//[x, 0, 0, 1],
//[x-dx, dy, 0, 1],
//[0, 0, 0, 1],
//[x-dx, -dy, 0, 1],
//[x, 0, 0, 1],
//[x+dx, -dy, 0, 1],
//[2*x, 0, 0, 1],
//]*40;

knot(); 

splines_help();


module knot()
{
// knot
A = [ 
  [-5,    0,   0],
  [-1,    0,   0],
  [-.4,    0,   -.2],
  [.3,    .3,   .2],
  [.2,     -.5,   0],
  [0,     0,   -.5],
  [-.2,     .5,   -0],
  [-.3,    -.3,   .2],
  [.4,    0,   -.2],
  [1,    0,   0],
  [5,    0,   0],
  ]*10;


N = 200; 

nS = nSpline(A,N);   // 4D-Spline rasterized

translate([0,0,20])
//{
//  plot4D(nS);         // 4D-plot, 4th dim is implicit radius
//  plot4D(A, "red"); 
//}
plot3D(col3D(nS), r=2); // 3D-plot, radius explicit
plot3D(col3D(nS), r=2); // 3D-plot, radius explicit
plot3D(col3D(A), r=3, c="red"); 

}

module help() splines_help();

/////////////////////////////////////////////////////////////
// library stuff - modules //////////////////////////////////
module plot3D(A, r=1, c = "yellow")
{ 
  for(i=[0:len(A)-1])
    color(c)
    translate(A[i])
    sphere(r, $fn=30); 
}

module plot4D(A, c = "yellow")
{
  for(i=[0:len(A)-1])
    color(c)
    translate([A[i][0], A[i][1], A[i][2]])
    sphere(A[i][3], $fn=30); 
}

module help () help_splines(); 

module help_splines()
{
  echo("\nModule prototypes:\n
=============\n
  help() - echos help in console
  help_splines() - echos help in console
  plot3D(A, r=1, c = \"yellow\")\n
  plot4D(A, c = \"yellow\")\n\n
  Function prototypes:\n
=============\n
  NxM = nSpline(S, N) - n-dim spline interpolation\n
  t = line_integral(S) - calcs line integral over 3D polygon\n
  coeffs = spline2D(x,y) - caculates coeffs for cubic spline\n
  y = spline2D_eval(coeffs, t, x) - evaluate spline at x\n
  Y = spline2D_rasterize(coeffs, t, N) - \n
  m = Max(A, flat=true) recursive max\n
  m = Min(A, flat=true) recursive min\n
  n = Norm(A) - recursive norm\n
  bb = Box(A) - boundingbox\n
  v = flat3(A, n=0) - flatten structured vector\n 
  
  "
); 
}


/////////////////////////////////////////////////////////////
// spline stuff - functions /////////////////////////////////
function nSpline(S, N) = 
// Rasterizes a PxM-dim vector sequence S into a NxM-dim sequence
// using a multivariate cubic spline interpolation scheme.
// along   a line integral 
// over P-dim polygon cord is used as common x-vector
//  S - is PxM-dim and denotes a seq of M-dim vectors to be
//      used as y-vectors
// returns NxM interpolated M-dim vectors
  let(M=len(S[0]))
  let(t = line_integral(S))
  transpose(
  [for(i=[0:M-1])
    let(C = col(S,i))
    let(coeffs = spline2D(t,C)) 
    (spline2D_rasterize(coeffs, t, N))]);

/////////////////////////////////////////////////////////////
//////// 2D cubic splines - main functions ///////////////// 
function spline2D(x,y) = 
// calculates coeffs of cubic spline segments 
// i.e. all coeffs of eq. systems Ax+Bx+Cx+D = y
//    x,y - paired vectors
//    [A, B, C, D]   returned vector values
  let(MT = eq_sys(x,y))  
  let(b = concat(0, solve_eq(MT[0], MT[1]), 0))
  let(N = len(x)-2) 
  let(dx = [for (i=[0:N])  x[i+1] - x[i]]) 
  let(A  = [for (i=[0:N]) (b[i+1]-b[i])/(3*dx[i])])
  let(C =  [for (i=[0:N]) (y[i+1]-y[i])/dx[i] - (b[i+1]-b[i])*dx[i]/3 - b[i]*dx[i]])
  [A, b, C, y]; 

function spline2D_rasterize(coeffs, t, N) = 
// evaluates a 2D-spline defined by coeffs for the ordered vector t
// at N equidistant points
// returns N vector containing sequence of interpolation values 
  let(T = raster(t,N))
  [for(i=[0:len(T)-1]) spline2D_eval(coeffs, t, T[i])];

function spline2D_eval(coeffs, t, x) = 
// evaluate spline represented by coeffs and t at x
// f(x) returned
    let(i = interval_idx(t,x))
    let(x_ = x-t[i])
    pow(x_,3)*coeffs[0][i]+
    pow(x_,2)*coeffs[1][i]+
           x_*coeffs[2][i]+
             coeffs[3][i] ;

/////////////////////////////////////////////////////////////
///stuff need for solving spline specific equation system ///
function eq_sys(x, y) = 
//transfers value pairs into eq.system M*x=T
//    x,y - paired vectors
//   [M, T] returned vector values with M - symmetric band (m=1) matrix 
//           in sparse lower band Nx2 representation
//   T - right side vector
    let(N = len(x)-3)
    let(T = [for (i=[0:N]) 
      3*((y[i+2]-y[i+1])/(x[i+2]-x[i+1]) - (y[i+1]-y[i])/(x[i+1]-x[i])) ])
    let(M = [for (i=[0:N]) 
      [(i==0)?0:(x[i+1]-x[i]), 2*(x[i+2]-x[i]) ]])
    [M, T]; 

function solve_eq(M,y) = 
// solves eq. system M*x = y, 
// M symmetric band (m=1) matrix, in sparse lower band representation
// uses Cholesky factorization L'*L*x=y
    let(N = len(M)-1)
    let(L = cholesky(M))
    LLx(L,y);
    
function LLx(L,y) =  
// solve L'Lx=y by first solving L'(Lx) = L'x_ = y and then Lx = x_
  let (N = len(y)-1) 
  let (x_ = [ for (i= [0:N]) Lx(i, L, y)]) 
            [ for (i= [0:N]) Lx_(i, N, L, x_)]; 
function Lx(i,L,y) =   (i==0)? y[0]/L[0][1]: (y[i] - Lx(i-1,L,y) * L[i][0])/L[i][1]; 
function Lx_(i,N,L,y) =(i==N)? y[i]/L[i][1]: (y[i] - Lx_(i+1,N,L,y) * L[i+1][0])/L[i][1]; 
    
function cholesky(A) = 
//  Cholesky factorization - applies only to symmetric band (m=1) matrix
// A - matrix to be factorized in sparse lower band representation
// returns Cholesky matrix in sparse lower band representation
    let(N=len(A)-1) 
    [ for(k= [0:N]) 
      let(Lk_ = Lk(A, k))
      [Lk_[0], Lk_[1]]
    ];
function Lk(A,k) = 
// recursive helper of cholesky()
  (k==0)?
    [0, sqrt(A[0][1]), A[0][1]]: 
      let(Lk_0  = (A[k][0] / Lk(A, k-1)[1])) 
      let(Ak_1  = (A[k][1] - Lk_0*Lk_0))
      let(Lk_1  = sqrt(Ak_1))
    [Lk_0, Lk_1, Ak_1];

/////////////////////////////////////////////////////////////
// some more general matrix and vector functions ////////////
function col(S,c=0) = 
// returns column c of matrix S
   [for(i=[0:len(S)-1]) S[i][c]]; 

function col3D(S) =
// returns first 3 columns of matrix S
   let(n=len(S[0])-1)
   [for(i=[0:len(S)-1]) 
     [S[i][0], (n>0)?S[i][1]:0, (n>1)?S[i][2]:0]]; 

function transpose(A) =
  [for(i=[0:len(A[0])-1])
    [for(j=[0:len(A)-1])
      A[j][i]]]; 

function line_integral(S) = let (M = len(S))
// calculates piecewise line integral over S, 
//    S is an ordered sequence of M distinct N-dim vectors
// returns ordered N-sequence of accumulated distances
    [for (i=[0:M-1]) lineT2(S,i)]; 
  
function lineT1(S, i, k) = 
// recursive helper of lineT2()
    let(x=(i==0)?0:S[i][k]-S[i-1][k])
    let(t1 = x*x)
    k==0 ? t1 : t1 + lineT1(S, i, k-1); 
  
function lineT2(S, i) = 
// recursive helper of line_integral()
    let(N = len(S[0]))
    let(x=lineT1(S,i,N-1))
    let(t1  = pow(x, .25)) 
    (i==0)? 0: (i==1) ? t1 : t1 + lineT2(S,i-1); 

function raster(t,N=100) = 
// splits interval covered by ordered vector t 
//    into N equ.dist. intervals
// returns raster as ordered N vector    
   let(d = t[len(t)-1]-t[0])
    [for (i=[0:N-1]) t[0]+i*d/(N-1)]; 

function interval_idx(t, x) = 
// returns index of interval containing real number x
// in ordered interval sequence defined by vector t
   let(N= len(t)-1)
  [for(i=[0:N-1]) 
    if(t[0]>x || (t[i]<=x && (t[i+1])>=x) || i==N-1) i][0];
 
    
// if flat == true 
//    max(vec of ... vec) 
// else
//    vec of (max(vec))
function Max(A, flat=true) = 
    let (m = 
      len(A[0])>1?
         [for(i=[0:len(A)-1]) Max(A[i])]:
          max(A) ) 
       flat?max(m):m; 

////////////////////////////////////////////////////////////////////
///// some information functions to measure diameter and bounding box of an interpolated system
//  usage:   
//    B = nSplines(A); 
//    echo(str("outer diam=",Max(Norm(B)))); 
//    echo(str("bounding box=",Box(B))); 
         
// if flat == true min(vec of ... vec) else vec of (min(vec))
function Max(A, flat=true) = 
    let (m = 
      len(A[0])>1?
         [for(i=[0:len(A)-1]) Max(A[i])]:
          max(A) ) 
       flat?max(m):m; 

// if flat == true max(vec of ... vec) else vec of (max(vec))
function Min(A, flat=true) = 
    let (m = 
      len(A[0])>1?
         [for(i=[0:len(A)-1]) Min(A[i])]:
          min(A) ) 
       flat?min(m):m; 

// norm of vec of vec ... vec3D       
function Norm(A) = 
  let (m = 
    len(A[0])>1?
       [for(i=[0:len(A)-1]) Norm(A[i])]:
        norm(A)) m;  

// calculate bounding box over vec of ... vec3D as [[x,y,z], [X,Y,Z]]

function Box(A) = [ 
    [min(flat3(A,0)), min(flat3(A,1)), min(flat3(A,2))], 
    [max(flat3(A,0)), max(flat3(A,1)), max(flat3(A,2))], 
    ]; 

// flatten  vec of vec of ... vec3D into vec of vec3D
function flat3(A, n=0) = 
      A[0][0][0] ==undef? A[n]:
      [for (i=[0:len(A)-1]) 
        for (j=[0:len(A[i])-1]) 
          flat3(A[i][j], n)];
    

// Mavic pro mini 11/6.6

pitch = 66;  // 66 mm advance per revolution

// A blade is described by matrix M. 
// Each line of M holds 10 parameters characterizing a single
// airfoil slice (rib or frame) and its placement in 3D.
//   Parameters are: naca4(camber, dist, thickness), chord length, translation(x,y,z), rotation(x,y,z)
echo(pa(12)); 
M = [// naca_params, chord, TX,  TY,   TZ    RX, Ry,  RZ
      [ .0, .4, .15,     4,  0,   0,    2,    0,  0,  -0], // ascending pitch
      [ .1, .4, .15,     5,  0,   0,    4,    0,  0,  -10],
      [ .1, .4, .1,     10,  0,   0,   12,    0,  0,  -pa(12)], // from here proper pitch ... 
      [ .1, .4, .1,     11,  0,   0,   18,    0,  0,  -pa(18)],
      [ .1, .4, .061,    5,  0,   0,   53,    0,  0,  -pa(53)],
      [ .1, .4, .06,     2,  0,  .1,   55,    0,  0,  -pa(55)],
    ]; 


CW = true;         // set false for counter clockwise rotation
N = 50;             // # of slices to be interpolated
M_ = nSpline(M, N); // interpolation 

// create blades
sl = false;  // if true, show slices only
n=2;         // number of blades in propeller
forN(0, n)   // rotate 2 objects with radius offset 0
  Sx(CW?1:-1)  // orientation
    Rx(90)       // flip to XY plane
      sweep(gendata(M_), showslices = sl);  // extrude blade along interpolated path


/////////////////////////////////////////////////////////////
// helping functions 

function gendata(M) =  // main function to generate airfoil slices
[ for(i=[0:len(M)-1]) 
  let(N=M[i])
  let(af = Tx(-N[3]/2, vec3(airfoil_data(part(N, 0, 2), L=N[3]))))  // generate polygon for slice
  T(part(N, 4, 6), R(part(N, 7,9), af))]    // place (=rotate + translate) slice in 3D
  ; 

function part(N, start, end) = [for(i=[start:1:end]) N[i]]; // cut vector part
  
function pa(x, pitch=pitch) = atan(pitch/(2*x*PI));  // pitch angle for x [mm]
                ```
                

                Example ID: modular_8bed98a0
                Score: 0.529
                Description: I want a propeller of a drone
                Code:
                ```scad
                // Drone Propeller - Parametric OpenSCAD Model
// This model creates an aerodynamic drone propeller with customizable parameters

// ======== CUSTOMIZABLE PARAMETERS ========
// Basic dimensions
prop_diameter = 127;    // Propeller diameter in mm (5 inches)
hub_diameter = 12;      // Hub diameter in mm
hub_height = 6;         // Hub height in mm
shaft_diameter = 5;     // Motor shaft diameter in mm (M5)
num_blades = 2;         // Number of blades

// Blade parameters
blade_chord_max = 14;   // Maximum width of blade in mm
blade_chord_tip = 5;    // Width at blade tip in mm
blade_thickness = 2.5;  // Maximum thickness at blade root in mm
pitch_angle = 15;       // Base pitch angle (degrees)
twist_angle = 12;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.05;  // Airfoil camber ratio (0.0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.7; // Controls how blade width decreases toward tip (0.5-1.0)
efficiency_factor = 1.2;// Multiplier for airfoil lift curve (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution for curved surfaces
blade_segments = 18;    // Number of segments along blade length
profile_resolution = 24;// Number of points in airfoil cross-section

// ======== DERIVED VARIABLES ========
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

// ======== MODULES ========

// Generate an airfoil cross-section profile
module airfoil_profile(chord, thickness, camber, angle) {
    // Create upper and lower curves of the airfoil
    upper_points = [for (i = [0:profile_resolution]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [profile_resolution:-1:0]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments with varying properties from root to tip
    for (i = [0:blade_segments-1]) {
        // Position along blade (normalized 0-1)
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position with non-linear taper
        chord1 = blade_chord_max * (1 - t * (1 - blade_chord_tip/blade_chord_max) * pow(t, tip_taper_factor));
        chord2 = blade_chord_max * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_max) * 
                 pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip for better dynamics)
        thickness1 = blade_thickness * (1 - 0.6 * t);
        thickness2 = blade_thickness * (1 - 0.6 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution for optimal thrust)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment by connecting profiles at z1 and z2
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/3, d1 = hub_diameter, d2 = hub_diameter * 0.6, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/3, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root for structural integrity
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_max * 0.6);
            
            translate([blade_root_offset - blade_chord_max * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_max * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: unknown_7ae6d851
                Score: 0.460
                Description: I want a blade of a drone propeller
                Code:
                ```scad
                //pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 12;

//Resolution steps between stations
SectRes = 10;  

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Spinner hinge radius at pin
SpinHPinRad = 34;

//Diameter of hinge pin
SpinPinD = 3;

//Blade base diameter
SpinHubD = 6;

//Spinner hinge width
SpinHL = 7;

//Hinge Pin Height Adjuster
SpinHubVTweak = 0.25;

//Holder variables for calculated Blade section parameters.  Ignore these.
Poz1 =0;
Poz2 = 0;
StrtAngi = 0;
EndAngi = 0;
StepLi = 0;
StrtWi = 0;
EndWi = 0; 


// Blade airfoil profile. Change with caution.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];


function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

StubSteps = (Diam/(16*SectL)>SpinHPinRad*1.2)?round(Diam/(16*SectL)):round(SpinHubD*1.1/SectL);

BldStubLn = 0.98*StubSteps * SectL; 
BldStrtPoint = round((SpinHPinRad+BldStubLn+0.5*SpinHubD)/SectL)-1;

function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
    rotate([0,90,0])
    cylinder (r =0.5*SpinHubD, h = SpinHL, center = true, $fn = 100);
}



module Hubcutter()
{
    union()
    {
        // Pin hole
        translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r = 0.5*SpinPinD, h = SpinHL*4, center = true, $fn = 100);
        
        //The two face shavers
        translate([1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 0.6*SpinHubD, r2 = 2.5*SpinHubD, h = SpinHL*2, center = true, $fn = 100);
        
        translate([-1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 5*SpinHubD, r2 = 0.6*SpinHubD, h = SpinHL*2, center = true, $fn = 100);        

    }
}


module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    union()
    {
    for(i = [BldStrtPoint:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module Hinge()
{
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*(SpinHPinRad+BldStubLn+0.5*SpinHubD)/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        EndAngi = atan(Pitch/(2*PI*(SpinHPinRad+BldStubLn+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+BldStubLn+0.5*SpinHubD);
        StrtAngi = atan(Pitch/(2*PI*(SpinHPinRad+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+0.5*SpinHubD);
        

            translate([0,-SpinHPinRad-0.5*SpinHubD,0])        
            rotate([90,0,0])
            Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);

    }
}


translate([0,SpinHPinRad,0])
difference()
{
    union()
    {
        Hinge();
        rotate([90,0,0])BladeBuilder();
    }
    Hubcutter();
}
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Aerodynamic efficiency (airfoil profile, pitch angle, and twist distribution)
- Structural integrity (material strength, thickness distribution, hub reinforcement)
- Balance and weight distribution (symmetry, mass distribution, center of gravity)
- Rotational dynamics (moment of inertia, tip speed, centrifugal forces)
- Noise reduction (blade tip design, edge profiling)
- Manufacturability (printable geometries, support requirements, material limitations)
- Code Structure: module structure
- Code Structure: algorithms for aerodynamic calculations
- Code Structure: parametric design for blade optimization
- Implementation Technique: minkowski
- Implementation Technique: rotate
- Implementation Technique: union
- Implementation Technique: mirror
- Implementation Technique: pattern
- Implementation Technique: scale
- Implementation Technique: extrude
                    
                    SHAPE COMPONENTS:
                    - Hub/mount (central connection point with motor shaft hole and mounting pattern)
- Blade root (transition area from hub to blade with reinforced structure)
- Blade airfoil (cross-sectional profile optimized for lift and efficiency)
- Blade twist (gradual change in angle from root to tip for consistent lift)
- Blade taper (width and thickness variation along blade length)
- Tip design (specialized shape to reduce vortices and noise)
- Leading edge (front edge profile for air contact)
- Trailing edge (back edge thinned for reduced drag)
                    
                    IMPLEMENTATION STEPS:
                    1. Define propeller specifications (diameter, pitch, number of blades, rotation direction)
2. Create the central hub with appropriate motor shaft hole and mounting pattern
3. Design the airfoil profile cross-section based on aerodynamic requirements
4. Establish the blade twist distribution from root to tip (higher angle at root, lower at tip)
5. Generate the 3D blade by sweeping the airfoil along the blade path with proper twist
6. Mirror or rotate the blade to create multiple balanced blades around the hub
7. Add fillets and reinforcements at stress concentration points (blade-hub junction)
8. Verify balance, structural integrity, and printability through simulation
9. Optimize for weight reduction while maintaining strength (internal structures/ribs)
10. Prepare the model for 3D printing with appropriate tolerances and support considerations

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "mechanical" type. Here's a suggested structure:
                
                ```scad
                
        module drone propeller(height=10, width=20, depth=15, wall_thickness=2) {
            union() {
                // Base shape based on: Hub/mount (central connection point with motor shaft hole and mounting pattern), Blade root (transition area from hub to blade with reinforced structure), Blade airfoil (cross-sectional profile optimized for lift and efficiency), Blade twist (gradual change in angle from root to tip for consistent lift), Blade taper (width and thickness variation along blade length), Tip design (specialized shape to reduce vortices and noise), Leading edge (front edge profile for air contact), Trailing edge (back edge thinned for reduced drag)
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
prop_diameter = 127; // Propeller diameter in mm (5 inches)
num_blades = 2; // Number of propeller blades (2-6)
pitch_angle = 10; // The pitch angle of the blades in degrees, affects lift and efficiency
hub_diameter = 20; // Diameter of the central hub in mm
shaft_diameter = 5; // Diameter of the center hole for motor shaft mounting in mm
blade_chord_max = 14; // Maximum width of blade in mm
blade_thickness = 2.5; // Maximum thickness of blade in mm
twist_angle = 12; // Additional twist from root to tip in degrees
propeller_diameter = 127; // The total diameter of the propeller in mm (tip-to-tip)
blade_count = 2; // Number of blades on the propeller (typically 2, 3, or 4)
rotation_direction = ccw; // Rotation direction of the propeller (ccw for counter-clockwise, cw for clockwise)


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: How to CAD and 3D print a Drone Propeller + CAD Basics!!! (Fusion ...
Content: Hey guys, this video shows some CAD basics and how to implement these tricks to make a drone propeller. Sorry about the long video and my
---

Title: Assembly procedures of propeller: (a) fabricate the 3D printed...
Content: Assembly procedures of propeller: (a) fabricate the 3D printed components for building a propeller assembly , (b) assemble the BLDC motor and the propeller
---

Title: [PDF] Design of Multi Material Drone Propeller - IIETA
Content: Multi-material plan has acquired consideration in designing ... The main purpose is to extend drones flight time and enhance their propulsion
---

Title: 3D printed drone propellers - Weerg
Content: The use of materials such as versatile resin and PA11 nylon allows for the experimentation of propeller configurations that would be complex or
---

Title: RC Drone Propeller - 3D Model by 3dsldworks
Content: RC drone propeller dimensions: Main diameter - 1.5 Inch (40mm) , Hole diameter - 1.5mm, Height - 0.2 inch (6.3mm). More by 3dsldworks  Bionic
---


USER REQUEST:
aerodynamic efficiency airfoil profile pitch angle twist distribution structural integrity material strength thickness distribution hub reinforcement balance weight distribution symmetry mass distribution center of gravity rotational dynamics moment of inertia tip speed centrifugal forces noise reduction blade tip design edge profiling manufacturability printable geometries support requirements material limitations drone propeller

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: quadcopter frame
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: modular_0cfc9eba
                Score: 0.798
                Description: Design of the frame of a quadcopter with 4 arms
                Code:
                ```scad
                module fillet(r=1.0,steps=3,include=true, fn=8) {
  if(include) for (k=[0:$children-1]) {
	children(k);
  }
  for (i=[0:$children-2] ) {
    for(j=[i+1:$children-1] ) {
	fillet_two(r=r,steps=steps, fn=fn) {
	  children(i);
	  children(j);
	  intersection() {
		children(i);
		children(j);
	  }
	}
    }
  }
}

module fillet_two(r=1.0, steps=3, fn=8) {
  for(step=[1:steps]) {
	hull() {
	  render() intersection() {
		children(0);
		offset_3d(r=r*step/steps, fn=fn) children(2);
	  }
	  render() intersection() {
		children(1);
		offset_3d(r=r*(steps-step+1)/steps, fn=fn) children(2);
	  }
	}
  }
}

module offset_3d(r=1.0, fn=8) {
  for(k=[0:$children-1]) minkowski() {
	children(k);
	sphere(r=r,$fn=fn);
  }
}

//$fn=200;
$fa = 1;
$fs= 0.1;


motor_platform_radius_inside = 25/2;
motor_platform_thickness = 3;
motor_protection_thickness = 2;
motor_protection_height = 14 + motor_platform_thickness - motor_protection_thickness/2;

motor_axis_protection_radius = 5.5/2;
motor_axis_protection_height = 2.3;
motor_platform_radius = motor_platform_radius_inside + motor_protection_thickness;

motor_screw_hole_radius = 2/2;
//45+90 = Gleichschenkliges rechtwinkliges Dreieck
//c = a*sqrt(2),
motor_screw_right_C = 6;
motor_screw_right_A = motor_screw_right_C/sqrt(2);
motor_screw_left_C = 8;
motor_screw_left_A = motor_screw_left_C/sqrt(2);
arm_width = 20;
arm_thickness = 6;
arm_angle = 15;

propeller_radius = 127/2;
propeller_safety_distance = 13;

arm_width_angled = 20;
arm_box_rounding_radius = 10;

motor_platform_rounding_radius = 20;
motor_platform_rounding_triangle_C = motor_platform_radius + motor_platform_rounding_radius;
motor_platform_rounding_triangle_B = arm_width/2 + motor_platform_rounding_radius;
motor_platform_rounding_triangle_A = sqrt(pow(motor_platform_rounding_triangle_C,2)-pow(motor_platform_rounding_triangle_B,2));
motor_platform_rounding_angle = asin(motor_platform_rounding_triangle_A/motor_platform_rounding_triangle_C);
motor_platform_rounding_intersection_X = sin(motor_platform_rounding_angle)*motor_platform_rounding_radius;
motor_platform_rounding_intersection_Y = tan(motor_platform_rounding_angle)*motor_platform_rounding_radius;

motor_platform_Z_rounding_radius = 6;

// motor_cable_hole_start = motor_platform_radius+motor_platform_Z_rounding_radius;
motor_cable_hole_angle = 12;
//motor_cable_hole_alpha = 180-motor_cable_hole_angle-90;
motor_cable_hole_triangle_a = arm_thickness - motor_platform_thickness;
motor_cable_hole_triangle_b = motor_cable_hole_triangle_a/tan(motor_cable_hole_angle);
motor_cable_hole_width = 4.5;
motor_cable_hole_height = 3;
motor_cable_hole_relation = motor_cable_hole_height/motor_cable_hole_width;
motor_cable_hole_start = motor_platform_radius_inside + motor_cable_hole_triangle_b;

//motor_distance_front_back = 153;
//motor_distance_left_right = 102*2;

motor_distance_front_back = propeller_radius*2+propeller_safety_distance*2;

box_wall_thickness = 2;
box_wall_height = 24.2;
box_bottom_thickness = 4;
box_length = motor_distance_front_back + motor_platform_radius*2;
echo("box_length = ", box_length);

flight_controller_slot_depth = 1.5;
flight_controller_size = 36;

sonar_center_distance = -70.8;
sonar_platform_height = 12;
sonar_platform_width = 45.3;
sonar_platform_length = 20.3;
sonar_hole_radius = 16 / 2;
sonar_hole_distance = 9.65;

box_width = max(flight_controller_size, sonar_platform_width) + 2*box_wall_thickness;
motor_distance_left_right = box_width + propeller_radius*2 + propeller_safety_distance*2;

box_front_add = box_width/2 - 9.5;
box_front_add_diff = box_width/2 - box_front_add;
box_front_rounding_center = box_front_add_diff - box_length/2;
//echo("box_front_add = ", box_front_add);
//echo("box_front_add_diff = ", box_front_add_diff);
//echo("box_front_rounding_center = ", box_front_rounding_center);

arm_length = (motor_distance_left_right/2) / cos(arm_angle);

esc_cable_hole_width = 3;
esc_cable_hole_height = 1.2;
esc_cable_hole_relation = esc_cable_hole_height/esc_cable_hole_width;
motor_center_esc_hole_distance = ((motor_distance_left_right - box_width +box_wall_thickness)/2);
box_cable_hole_intersection = motor_distance_front_back/2 - motor_center_esc_hole_distance * tan(arm_angle);

fpv_cam_thread_radius = 11.86/2;
fpv_cam_thread_height = 16;
fpv_cam_board_floor_thickness = 2;
fpv_cam_board_width = 33;
fpv_cam_board_thickness = 5;
fpv_cam_board_thread_distance = 16;

openlog_wall1_a = 1.5;
openlog_wall1_b = 2;
openlog_wall1_from_corner = 19.3;

openlog_wall2_from_corner = 5;
openlog_wall2_a = 22;
openlog_wall2_b = 2;
openlog_wall2_height = box_bottom_thickness + 8;
openlog_wall2_rounding_radius = 3;

openlog_slot_thickness = 1.1;
openlog_slot_height = 11.4;
openlog_slot_from_floor = 0.8;

gps_tower_radius_outside = 10.2/2;
gps_tower_radius_inside = 7.9/2;
gps_tower_height = 10;
gps_tower_outside_holder = 4;
gps_tower_center_distance = 48;

module arm_2D() {
    translate([0,-arm_width/2]) square([arm_length,arm_width]);

    // rounding between motor platform and arm
    difference() {
        translate([motor_platform_rounding_triangle_A-motor_platform_rounding_intersection_X,-motor_platform_rounding_triangle_B]) square([motor_platform_rounding_intersection_X,arm_width+motor_platform_rounding_radius*2]);
        
        translate([motor_platform_rounding_triangle_A,motor_platform_rounding_triangle_B]) circle(r=motor_platform_rounding_radius);
        translate([motor_platform_rounding_triangle_A,-motor_platform_rounding_triangle_B,-0.1]) circle(r=motor_platform_rounding_radius);
    }
}

module motor_platform() {
    difference() {
        cylinder(r=motor_platform_radius, h=motor_platform_thickness);
        
        // axis protection
        translate([0,0,motor_platform_thickness-motor_axis_protection_height]) cylinder(r=motor_axis_protection_radius, h=motor_axis_protection_height+0.1);

        // screw holes
        translate([motor_screw_right_A,motor_screw_right_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([-motor_screw_right_A,-motor_screw_right_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([motor_screw_left_A,-motor_screw_left_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([-motor_screw_left_A,motor_screw_left_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
    }
    
    //space required by propellers
    //translate([0,0,30]) cylinder(r=propeller_radius,h=0.1);
}

module motor_protection() {
    
    difference() {
        cylinder(r=motor_platform_radius, h=motor_protection_height);
            translate([0,0,-0.1])
        cylinder(r=motor_platform_radius_inside, h=motor_protection_height+0.2);
    }
    translate([0,0,motor_protection_height])
    rotate_extrude()
    translate([motor_platform_radius_inside+motor_protection_thickness/2,0,0]) 
    circle(r=motor_protection_thickness/2);
    
    translate([0,0,arm_thickness])
    intersection() {
        linear_extrude(height=motor_platform_Z_rounding_radius+1) arm_2D();
        rotate_extrude()
        translate([motor_platform_radius, 0, 0])
        difference() {
            square([motor_platform_Z_rounding_radius,motor_platform_Z_rounding_radius]);
            translate([motor_platform_Z_rounding_radius,motor_platform_Z_rounding_radius])
            circle(r = motor_platform_Z_rounding_radius);
        }
    }
}

module simple_arm() {
    translate([motor_platform_radius*2,-arm_width/2]) cube([arm_length-motor_platform_radius*2,arm_width,arm_thickness]);
}

module complete_arm() {
    
    difference() {
        union() {
            motor_protection();
            difference() {
                linear_extrude(height=arm_thickness) arm_2D();
                //subtract the space of the motor_platform from the arm
                translate([0,0,-0.1]) cylinder(r=motor_platform_radius_inside, h=motor_protection_height);
            }
        }
        
        translate([motor_cable_hole_start,0,arm_thickness])
        rotate([0,-1*(motor_cable_hole_angle+90),0])
        translate([motor_cable_hole_height,0,0])
        scale([motor_cable_hole_relation,1,1])
        cylinder(r=motor_cable_hole_width,h=motor_cable_hole_triangle_b+motor_platform_radius); 
    }
    motor_platform();
}

module box_arm_fillet() { // fillet(r=15,steps=30, fn=50) {
    //only the part of the box, that is symetrical front and back (so subtracting box_front_add_diff*2 in size)
    translate([0,0,box_wall_height/2]) cube([box_width,box_length-box_front_add_diff*2,box_wall_height], center=true);
    translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) simple_arm();
}

module placed_arm() {
    translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) complete_arm();
}

module placed_esc_to_fc_hole() {
    translate([box_width/2-box_wall_thickness,box_cable_hole_intersection,box_bottom_thickness])
    rotate([0,90-15,arm_angle])
    difference() {
        c = esc_cable_hole_width*2 / cos(arm_angle);
        b = sin(arm_angle) * c;
        
        scale([esc_cable_hole_relation,1,1])
        translate([-esc_cable_hole_width,0,-b/2])
        cylinder(r=esc_cable_hole_width, h=arm_length/3);
        
        rotate([arm_angle,0,0])
        translate([-esc_cable_hole_height*2-1,-c/2,-b])
        cube([esc_cable_hole_height*2+2,c,b]);
    }
}

module box_with_arms() difference() {
    union() {
        translate([0,box_front_add_diff/2,box_wall_height/2]) cube([box_width,box_length-box_front_add_diff,box_wall_height], center=true);
        box_arm_fillet();
        mirror([0,1,0]) box_arm_fillet();
        mirror([1,0,0]) box_arm_fillet();
        mirror([0,1,0]) mirror([1,0,0]) box_arm_fillet();

        translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) complete_arm();
        translate([-motor_distance_left_right/2,motor_distance_front_back/2,0]) rotate([0,0,-arm_angle]) complete_arm();
        translate([motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,180-arm_angle]) complete_arm();
        translate([motor_distance_left_right/2,motor_distance_front_back/2,0]) rotate([0,0,-180+arm_angle]) complete_arm();
        
        //rounding in front for fpv camera
        translate([0,box_front_rounding_center,0]) cylinder(r=box_width/2, h= box_wall_height);
    }
    
    //make the box hollow, leave a wall with box_wall_thickness
    translate([0,-box_wall_thickness/2+box_front_add_diff/2,box_wall_height/2+box_bottom_thickness]) cube([box_width-box_wall_thickness*2,box_length-box_wall_thickness-box_front_add_diff,box_wall_height], center=true);
    
    translate([0,box_front_rounding_center,box_bottom_thickness]) cylinder(r=box_width/2-box_wall_thickness, h= box_wall_height);
    
    // holes in the box for cables from ESC to flightcontroller
    placed_esc_to_fc_hole();
    mirror([0,1,0]) placed_esc_to_fc_hole();
    mirror([1,0,0]) placed_esc_to_fc_hole();
    mirror([0,1,0]) mirror([1,0,0]) placed_esc_to_fc_hole();
}

module gps_tower() {
    cylinder(r = gps_tower_radius_inside, h = gps_tower_height);
    translate([0,0,gps_tower_height])
    sphere(r = gps_tower_radius_inside);

    rotate_extrude()
    translate([gps_tower_radius_outside, 0, 0])
    difference() {
        square([gps_tower_outside_holder,gps_tower_outside_holder]);
        translate([gps_tower_outside_holder,gps_tower_outside_holder])
        circle(r = gps_tower_outside_holder);
    }
}

module box_with_all_adds() {
    //debug_box();
    box_with_arms();
    
    //sonar platform
translate([0,sonar_center_distance,sonar_platform_height/2])
cube([box_width-box_wall_thickness*2,sonar_platform_length,sonar_platform_height], center=true);
    
    //openlog wall1
    translate([-box_width/2+box_wall_thickness,box_length/2-box_wall_thickness-openlog_wall1_from_corner-openlog_wall1_a,0])
    cube([openlog_wall1_b,openlog_wall1_a,box_wall_height]);
    
    //openlog wall2
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner,box_length/2-box_wall_thickness-openlog_wall2_a,0])
    cube([openlog_wall2_b,openlog_wall2_a,openlog_wall2_height]);

    //openlog wall2 rounding
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner+openlog_wall2_b,box_length/2-box_wall_thickness-openlog_wall2_rounding_radius,0])
    difference() {
        cube([openlog_wall2_rounding_radius,openlog_wall2_rounding_radius,openlog_wall2_height]);
        translate([openlog_wall2_rounding_radius,0,0])
        cylinder(r = openlog_wall2_rounding_radius, h = openlog_wall2_height+1);
    }
    
    //gps tower
    translate([0,-gps_tower_center_distance,box_bottom_thickness])
    gps_tower();
}

module quad_with_slots() difference() {
    box_with_all_adds();
    
    //sonar holes
    translate([sonar_hole_radius+sonar_hole_distance/2,sonar_center_distance,0])
    cylinder(r=sonar_hole_radius, h=39.229+1, center=true);
    translate([-sonar_hole_radius-sonar_hole_distance/2,sonar_center_distance,0])
    cylinder(r=sonar_hole_radius, h=39.229+1, center=true);
    
    //slit through sonar platform for camera cable
    translate([0,sonar_center_distance,sonar_platform_height/2+box_bottom_thickness+1])
    cube([11,sonar_platform_length+2,sonar_platform_height+2], center=true);
    
    //openlog_micro_sd_card_slot
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner-openlog_slot_thickness,box_length/2-box_wall_thickness-1,box_bottom_thickness+openlog_slot_from_floor])
    cube([openlog_slot_thickness,box_wall_thickness+2,openlog_slot_height]);
    
    //flight controller slot
    translate([0,0,box_bottom_thickness+(flight_controller_slot_depth+1)/2-flight_controller_slot_depth])
    cube([flight_controller_size,flight_controller_size,(flight_controller_slot_depth+1)], center=true);
    
    //fpv cam thread mount
    translate([0,-box_length/2,fpv_cam_thread_radius+fpv_cam_thread_height+fpv_cam_board_floor_thickness])
    rotate([90,0,0]) cylinder(r=fpv_cam_thread_radius, h=20);
    //fpv board slot
    translate([-fpv_cam_board_width/2,-box_length/2-box_front_add+fpv_cam_board_thread_distance,fpv_cam_board_floor_thickness]) cube([fpv_cam_board_width,fpv_cam_board_thickness,10]);
}

module sonar_platform() difference() {
    cube([box_width-box_wall_thickness*2,sonar_platform_length,sonar_platform_height], center=true);
    //
}


quad_with_slots();
                ```
                

                Example ID: modular_e6bcb845
                Score: 0.774
                Description: Design of a frame of a drone
                Code:
                ```scad
                module fillet(r=1.0,steps=3,include=true, fn=8) {
  if(include) for (k=[0:$children-1]) {
	children(k);
  }
  for (i=[0:$children-2] ) {
    for(j=[i+1:$children-1] ) {
	fillet_two(r=r,steps=steps, fn=fn) {
	  children(i);
	  children(j);
	  intersection() {
		children(i);
		children(j);
	  }
	}
    }
  }
}

module fillet_two(r=1.0, steps=3, fn=8) {
  for(step=[1:steps]) {
	hull() {
	  render() intersection() {
		children(0);
		offset_3d(r=r*step/steps, fn=fn) children(2);
	  }
	  render() intersection() {
		children(1);
		offset_3d(r=r*(steps-step+1)/steps, fn=fn) children(2);
	  }
	}
  }
}

module offset_3d(r=1.0, fn=8) {
  for(k=[0:$children-1]) minkowski() {
	children(k);
	sphere(r=r,$fn=fn);
  }
}

$fa = 1;
$fs= 0.1;


motor_platform_radius_inside = 25/2;
motor_platform_thickness = 3;
motor_protection_thickness = 2;
motor_protection_height = 14 + motor_platform_thickness - motor_protection_thickness/2;

motor_axis_protection_radius = 5.5/2;
motor_axis_protection_height = 2.3;
motor_platform_radius = motor_platform_radius_inside + motor_protection_thickness;

motor_screw_hole_radius = 2/2;

motor_screw_right_C = 6;
motor_screw_right_A = motor_screw_right_C/sqrt(2);
motor_screw_left_C = 8;
motor_screw_left_A = motor_screw_left_C/sqrt(2);
arm_width = 20;
arm_thickness = 6;
arm_angle = 15;

propeller_radius = 127/2;
propeller_safety_distance = 13;

arm_width_angled = 20;
arm_box_rounding_radius = 10;

motor_platform_rounding_radius = 20;
motor_platform_rounding_triangle_C = motor_platform_radius + motor_platform_rounding_radius;
motor_platform_rounding_triangle_B = arm_width/2 + motor_platform_rounding_radius;
motor_platform_rounding_triangle_A = sqrt(pow(motor_platform_rounding_triangle_C,2)-pow(motor_platform_rounding_triangle_B,2));
motor_platform_rounding_angle = asin(motor_platform_rounding_triangle_A/motor_platform_rounding_triangle_C);
motor_platform_rounding_intersection_X = sin(motor_platform_rounding_angle)*motor_platform_rounding_radius;
motor_platform_rounding_intersection_Y = tan(motor_platform_rounding_angle)*motor_platform_rounding_radius;

motor_platform_Z_rounding_radius = 6;

motor_cable_hole_angle = 12;

motor_cable_hole_triangle_a = arm_thickness - motor_platform_thickness;
motor_cable_hole_triangle_b = motor_cable_hole_triangle_a/tan(motor_cable_hole_angle);
motor_cable_hole_width = 4.5;
motor_cable_hole_height = 3;
motor_cable_hole_relation = motor_cable_hole_height/motor_cable_hole_width;
motor_cable_hole_start = motor_platform_radius_inside + motor_cable_hole_triangle_b;


motor_distance_front_back = propeller_radius*2+propeller_safety_distance*2;

box_wall_thickness = 2;
box_wall_height = 24.2;
box_bottom_thickness = 4;
box_length = motor_distance_front_back + motor_platform_radius*2;
echo("box_length = ", box_length);

flight_controller_slot_depth = 1.5;
flight_controller_size = 36;

sonar_center_distance = -70.8;
sonar_platform_height = 12;
sonar_platform_width = 45.3;
sonar_platform_length = 20.3;
sonar_hole_radius = 16 / 2;
sonar_hole_distance = 9.65;

box_width = max(flight_controller_size, sonar_platform_width) + 2*box_wall_thickness;
motor_distance_left_right = box_width + propeller_radius*2 + propeller_safety_distance*2;

box_front_add = box_width/2 - 9.5;
box_front_add_diff = box_width/2 - box_front_add;
box_front_rounding_center = box_front_add_diff - box_length/2;


arm_length = (motor_distance_left_right/2) / cos(arm_angle);

esc_cable_hole_width = 3;
esc_cable_hole_height = 1.2;
esc_cable_hole_relation = esc_cable_hole_height/esc_cable_hole_width;
motor_center_esc_hole_distance = ((motor_distance_left_right - box_width +box_wall_thickness)/2);
box_cable_hole_intersection = motor_distance_front_back/2 - motor_center_esc_hole_distance * tan(arm_angle);

fpv_cam_thread_radius = 11.86/2;
fpv_cam_thread_height = 16;
fpv_cam_board_floor_thickness = 2;
fpv_cam_board_width = 33;
fpv_cam_board_thickness = 5;
fpv_cam_board_thread_distance = 16;

openlog_wall1_a = 1.5;
openlog_wall1_b = 2;
openlog_wall1_from_corner = 19.3;

openlog_wall2_from_corner = 5;
openlog_wall2_a = 22;
openlog_wall2_b = 2;
openlog_wall2_height = box_bottom_thickness + 8;
openlog_wall2_rounding_radius = 3;

openlog_slot_thickness = 1.1;
openlog_slot_height = 11.4;
openlog_slot_from_floor = 0.8;

gps_tower_radius_outside = 10.2/2;
gps_tower_radius_inside = 7.9/2;
gps_tower_height = 10;
gps_tower_outside_holder = 4;
gps_tower_center_distance = 48;

module arm_2D() {
    translate([0,-arm_width/2]) square([arm_length,arm_width]);

    // rounding between motor platform and arm
    difference() {
        translate([motor_platform_rounding_triangle_A-motor_platform_rounding_intersection_X,-motor_platform_rounding_triangle_B]) square([motor_platform_rounding_intersection_X,arm_width+motor_platform_rounding_radius*2]);
        
        translate([motor_platform_rounding_triangle_A,motor_platform_rounding_triangle_B]) circle(r=motor_platform_rounding_radius);
        translate([motor_platform_rounding_triangle_A,-motor_platform_rounding_triangle_B,-0.1]) circle(r=motor_platform_rounding_radius);
    }
}

module motor_platform() {
    difference() {
        cylinder(r=motor_platform_radius, h=motor_platform_thickness);
        
        // axis protection
        translate([0,0,motor_platform_thickness-motor_axis_protection_height]) cylinder(r=motor_axis_protection_radius, h=motor_axis_protection_height+0.1);

        // screw holes
        translate([motor_screw_right_A,motor_screw_right_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([-motor_screw_right_A,-motor_screw_right_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([motor_screw_left_A,-motor_screw_left_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([-motor_screw_left_A,motor_screw_left_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
    }
    
}

module motor_protection() {
    
    difference() {
        cylinder(r=motor_platform_radius, h=motor_protection_height);
            translate([0,0,-0.1])
        cylinder(r=motor_platform_radius_inside, h=motor_protection_height+0.2);
    }
    translate([0,0,motor_protection_height])
    rotate_extrude()
    translate([motor_platform_radius_inside+motor_protection_thickness/2,0,0]) 
    circle(r=motor_protection_thickness/2);
    
    translate([0,0,arm_thickness])
    intersection() {
        linear_extrude(height=motor_platform_Z_rounding_radius+1) arm_2D();
        rotate_extrude()
        translate([motor_platform_radius, 0, 0])
        difference() {
            square([motor_platform_Z_rounding_radius,motor_platform_Z_rounding_radius]);
            translate([motor_platform_Z_rounding_radius,motor_platform_Z_rounding_radius])
            circle(r = motor_platform_Z_rounding_radius);
        }
    }
}

module simple_arm() {
    translate([motor_platform_radius*2,-arm_width/2]) cube([arm_length-motor_platform_radius*2,arm_width,arm_thickness]);
}

module complete_arm() {
    
    difference() {
        union() {
            motor_protection();
            difference() {
                linear_extrude(height=arm_thickness) arm_2D();
                //subtract the space of the motor_platform from the arm
                translate([0,0,-0.1]) cylinder(r=motor_platform_radius_inside, h=motor_protection_height);
            }
        }
        
        translate([motor_cable_hole_start,0,arm_thickness])
        rotate([0,-1*(motor_cable_hole_angle+90),0])
        translate([motor_cable_hole_height,0,0])
        scale([motor_cable_hole_relation,1,1])
        cylinder(r=motor_cable_hole_width,h=motor_cable_hole_triangle_b+motor_platform_radius); 
    }
    motor_platform();
}

module box_arm_fillet() { 
    translate([0,0,box_wall_height/2]) cube([box_width,box_length-box_front_add_diff*2,box_wall_height], center=true);
    translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) simple_arm();
}

module placed_arm() {
    translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) complete_arm();
}

module placed_esc_to_fc_hole() {
    translate([box_width/2-box_wall_thickness,box_cable_hole_intersection,box_bottom_thickness])
    rotate([0,90-15,arm_angle])
    difference() {
        c = esc_cable_hole_width*2 / cos(arm_angle);
        b = sin(arm_angle) * c;
        
        scale([esc_cable_hole_relation,1,1])
        translate([-esc_cable_hole_width,0,-b/2])
        cylinder(r=esc_cable_hole_width, h=arm_length/3);
        
        rotate([arm_angle,0,0])
        translate([-esc_cable_hole_height*2-1,-c/2,-b])
        cube([esc_cable_hole_height*2+2,c,b]);
    }
}

module box_with_arms() difference() {
    union() {
        translate([0,box_front_add_diff/2,box_wall_height/2]) cube([box_width,box_length-box_front_add_diff,box_wall_height], center=true);
        box_arm_fillet();
        mirror([0,1,0]) box_arm_fillet();
        mirror([1,0,0]) box_arm_fillet();
        mirror([0,1,0]) mirror([1,0,0]) box_arm_fillet();
        placed_arm();
        mirror([0,1,0]) placed_arm();
        mirror([1,0,0]) placed_arm();
        mirror([0,1,0]) mirror([1,0,0]) placed_arm();
        
        //rounding in front for fpv camera
        translate([0,box_front_rounding_center,0]) cylinder(r=box_width/2, h= box_wall_height);
    }
    
    //make the box hollow, leave a wall with box_wall_thickness
    translate([0,-box_wall_thickness/2+box_front_add_diff/2,box_wall_height/2+box_bottom_thickness]) cube([box_width-box_wall_thickness*2,box_length-box_wall_thickness-box_front_add_diff,box_wall_height], center=true);
    
    translate([0,box_front_rounding_center,box_bottom_thickness]) cylinder(r=box_width/2-box_wall_thickness, h= box_wall_height);
    
    // holes in the box for cables from ESC to flightcontroller
    placed_esc_to_fc_hole();
    mirror([0,1,0]) placed_esc_to_fc_hole();
    mirror([1,0,0]) placed_esc_to_fc_hole();
    mirror([0,1,0]) mirror([1,0,0]) placed_esc_to_fc_hole();
}

module gps_tower() {
    cylinder(r = gps_tower_radius_inside, h = gps_tower_height);
    translate([0,0,gps_tower_height])
    sphere(r = gps_tower_radius_inside);

    rotate_extrude()
    translate([gps_tower_radius_outside, 0, 0])
    difference() {
        square([gps_tower_outside_holder,gps_tower_outside_holder]);
        translate([gps_tower_outside_holder,gps_tower_outside_holder])
        circle(r = gps_tower_outside_holder);
    }
}

module box_with_all_adds() {
    box_with_arms();
    
    //sonar platform
translate([0,sonar_center_distance,sonar_platform_height/2])
cube([box_width-box_wall_thickness*2,sonar_platform_length,sonar_platform_height], center=true);
    
    //openlog wall1
    translate([-box_width/2+box_wall_thickness,box_length/2-box_wall_thickness-openlog_wall1_from_corner-openlog_wall1_a,0])
    cube([openlog_wall1_b,openlog_wall1_a,box_wall_height]);
    
    //openlog wall2
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner,box_length/2-box_wall_thickness-openlog_wall2_a,0])
    cube([openlog_wall2_b,openlog_wall2_a,openlog_wall2_height]);

    //openlog wall2 rounding
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner+openlog_wall2_b,box_length/2-box_wall_thickness-openlog_wall2_rounding_radius,0])
    difference() {
        cube([openlog_wall2_rounding_radius,openlog_wall2_rounding_radius,openlog_wall2_height]);
        translate([openlog_wall2_rounding_radius,0,0])
        cylinder(r = openlog_wall2_rounding_radius, h = openlog_wall2_height+1);
    }
    
    //gps tower
    translate([0,-gps_tower_center_distance,box_bottom_thickness])
    gps_tower();
}

module quad_with_slots() difference() {
    box_with_all_adds();
    
    //sonar holes
    translate([sonar_hole_radius+sonar_hole_distance/2,sonar_center_distance,0])
    cylinder(r=sonar_hole_radius, h=39.229+1, center=true);
    translate([-sonar_hole_radius-sonar_hole_distance/2,sonar_center_distance,0])
    cylinder(r=sonar_hole_radius, h=39.229+1, center=true);
    
    //slit through sonar platform for camera cable
    translate([0,sonar_center_distance,sonar_platform_height/2+box_bottom_thickness+1])
    cube([11,sonar_platform_length+2,sonar_platform_height+2], center=true);
    
    //openlog_micro_sd_card_slot
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner-openlog_slot_thickness,box_length/2-box_wall_thickness-1,box_bottom_thickness+openlog_slot_from_floor])
    cube([openlog_slot_thickness,box_wall_thickness+2,openlog_slot_height]);
    
    //flight controller slot
    translate([0,0,box_bottom_thickness+(flight_controller_slot_depth+1)/2-flight_controller_slot_depth])
    cube([flight_controller_size,flight_controller_size,(flight_controller_slot_depth+1)], center=true);
    
    //fpv cam thread mount
    translate([0,-box_length/2,fpv_cam_thread_radius+fpv_cam_thread_height+fpv_cam_board_floor_thickness])
    rotate([90,0,0]) cylinder(r=fpv_cam_thread_radius, h=20);
    //fpv board slot
    translate([-fpv_cam_board_width/2,-box_length/2-box_front_add+fpv_cam_board_thread_distance,fpv_cam_board_floor_thickness]) cube([fpv_cam_board_width,fpv_cam_board_thickness,10]);
}

module sonar_platform() difference() {
    cube([box_width-box_wall_thickness*2,sonar_platform_length,sonar_platform_height], center=true);

}
quad_with_slots();
                ```
                

                Example ID: unknown_9af337fa
                Score: 0.706
                Description: I want a drone propeller with 4 blades, each of it with 6 inches and diameter of 9 inches
                Code:
                ```scad
                //pitch (inches)
PitchI = 6;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 4;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_301fdbd5
                Score: 0.678
                Description: Propeller for a whirligig
                Code:
                ```scad
                $fn=180;
Off_ang=-20;
//30mm_bearing cut out
difference(){	union(){
					propeller(5);
						translate([0,0,25])
							scale([1,1,.45])
					hub(20);}
	translate([0,0,-20])
		cylinder(h=30,r=15);}
 module hub(ra){
	 translate([0,0,-55])
		cylinder(h=40,r=ra);
	 	 translate([0,0,-15])
			scale([1,1,.8])
				sphere(ra);}
module propeller(x){
	rotate([-90,0,0])
		for(i=[1:360/x:360])
			rotate([0,i,0])	prop();}
module prop(){
	 scale([.5,1,1])
		translate([0,-11,10])
			intersection(){
				linear_extrude(230,twist=40,scale=.15){
					scale([3,1]) circle(10);}
						translate([0,3,0])
							rotate([0,5,Off_ang])
								scale([.5,.2,3])
									sphere(40);}}
                ```
                

                Example ID: modular_e755671c
                Score: 0.626
                Description: A frame for a foldable nano drone
                Code:
                ```scad
                // Select object to show / print
show = "all" ; 

// Show additional electronic components
ghosts = 0 ; // [0:w/o electronic parts, 1:With ghost components]

// Select flight controller footprint
FC_footprint = "31x31" ; // ["31x31":Naze32 30.5x30.5mm, "45x45":MultiWii 45x45mm, "none":No footprint]

/* [Frame Dimensions] */
// Frame Basic Length
Quad_L = 90 ;	// [80:150]

// Frame Basic Width
Quad_B = 70 ;	 // [65:100]

// Boom Flight Position Angle
Quad_W = 50 ; // [45:65]

// Jeti RSAT antenna holder on top
ant_holder = 1 ; // [0:w/o antenna holder, 1:with antenna holder]

// Cover dome on top
top_cover = 1 ; // [0:w/o top cover, 1:with top cover]

// Height of 4 Flight Controller screw domes
Dome_H = 6 ;  // [3:0.5:10]

// Geometry of Flight Position Stoppers 
StopperFill = 1 ; // [0:No fill-only stopper blades, 1:Side blades filled]

/* [Boom Dimensions] */
// Motor type
motor_type = "hk1811sup" ; // ["hk1811sup":HK1811 with support, "hk1811":HK1811 without support, "bx1306":BX1306]

// Height of rotor bell
H_Rotor = 7.5 ; // [7.5:7.5 for HK1811 Motor, 10.0:10 Low for BX1306, 12.0:12 High for BX1306]

// Inner radius of motor holder around rotor bell
R_Rotor = 9.7 ; // [9.7:9.7 for HK1811 Motor, 10.0:10.0 for BX1306 Motor]

// Length of boom tube (to motor center, 5" prop: 85, 4" prop: 75) 
L_Arm = 85 ; // [60:120]

// Outer Radius of Boom Cylinder
R_Arm = 4.5 ; // [4.0:0.1:5.0]

// Wall thickness of boom tube
Wall_Arm = 0.9 ; // [0.7:0.1:1.2]

// Ovality factor of boom (H to W ratio in %)
Q_Arm   = 105 ; // [90:120]

// Chamfers at BX1306 motor fixing holes
Hole_chamfers = 1 ; // [0:No chamfers, 1:Chamfers]

// Wall thickness around rotor bell
Wall_Rotor = 1.2 ; // [0.9:0.1:1.5]

// Wall thickness at motor holder socket
Wall_Sockel = 1.5 ; 

/* [Leg dimensions] */
// Wideness of leg
 W_leg = 8.5 ; // [7.5:0.1:12]

// Material thickness of leg
H_leg = 3.2 ; // [2.5:0.1:4.0]

// Length extension of leg
 L_leg = 0 ;  // [0:15] 
 
// Use stop nuts or cut thread yourself
legeco = 0 ; // [1:Thread core hole, 0:M3 stop nut hole]

/* [Top cover  parameters] */
// Cover dome height
h_dome = 7; // [4:15]

// Dome cylinder radius
radome = 3.0 ; // [2:0.1:3.8]

// Border frame height
kragen = 1.5 ; // [1:0.1:3]

/* [Further internal parameters] */
// Height of chamfer below
H_Rotfase = 1 ;				
// Height of cone at lower side of motor holder
H_Rotkegel = 3 ;				
// Motor flange radius 1
R_hold1 = 4.5 ;				
// Motor flange radius 2
R_hold2 = 6 ;
// Motor flange height
H_hold = 8.8 ;				
// Lower flange outside radius (for stiff motor fixing)
R_Naussen = 5.2 ;
// Hole radius for "simple holder"
R_Nabe = 3.0 ;
// Position of M2.5 Motor fixing thread
MFix_z = 2.0 ; // [1.5:0.1:2.5]
// Radius cable channel inside boom
R_cable = 2.9;				
// Propeller Diameter (5"=127, 4"=102, 3"=76)
D_prop = 126 ; // [76:152]
// Hinge length
L_Hinge  = 20; // [18:22]		
// Hinge width
B_Hinge  = 14 ; // [12:16]	
// M3-Screw hole radius
R_Screw = 1.53 ;	 // [1.4:0.05:1.65]
// M3-Screw thread core hole
R_M3core = 1.2 ;
// axial length of chamfer hinge -> boom tube
H_HFase = 3.54 ;				
// axial backstand of internal bar in hinge
stegbak  = 1.0 ;				
// axial length of nose bar in hinge
stegovl  = 5 ;				
// Plate size reduction towards "mickey ears"
Quad_red = 11 ;	
// Thickness of lower frame plate
Quad_H = 1.6;	 // [1.3:0.1:2.0]
// Distance of Arm-End to Frame-Outline
Armbord = 18 ; // [15:18]
// Radius of Mickey Ears 
Quadmic_R = 18.0 ; // [17:20]
// Side walls thickness in lower frame
LowerWall = 1.4 ; // [1.0:0.1:2.0]
// Gap between lower side wall and upper frame
LowerSlot = 0.2 ;	 // [0.15:0.05:0.25]	
// Width of flight position stopper 
StopperWall = 1.6 ; // [1.3:0.1:2.0]
// Gap of flight position stopper to boom
StopperGap = 0.4 ; // [0.1:0.1:0.6]
// Height of storage position stopper 
Stopper_H = 3 ;  // [2.0:0.1:4.0]
// Height of strengthening X-dir bars around FC
QXbar_H = Dome_H*0.65 ; 
// Height of strengthening Y-dir bars around FC (w space for RX)
QYbar_H = 0.5 ;				
// Antenna hole radius
r_antenna = 1.2 ; // [1.2:0.1:1.5]

module arm_1811(support)
{
    // Hollow motor holder
    difference() {
       union() {
          translate ([0,0,H_Rotfase]) 
			cylinder (r=R_Rotor+Wall_Rotor, h=H_Rotor+Wall_Sockel-H_Rotfase, $fn=60) ;

	    // Cone below rotor bell
          translate ([0,0,-H_Rotkegel/2-H_Rotfase/2]) 
          		cylinder (r2=R_Rotor+Wall_Rotor, r1=R_Naussen, h=H_Rotkegel, $fn=40) ;

          // Flange tube holder with chamfer
          translate ([0,0,-H_hold]) cylinder (r1=R_Naussen, r2=R_Naussen+1, h=H_hold-H_Rotfase, $fn=40) ;
          translate ([0,0,-H_hold-1]) cylinder (r1=R_Naussen-1, r2=R_Naussen, h=1, $fn=40) ;

	    // Cylinder for flange fix screws
          translate ([0,0,-H_hold/2+MFix_z]) rotate ([90,0,0]) scale ([1.4,1,1]) cylinder (r=2.3, h=2*R_Naussen+3, $fn=20, center=true) ;  

          // Oval boom
          scale ([1,Q_Arm/100,1]) translate ([0,0,R_Arm]) rotate ([0,90,0]) cylinder (r=R_Arm, h=L_Arm, $fn=40) ;

          // Hinge block
          translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;

          // Chamfer between hinge and boom
          hull() {
             translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;
             scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge-H_HFase,0,R_Arm]) rotate ([0,90,0]) 
			cylinder (r=R_Arm, h=0.1, center=true, $fn=30) ;          
          }

	     // Cable tube below motor holder (outside)
         translate ([9.5,0,+0.2]) rotate ([0,-110,0]) scale ([1.1,1.33*Q_Arm/112,1]) cylinder (r = R_cable+0.9, h=24, $fn=40, center=true) ;
       }
      
       translate ([0,0,Wall_Sockel]) cylinder (r=R_Rotor, h=H_Rotor+0.05, $fn=40) ;			// Around rotor 
       translate ([0,0,-1.85]) cylinder (r2=R_Rotor, r1=R_Nabe-2, h=3.4, $fn=40) ;			// Below rotor, conic hole
       cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								// flange hole

       scale ([1,Q_Arm/100,1]) translate ([R_Rotor+Wall_Arm,0,R_Arm]) rotate ([0,90,0]) 			// boom tube hollow with end cap
			cylinder (r=R_Arm-Wall_Arm, h=L_Arm+0.1, $fn=30) ;

      // Cable tube at rotor, rotated part (inside)
      translate ([12.7,0,+0.0]) rotate ([0,-110,0]) scale ([0.72,1.2,1]) cylinder (r = R_cable, h=18, $fn=20, center=true) ;
	 // Cable tube, horizontal part
      translate ([6,0,-0.0]) rotate ([0,91,0]) scale ([0.8,1.3,1]) cylinder (r = 2.2, h=9.5, $fn=20, center=true) ;
      translate ([6.8,0,-0.6]) rotate ([0,91,0]) scale ([1.0,1.3,1]) cylinder (r = 2.2, h=6, $fn=20, center=true) ;

	// Hole for motor fixing screws M2.5
      translate ([0,0,-H_hold/2+MFix_z]) rotate ([90,0,0]) cylinder (r = 0.7, h=30, $fn=20, center=true) ;

	 // 50% wider hole in boom within hinge block, with chamfer
       hull() {
         scale ([1,1.50*Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2+stegbak,0,R_Arm]) rotate ([0,90,0])
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
         scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2-H_HFase/3-1.6,0,R_Arm]) rotate ([0,90,0]) 	
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
       }

       // M3 holes in hinge
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
    
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;

	 // 4 Chamfers at hinge block
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 2*R_Arm]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 2*R_Arm]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 0]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 0]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;    

       // Cylindrical cutout at hinge base for less cable movement when folding
       translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
    }

    // Vertical bar with screw holes in hinge block
   difference() { 
     hull() {
       translate ([L_Arm-L_Hinge/2+stegbak/2, 0, R_Arm]) cube ([L_Hinge-stegbak, 1+2*R_Screw, 2*R_Arm-0.5], center=true) ;
       translate ([L_Arm-L_Hinge/2-stegovl, 0, R_Arm]) cube ([L_Hinge, 0.5, 2*R_Arm-0.5], center=true) ;
     }

     // Again 4 M3 screw holes incl chamfers
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
  } 

  // Strengthening tube in motor dome (only possible together with support tube)
  if (support == 1) 
  {
    difference() { 
       union() {
         translate ([0,0,-1.5]) cylinder (r=R_Nabe+1.5, h=2, $fn=30) ;		    // Strenghtening tube
         translate ([0,0,-0.5]) cylinder (r1=R_Nabe+3, r2=R_Nabe+1.0, h=2, $fn=30) ;  // chamfer
       }
       cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								    // Flange hole
       translate ([R_Nabe+1.4,0,0]) scale ([1.3,0.95,1]) cylinder (r=R_cable, h=10, center=true, $fn=30) ;	            // Cable hole
    } // difference 

    // Support-tube in motor dome (can be broken away after print)
    difference() { 
        translate ([0,0,1]) cylinder (r=R_Nabe+0.8, h=H_Rotor+Wall_Sockel-1, $fn=30) ;	// Thin tube
        cylinder (r=R_Nabe+0.2, h=50, center=true, $fn=30) ;								        // Flange hole
        translate ([0,0,0.3]) rotate ([0,0,30]) cube ([10,2.5,4], center = true) ;				// 3 x 2 cutouts
	    translate ([0,0,0.3]) rotate ([0,0,90]) cube ([10,2.5,4], center = true) ;		
	    translate ([0,0,0.3]) rotate ([0,0,150]) cube ([10,2.5,4], center = true) ;
    } // difference

  } // if
}

module arm_bx1306()
{
    // Hollow Boom
    difference() {
       union() {
          translate ([0,0,H_Rotfase]) 
			 cylinder (r=R_Rotor+Wall_Rotor, h=H_Rotor+Wall_Sockel-H_Rotfase, $fn=60) ;
          translate ([0,0,H_Rotfase+H_Rotor+0.5]) 
			 cylinder (r1=R_Rotor+Wall_Rotor, r2=R_Rotor+Wall_Rotor-0.6, h=0.6, $fn=60) ;
          cylinder (r1=R_Rotor+Wall_Rotor-H_Rotfase, r2=R_Rotor+Wall_Rotor, h=H_Rotfase, $fn=50) ;
 
          // Strengthening fin between boom and motor dome
          hull() {
              translate ([R_Rotor,0,H_Rotor+1]) rotate ([0,90+36,0]) cylinder (r=0.8, h=10, $fn=10) ;
              translate ([R_Rotor,0,3]) rotate ([0,90,0]) cylinder (r=1.5, h=10, $fn=10) ;
          }
           
          // Oval boom tube
         scale ([1,Q_Arm/100,1]) translate ([0,0,R_Arm]) rotate ([0,90,0]) cylinder (r=R_Arm, h=L_Arm, $fn=40) ;

          // Hinge block
          translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;

          // Chamfer between hinge and boom
          hull() {
             translate ([L_Arm-L_Hinge/2, 0, R_Arm]) cube ([L_Hinge, B_Hinge, 2*R_Arm], center=true) ;
             scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge-H_HFase,0,R_Arm]) rotate ([0,90,0]) 
			cylinder (r=R_Arm, h=0.1, center=true, $fn=30) ;          
          } // hull
       } // union
      
       translate ([0,0,Wall_Sockel]) cylinder (r=R_Rotor, h=H_Rotor+1.01, $fn=30) ;		// rotor hole
       translate ([0,0,0.5]) cylinder (r=5.5/2, h=2, $fn=30) ;	                                    // center groove
       scale ([1,Q_Arm/100,1]) translate ([8,0,R_Arm]) rotate ([0,90,0]) 						    // tube boom hole
			cylinder (r=R_Arm-Wall_Arm, h=L_Arm+0.1, $fn=30) ;
       scale ([1,Q_Arm/100,1]) translate ([8-6+0.1,0,R_Arm]) rotate ([0,90,0]) 					// tube boom hole
			cylinder (r2=R_Arm-Wall_Arm, r1=R_Arm-Wall_Arm-1.5, h=6, $fn=30) ;

       // 4 holes in boom bottom for fixing screws, with optional chamfers
       for (i= [0:3]) {
           assign (rot = i*90) rotate ([0,0,45+rot]) 
           {
             translate ([12/2, 0, -1]) cylinder (r=2.3/2, h=10, $fn=20) ;                         // hole
             if (Hole_chamfers == 1)
                 translate ([12/2, 0, -0.1]) cylinder (r2=2.3/2, r1=2.3/2+1, h=1, $fn=20) ;     // chamfer
           } // rotate
       } // for

	 // 50% wider hole in hinge block
       hull() {
         scale ([1,1.50*Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2+stegbak,0,R_Arm]) rotate ([0,90,0])
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
         scale ([1,Q_Arm/100,1]) translate ([L_Arm-L_Hinge/2-H_HFase/3,0,R_Arm]) rotate ([0,90,0]) 	
			cylinder (r=R_Arm-Wall_Arm, h=L_Hinge, center=true, $fn=30) ;
       }

       // M3 holes
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

       // M3 chamfers
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
       translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;

	 // 4 Hinge chamfers
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 2*R_Arm]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 2*R_Arm]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, B_Hinge/2, 0]) rotate ([45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       translate ([L_Arm-L_Hinge/2, -B_Hinge/2, 0]) rotate ([-45,0,0]) cube ([2*L_Hinge, B_Hinge/2, 1], center=true) ;
       
       // Cylindrical cutout at hinge base for less cable movement when folding
       translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
    }

    // Vertical bar in hinge block
   difference() { 
     hull() {
       translate ([L_Arm-L_Hinge/2+stegbak/2, 0, R_Arm]) cube ([L_Hinge-stegbak, 1+2*R_Screw, 2*R_Arm-0.5], center=true) ;
       translate ([L_Arm-L_Hinge/2-stegovl, 0, R_Arm]) cube ([L_Hinge, 0.5, 2*R_Arm-0.5], center=true) ;
     }

     // Again M3 holes incl chamfers
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,R_Arm]) cylinder (r=R_Screw, h=30, center=true, $fn=20) ;

     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,2*R_Arm]) cylinder (r1=R_Screw, r2=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     translate ([L_Arm-L_Hinge/2-L_Hinge/3+12,0,0]) cylinder (r2=R_Screw, r1=R_Screw+1, h=1, center=true, $fn=20) ;
     
       // Again cylindrical cutout at hinge base for less cable movement
      translate ([L_Arm+1.2*R_Arm-1.6,0,R_Arm]) rotate ([90,0,0])
           cylinder (r=1.2*R_Arm, h=20, center=true, $fn=40) ;
  }
}

module boom()
{
   if (motor_type == "hk1811sup") arm_1811(1) ;
   if (motor_type == "hk1811") arm_1811(0) ;
   if (motor_type == "bx1306") arm_bx1306() ;
}

module armslots(startw, endw)
{
      cylinder (r=R_Screw, h=20, center=true, $fn=20) ;									// anchor point
   
      for (angle = [startw : 10 : endw-10])												// Long hole
      {
          hull() {
             rotate ([0,0,angle]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
             rotate ([0,0,angle+10]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
          }
      }

      hull() {																			// Rest in long hole...
          rotate ([0,0,endw]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
          rotate ([0,0,endw-10]) translate ([0,12,0]) cylinder (r=R_Screw, h=10, center=true, $fn=20) ;
      }
}

module roundcube (x, y, z, rad)
{
    hull() {
      translate ([-x/2+rad, -y/2+rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([-x/2+rad, y/2-rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([x/2-rad, -y/2+rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
      translate ([x/2-rad, y/2-rad, 0]) cylinder (r=rad,h=z, center=true, $fn=30) ;
    }
}

module frame_basis()
{
    difference()
    {
        union()
        {
             cube ([Quad_L-Quad_red, Quad_B-Quad_red, Quad_H], center=true) ;
             translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
             translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=Quad_H, center=true, $fn=50) ;
         } // union
         
         // 4 slot footprints for the arms
         translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) rotate ([0,0,-90]) armslots (0, Quad_W) ;
         translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) rotate ([0,0,90-Quad_W]) armslots (0, Quad_W) ;
          translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) rotate ([0,0,-90-Quad_W]) armslots (0, Quad_W) ;
         translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) rotate ([0,0,90]) armslots (0, Quad_W) ;
   } // diff
}

module frame_lower()
{
    difference ()
    {
      frame_basis() ;

	 // Cooling / weight reduction holes in the middle under the ESC's
      hull() {
          translate ([ 45/2-16, Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }

      translate ([24,0,0]) cylinder (r=7, h=10, $fn=20, center=true) ;			// weight red holes between arms
      translate ([-24,0,0]) cylinder (r=7, h=10, $fn=20, center=true) ;
    }

   // Battery rubber bolts with 2 sided chamfers
   translate ([20,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r=1.5, h=9, $fn=20, center=true);
   translate ([20+9/2+1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r1=1.5, r2=0.8, h=1.4, $fn=20, center=true);
   translate ([20-9/2-1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r2=1.5, r1=0.8, h=1.4, $fn=20, center=true);
   translate ([-20,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r=1.5, h=9, $fn=20, center=true);
   translate ([-20+9/2+1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r1=1.5, r2=0.8, h=1.4, $fn=20, center=true);
   translate ([-20-9/2-1.4/2,0,1.5/2]) rotate ([0,90,0]) scale ([1,1.6,1]) cylinder (r2=1.5, r1=0.8, h=1.4, $fn=20, center=true);

   // Side walls 
   difference ()
   {
     union()
     {
         translate ([0,(Quad_B-Quad_red-LowerWall)/2, Quad_H/2+R_Arm-LowerSlot/2]) 
            cube ([Quad_L-36, LowerWall, 2*R_Arm-LowerSlot], center=true) ;
        translate ([0,-(Quad_B-Quad_red-LowerWall)/2, Quad_H/2+R_Arm-LowerSlot/2]) 
            cube ([Quad_L-36, LowerWall, 2*R_Arm-LowerSlot], center=true) ;
     }

    // Subtract Arms stopper plates for flight position
    translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-180+Quad_W]) translate ([-9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-Quad_W]) translate ([9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,+Quad_W]) translate ([-9, -B_Hinge/2+10-StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
    translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
     rotate ([0,0,-Quad_W]) translate ([-9, B_Hinge/2-10+StopperGap, 0])
     	 cube ([13, 20, 2*R_Arm], center=true) ;
   }

   // Flight position Stopper blades cylindrical fill?
   // Create these as intersection of mickey ears with stopper blade hull of one side
   if (StopperFill > 0)
   {
       clen = 12.5 - (Quad_W - 55)/10 ;      // correction of stopper length

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-180+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
                translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-Quad_W]) translate ([-15, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // difference
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-180+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
                translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                rotate ([0,0,-Quad_W]) translate ([-15, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	            cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,-Quad_W]) translate ([15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection

       intersection() {
           hull() {
              translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,-Quad_W]) translate ([15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
                 rotate ([0,0,+Quad_W]) translate ([-15, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	             cube ([clen, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
           } // hull
           difference () {
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R, h=20, center=true, $fn=50) ;
              translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, 0]) cylinder (r=Quadmic_R-LowerWall, h=20, center=true, $fn=50) ;
           } // diff
       } // intersection
   } // if 

    // Big wall in the middle with extension to the battery rubber bolts
   translate ([0,0, Quad_H/2]) rotate ([45, 0, 0]) cube ([40, 1.8, 1.8], center=true) ;	// socket chamfer
    hull () {
       translate ([0,0, Quad_H/2+R_Arm-LowerSlot/2]) cube ([22, 1.1, 2*R_Arm-LowerSlot], center=true) ;
       translate ([0,0, Quad_H/2+3/2]) cube ([40, 1.4, 2], center=true) ;
    }

   // Two lower inner walls / bars only for ESC fixation
  translate ([0,Quad_B/4.8, Quad_H/2]) rotate ([45, 0, 0]) cube ([30, 1.8, 1.8], center=true) ;	// socket chamfer
   hull () {
      translate ([0,Quad_B/4.8, Quad_H/2+2/2]) cube ([30, 1.3, 2], center=true) ;
      translate ([0,Quad_B/4.8, Quad_H/2+R_Arm]) cube ([22, 1.2, 1.3*R_Arm], center=true) ;
   }
  translate ([0,-Quad_B/4.8, Quad_H/2]) rotate ([45, 0, 0]) cube ([30, 1.8, 1.8], center=true) ;	// socket chamfer
   hull () {
      translate ([0,-Quad_B/4.8, Quad_H/2+2/2]) cube ([30, 1.4, 2], center=true) ;
      translate ([0,-Quad_B/4.8, Quad_H/2+R_Arm]) cube ([22, 1.2, 1.3*R_Arm], center=true) ;
   }

  // Arms stopper plates for flight position, if not replaced by cylindrical fill
//  if (StopperFill < 2)
  {
    translate ([Quad_L/2-Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-180+Quad_W]) translate ([-11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([-Quad_L/2+Armbord, Quad_B/2-Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-Quad_W]) translate ([-11, B_Hinge/2+StopperWall/2+StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([Quad_L/2-Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,-Quad_W]) translate ([11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
    translate ([-Quad_L/2+Armbord, -Quad_B/2+Armbord, Quad_H/2+R_Arm-LowerSlot/2]) 
      rotate ([0,0,+Quad_W]) translate ([-11, -B_Hinge/2-StopperWall/2-StopperGap, 0])
     	 cube ([9, StopperWall, 2*R_Arm-LowerSlot], center=true) ;
   }
      
   // Arm stopper bars for storage position
   translate ([Quad_L/2-6,Quad_B/2-Armbord-B_Hinge/2-LowerWall, Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([Quad_L/2-6,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall), Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([-Quad_L/2+6,Quad_B/2-Armbord-B_Hinge/2-LowerWall, Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ; 
   translate ([-Quad_L/2+6,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall), Stopper_H/2]) 
		cube ([6, LowerWall, Stopper_H], center=true) ;  
}
module frame_upper_45x45()
{
    difference ()
    {
      frame_basis() ;

	 // Weight reduction holes in the middle
      hull() {
          translate ([ 45/2-12, 45/2-10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
          translate ([-45/2+12,45/2-10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-12, -45/2+10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
          translate ([-45/2+12,-45/2+10, 0]) cylinder (r=8, h=20, center=true, $fn=25) ;
      }
      
      // Holes for M3 threads
      translate ([+22.5,+22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([+22.5,-22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([-22.5,+22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;
      translate ([-22.5,-22.5,0]) cylinder (r=R_M3core, h=20, $fn=20, center=true) ;	
    } // difference

    // Holder for FC footprint 45x45 (e.g. Crius AIO V2)
   difference() {
      union() {
        translate ([+22.5,+22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;		// Domes for M3 screws
        translate ([+22.5,-22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;
        translate ([-22.5,+22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;
        translate ([-22.5,-22.5,0]) cylinder (r1=3.2, r2=2.5, h=Dome_H, $fn=20) ;

        translate ([+22.5-2.5,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 45, QYbar_H], center=true) ;   // Bars betw FC domes
	    translate ([-22.5+2.5,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 45, QYbar_H], center=true) ;
	    translate ([0,+22.5,     Quad_H/2+QXbar_H/2]) cube ([45, 1.5, QXbar_H], center=true) ;
 	    translate ([0,-22.5,     Quad_H/2+QXbar_H/2]) cube ([45, 1.5, QXbar_H], center=true) ;
      }

      translate ([+22.5,+22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;				// Dome holes for M3 threads
      translate ([+22.5,-22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-22.5,+22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-22.5,-22.5,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;	
   }
}

module frame_upper_blanco()
{
    frame_basis() ;
}


module frame_upper_31x31()
{
    difference ()
    {
      frame_basis() ;

	  // Holes for M3 threads
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.2, h=30, $fn=20, center=true) ;	           

	// Cooling / weight reduction holes in the middle under the ESC's
      hull() {
          translate ([ 45/2-16, Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/9, 0]) cylinder (r=4.5, h=15, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/9, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, -Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,-Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }
      hull() {
          translate ([ 45/2-16, Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
          translate ([-45/2+16,Quad_B/3.2, 0]) cylinder (r=4.5, h=20, center=true, $fn=25) ;
      }

      translate ([25,0,0]) cylinder (r=6, h=10, $fn=30, center=true) ;			// weight red holes between arms
      translate ([-25,0,0]) cylinder (r=6, h=10, $fn=30, center=true) ;     
    } // difference

    // Holder for FC footprint 30.5x30.5 (e.g. Naze32)
   difference() {
      union() {
        translate ([+30.5/2,+30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;		// Domes for M3 screws
        translate ([+30.5/2,-30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;
        translate ([-30.5/2,+30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;
        translate ([-30.5/2,-30.5/2,0]) cylinder (r1=3.4, r2=2.6, h=Dome_H, $fn=20) ;

	    translate ([+30.5/2,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 30.5, QYbar_H], center=true) ;   // Bars betw FC domes
	    translate ([-30.5/2,0,Quad_H/2+QYbar_H/2]) cube ([1.5, 30.5, QYbar_H], center=true) ;
 	    translate ([0,+30.5/2-1,Quad_H/2+QXbar_H/2]) cube ([30.5, 1.5, QXbar_H], center=true) ;
 	    translate ([0,-30.5/2+1, Quad_H/2+QXbar_H/2]) cube ([30.5, 1.5, QXbar_H], center=true) ;
      } // union
      
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;		// Holes for M3 threads
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.2, h=20, $fn=20, center=true) ;	           
   } // difference
}

module frame_upper ()
{
    if (FC_footprint == "31x31") frame_upper_31x31() ;
    if (FC_footprint == "45x45") frame_upper_45x45() ;
    if (FC_footprint == "none")  frame_upper_blanco() ;
        
    // Jeti RSAT antenna holder on top
    if (ant_holder == 1) translate ([-35,0,Quad_H/2+2.5]) antenna_holder() ;
}

module cover_dome(foot)
{
   // Holder for FC footprint
   difference() {
      union() {
        translate ([0,0,h_dome]) hull() {
            translate ([+foot/2,+foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		// Top plate = Round cube
            translate ([+foot/2,-foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
            translate ([-foot/2,+foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
            translate ([-foot/2,-foot/2,0]) cylinder (r=radome, h=1.2, $fn=20) ;		
        } // hull
        translate ([+foot/2,+foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;		// Domes for M3 screws
        translate ([+foot/2,-foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;
        translate ([-foot/2,+foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;
        translate ([-foot/2,-foot/2,0]) cylinder (r=radome, h=h_dome, $fn=20) ;

        translate ([0,+foot/2+radome-1.2/2,h_dome-1.2/2]) cube ([foot, 1.2, kragen], center=true) ;	// Small side wall
        translate ([0,-foot/2-radome+1.2/2,h_dome-1.2/2]) cube ([foot, 1.2, kragen], center=true) ;	
        translate ([+foot/2+radome-1.2/2,0,h_dome-1.2/2]) cube ([1.2,foot, kragen], center=true) ;	
        translate ([-foot/2-radome+1.2/2,0,h_dome-1.2/2]) cube ([1.2,foot, kragen], center=true) ;	
      } // union
      
      translate ([+foot/2,+foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;		// Holes for M3 bolts
      translate ([+foot/2,-foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-foot/2,+foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-foot/2,-foot/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;	           
   } // difference
}

module dome()
{
   if (FC_footprint == "31x31") cover_dome (30.5) ;
   if (FC_footprint == "45x45") cover_dome (45) ;
}

module spacers_31x31()
{
   h_spc = 2.5;
   kragen = 1.0 ;
    
   // Holder for FC footprint 30.5x30.5 (e.g. Naze32)
   difference() {
      union() {
        translate ([+30.5/2,+30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;		// Domes for M3 screws
        translate ([+30.5/2,-30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;
        translate ([-30.5/2,+30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;
        translate ([-30.5/2,-30.5/2,0]) cylinder (r=2.8, h=h_spc, $fn=20) ;

        translate ([0,+30.5/2+2.8-1.2/2,h_spc-1.2/2]) cube ([30.5, 1.2, kragen], center=true) ;	// Small side wall
        translate ([0,-30.5/2-2.8+1.2/2,h_spc-1.2/2]) cube ([30.5, 1.2, kragen], center=true) ;	
        translate ([+30.5/2+2.8-1.2/2,0,h_spc-1.2/2]) cube ([1.2,30.5, kragen], center=true) ;	
        translate ([-30.5/2-2.8+1.2/2,0,h_spc-1.2/2]) cube ([1.2,30.5, kragen], center=true) ;	
      } // union
      
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;		// Holes for M3 bolts
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=1.7, h=30, $fn=20, center=true) ;	           
   } // difference
}

module leg()
{
   translate ([L_Arm-L_Hinge/2,0,-Quad_H-H_leg/2]) rotate ([0, 180, 90]) difference() {
      union() {
         hull() {
	      translate ([0,-7,0]) cylinder (r=W_leg/2, h=H_leg, center=true, $fn=30) ;
	      translate ([0,2,0]) cube ([W_leg, 14, H_leg], center=true) ;
	      translate ([0,2,H_leg/2]) rotate ([6,0,0]) cube ([W_leg, 18, 0.1], center=true) ;
	   }
         hull() {
	      translate ([0,9,0]) rotate ([0,90,0]) cylinder (r=H_leg/2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,4,0]) rotate ([0,90,0]) cylinder (r=H_leg/2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,11,1]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,11,1]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	      translate ([0,10,0.7]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,13,2.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,13,2.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.3, h=W_leg, center=true, $fn=20) ;
	      translate ([0,15,4.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,15,4.5]) rotate ([0,90,0]) cylinder (r=H_leg/2+0.2, h=W_leg, center=true, $fn=20) ;
	      translate ([0,17,7]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.0, h=W_leg, center=true, $fn=20) ;
	   }
         hull() {
	      translate ([0,17,7]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.0, h=W_leg, center=true, $fn=20) ;
	      translate ([0,22+0.9*L_leg,14+L_leg]) rotate ([0,90,0]) cylinder (r=H_leg/2-0.2, h=W_leg, center=true, $fn=20) ;
	   }

       // Thread threngthening cylinders for ECO, to drill M3 yourself
       if (legeco == 1) {
          translate ([0,-6,2.5]) cylinder (r2=2.4, r1=4.0, h=5, center=true, $fn=20) ;		
          translate ([0,6,2.5]) cylinder (r2=2.4, r1=4.0, h=5, center=true, $fn=20) ;		
       } // if
      } // union

      // Create M3 through holes with stop nut   OR   M3 core thread hole w/o nut
      if (legeco == 1) {
        translate ([0,-6,0]) cylinder (r=1.2, h=20, center=true, $fn=20) ;		// M3 thread core
        translate ([0,6,0]) cylinder (r=1.2, h=20, center=true, $fn=20) ;		// M3 thread core 
      }
      else {    
        translate ([0,-6,0]) cylinder (r=1.6, h=20, center=true, $fn=20) ;		// M3 screw whole
        translate ([0,-6,2]) cylinder (r=6.5/2, h=5, center=true, $fn=6) ;   	// stop nut hole
        translate ([0,6,0]) cylinder (r=1.6, h=20, center=true, $fn=20) ;		// M3 screw whole
        translate ([0,6,2]) cylinder (r=6.5/2, h=5, center=true, $fn=6) ;     	// stop nut hole
      } // else
   }
}

module motor_1811()
{
   translate ([0,0,0-9.5])   cylinder (r=1, h=30, $fn=10) ;						// Shaft
   translate ([0,0,1.5-9.5]) cylinder (r=3, h=10, $fn=20) ;						// Stator flange
   translate ([0,0,11-9.5]) cylinder (r=17.5/2, h=7.5, $fn=30) ;					// Rotor bell
   translate ([0,0,16.5-9.5]) cylinder (r=5/2, h=5, $fn=20) ;					// Rotor adaptor
   translate ([0,-2,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 1
   translate ([0, 0,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 2
   translate ([0,+2,9.2-9.5]) rotate ([0,90,0]) cylinder (r=0.8, h=20, $fn=10) ;	// Wire 3 
}


module prop_5x3()
{
   translate ([0,0,12.2]) cylinder (r=3, h=6.5, $fn=15) ;						// Flange
   translate ([0,0,15.2]) cylinder (r=D_prop/2, h=1, $fn=30) ;				// Props
}

module plush_6a()
{
   cube ([25.5, 12, 1.3], center=true) ;										// PCB
   translate ([-5,0,3.5]) rotate ([0,90,0]) cylinder (r=2.6, h=12, $fn=15) ;		// Elko
}

module fc_45x45()
{
   difference() {
      cube ([55, 52, 1.6], center=true) ;										// PCB
      translate ([+22.5,+22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;				// Hole for M3 screw
      translate ([+22.5,-22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-22.5,+22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-22.5,-22.5,0]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}

module fc_31x31()
{
   difference() {
      cube ([35, 35, 1.6], center=true) ;										// PCB
      translate ([+30.5/2,+30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;			// Hole for M3 screw
      translate ([+30.5/2,-30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,+30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,-30.5/2,0]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}


module fc()
{
    if (FC_footprint == "31x31") fc_31x31() ;
    if (FC_footprint == "45x45") fc_45x45() ;
}

module fc_flip32mini()
{
   frame = 0.3 ;                                                                            // border around Flip32mini PCB
   mpcb_x = 15.0 ;                                                                        // Flip32 mini PCB dimensions
   mpcb_y = 31.7 ; 

   difference() {
      union() {
         roundcube (36, 36, 1.2, 2) ;										            // instead Naze32 PCB
         translate ([0,0,1]) roundcube (17, 33, 2, 1.5) ;			            // socket for Flip32 mini
      }
      translate ([0,0,1.8]) roundcube (mpcb_x, mpcb_y, 2, 0.5) ;			// PCB cutout for Flip32 mini 
      translate ([0,0,-1]) roundcube (mpcb_x-2*frame, mpcb_y-2*frame, 10, 1.0) ; // hole below PCB

      translate ([+30.5/2,+30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;		// Holes for M3 screw
      translate ([+30.5/2,-30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,+30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;
      translate ([-30.5/2,-30.5/2,-1]) cylinder (r=R_Screw, h=2, $fn=20) ;	
  }
}

module jeti_rsat()
{
      cube ([19, 35, 3], center=true) ;										    // PCB
      // Straight antennas
//      translate ([4, 35/2,0]) rotate ([0,90,60]) cylinder (r=0.7, h=72, $fn=10) ;	            // Antenna 1
//      translate ([-4,35/2,0]) rotate ([0,90,120]) cylinder (r=0.7, h=72, $fn=10) ;            // Antenna 2

      // Bent for antenna holder
      translate ([4, 35/2+14,0]) rotate ([90,0,0]) cylinder (r=0.7, h=14, $fn=10) ;	         // Antenna 1
      translate ([4, 35/2+14,0]) rotate ([0,96,62]) cylinder (r=0.7, h=40, $fn=10) ;

      translate ([-4,35/2+14,0]) rotate ([90,0,0]) cylinder (r=0.7, h=14, $fn=10) ;            // Antenna 2
      translate ([-4,35/2+14,0]) rotate ([0,96,118]) cylinder (r=0.7, h=40, $fn=10) ;
}

module antenna_holder()
{
   difference() {
      hull() {                                                                                             // Fixing Block
          translate ([0,0,-2.2]) cube ([5, 24, 1], center=true) ;
          translate ([0,0,2.2]) cube ([5, 16, 0.1], center=true) ;
       }
      translate ([0,-6,0]) rotate ([0,80,25]) cylinder (r=r_antenna, h=20, $fn=10, center=true) ;   // Antenna 1
      translate ([0,6,0]) rotate ([0,80,-25]) cylinder (r=r_antenna, h=20, $fn=10, center=true) ;   // Antenna 2
       
      hull() {                                                                                          // Weight Reduction
         translate ([0,-3,0]) cylinder (r=1.5, h=20, $fn=20, center=true) ;  
         translate ([0,3,0]) cylinder (r=1.5, h=20, $fn=20, center=true) ;  
      }
   }
}

module neopixel_holder()
{
   difference() {
     translate ([0,0,0]) cube ([4, (Quad_B-Armbord-B_Hinge)/2-1, 2*R_Arm], center=true) ;
    
     // Holes for arm stopper bars in storage position
     translate ([0,Quad_B/2-Armbord-B_Hinge/2-LowerWall-0.2, -R_Arm+Stopper_H/2]) 
	  	 cube ([6, LowerWall, Stopper_H], center=true) ; 
     translate ([0,-(Quad_B/2-Armbord-B_Hinge/2-LowerWall-0.2), -R_Arm+Stopper_H/2]) 
		  cube ([6, LowerWall, Stopper_H], center=true) ;  

     // Rect 5x5mm holes for 2 LEDs
      translate ([-1,-3.8,0]) cube ([2.5, 5, 5], center=true) ;   // Front Frame for LED 1
      translate ([-1,3.8,0])  cube ([2.5, 5, 5], center=true) ;   // for LED 2

      translate ([-0.6,-3.8,0]) cube ([2.0, 5.5, 5.5], center=true) ;   // LED 1
      translate ([-0.6,3.8,0])  cube ([2.0, 5.5, 5.5], center=true) ;   // LED 2

     // Holes for wiring inlay
     hull() {
       translate ([0.5,0,1]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20,center=true) ;
       translate ([0.5,0,2.5]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20,center=true) ;
       translate ([0.5,0,-2.5]) rotate ([90,0,0]) cylinder (r=0.9, h=14, $fn=20, center=true) ;
     }
      hull() {
        translate ([0.5,-6.5,2.5]) rotate ([90,0,0]) cylinder (r=0.6, h=3, $fn=20,center=true) ;
        translate ([0.5,-6.5,0]) rotate ([90,0,0]) cylinder (r=0.6, h=3, $fn=20,center=true) ;
      } // hull

      // Cable outlet at backside
      hull() {
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+1.2,2.5]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+1.2,0]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+0.5,2.5]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
        translate ([1,-(Quad_B-Armbord-B_Hinge)/4+0.5,0]) rotate ([90,0,90]) cylinder (r=0.8, h=3.1, $fn=20,center=true) ;
      } // hull
   } // difference
}

module quadro(angle)
{
  frame_lower() ;
  translate ([0,0,2*R_Arm+1.6]) frame_upper() ;

  translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) { boom() ; leg(); }
  translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) { boom() ; leg(); }
  translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0]) {  boom() ; leg(); }
  translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0])  { boom() ; leg(); }

   if (top_cover == 1) translate ([0,0,Dome_H+2*R_Arm+1.6]) dome() ;
   
   // If selected, show electronic components as ghosts
   if (ghosts == 1)
   {
      // Motors and props 
      translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0])  { %motor_1811() ; %prop_5x3() ; }
      translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0])  {%motor_1811() ; %prop_5x3() ; }
      translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0])  {%motor_1811() ; %prop_5x3() ; }
      translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0])  {%motor_1811() ; %prop_5x3(); }

      // 4 ESCs PLUSH 6A between the frames
      %translate ([1,20.5,3]) rotate ([0,0,180]) plush_6a() ;
      %translate ([2, 7,3]) rotate ([0,0,0]) plush_6a() ;
      %translate ([2,-7,3]) rotate ([0,0,0]) plush_6a() ;
      %translate ([1,-20.5,3]) rotate ([0,0,180]) plush_6a() ;

     // Jeti Duplex RMK receiver sandwiched below FC
     %translate ([0,0,14]) rotate ([0,0,90]) jeti_rsat() ;

     // Flight Controller on top
     %translate ([0,0,11.5+Dome_H]) fc() ;
   } // if 
}

module quadro_exploded(angle)
{
  translate ([0,0,-60]) frame_lower() ;
  translate ([0,0,2*R_Arm]) frame_upper() ;

  translate ([Quad_L/2-Armbord-0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-180+angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) 
	  { translate ([0,0,-20])  boom() ; if (ghosts == 1) %motor_1811() ; translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([-Quad_L/2+Armbord+0.7, Quad_B/2-Armbord-0.7, Quad_H/2]) rotate ([0,0,-angle]) translate ([-L_Arm+L_Hinge/6, 0, 0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;   translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([Quad_L/2-Armbord-0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,180-angle]) translate ([-L_Arm+L_Hinge/6,0, 0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;   translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }
  translate ([-Quad_L/2+Armbord+0.7, -Quad_B/2+Armbord+0.7, Quad_H/2]) rotate ([0,0,angle]) translate ([-L_Arm+L_Hinge/6,0,0]) 
	  { translate ([0,0,-20]) boom() ; if (ghosts == 1) %motor_1811() ;  translate ([0,0,20]) if (ghosts == 1) %prop_5x3() ; translate ([0,0,-80]) leg(); }

   if (top_cover == 1) translate ([0,0,45]) dome() ;

   if (ghosts == 1)
   {
       // 4 ESCs PLUSH 6A between the frames
       %translate ([1,20.5,3 -40]) rotate ([0,0,180]) plush_6a() ;
       %translate ([2, 7,3    -40]) rotate ([0,0,0]) plush_6a() ;
       %translate ([2,-7,3   -40]) rotate ([0,0,0]) plush_6a() ;
       %translate ([1,-20.5,3-40]) rotate ([0,0,180]) plush_6a() ;

       // Jeti Duplex RMK receiver sandwiched below FC
       %translate ([0,0,14+10]) rotate ([0,0,90]) jeti_rsat() ;
 
      // Flight Controller on top
      %translate ([0,0, 15+20]) fc() ;
   } // if
}



if (show == "all") quadro (Quad_W) ;            // 0 = booms in park / Quad_W = in flight
if (show == "exp") quadro_exploded (Quad_W) ;	   // optional: exploded view
if (show == "leg") leg() ;
if (show == "ant") translate ([-35,0,13.5]) antenna_holder() ;         // Jeti RSAT antenna holder
if (show == "neo") translate ([Quad_L/2-8,0,R_Arm]) rotate ([0,0,180]) neopixel_holder() ;
if (show == "boom") boom();
if (show == "bot") frame_lower();
if (show == "top") frame_upper();
if (show == "cov") translate ([0,0,Dome_H+8]) dome();
if (show == "debug") quadro_debug (Quad_W) ;
                ```
                

                Example ID: modular_b66f5e5e
                Score: 0.654
                Description: A design of the frame for a micro fpv drone
                Code:
                ```scad
                module motorHolders(x, diameter, height) {
  motorHolder(x, x, diameter, height); 
  motorHolder(-x, x, diameter, height); 
  motorHolder(x, -x, diameter, height); 
  motorHolder(-x, -x, diameter, height); 
}

module motorHoles(x, diameter, height) {
  motorHole(x, x, diameter, height); 
  motorHole(x, -x, diameter, height); 
  motorHole(-x, x, diameter, height); 
  motorHole(-x, -x, diameter, height); 
}

module motorHolder(x, y, motorDiameter, height = 3) {
  motorRadius = motorDiameter / 2;
  translate([x, y, 0])
  linear_extrude(height)
  circle(motorRadius + 2);
}

module motorHole(x, y, motorDiameter, height = 3) {
  motorRadius = motorDiameter / 2;
  translate([x, y, -1])
  linear_extrude(height + 2)
  circle(motorRadius);
}


module sides(x, sideOffset, h) {
  sideTB(x, sideOffset, 1, h);
  sideTB(x, sideOffset, -1, h);
  sideLR(x, sideOffset, 1, h);
  sideLR(x, sideOffset, -1, h);
}

module sideLR(x, sideOffset, dir, h) {
  p0=[dir * x, x - sideOffset];
  p1=[dir * sideOffset, 0];
  p2=[dir * x, -x + sideOffset];
  linear_extrude(h)
  BezConic( p0, p1, p2, steps=20);
}

module sideTB(x, sideOffset, dir, h) {
  p0=[x - sideOffset, dir * x];
  p1=[0, dir * sideOffset];
  p2=[-x + sideOffset, dir * x];
  linear_extrude(h)
  BezConic( p0, p1, p2, steps=20);
}

module cross(x, sideOffset, dir, h) {
  p0 = [dir * x, x - sideOffset];
  p1 = [dir * (x - sideOffset), x];
  p2 = [dir * -x, -x + sideOffset];
  p3 = [dir * (-x + sideOffset), -x];

  linear_extrude(h)
  polygon([p0, p1, p2, p3]);
}

module centerHole(h) {
  union() {
    translate([-10, -6, -1])
    cube([20, 12, h + 2]);
    translate([-8, -(23.5 / 2) + 1, -1])
    cube([16, 22.5, h + 2]);

    translate([-8, -(23.5 / 2) - 8, -1])
    cube([16, 8, h + 2]);
  }
}

module strapHoles(h) {
  union() {

    translate([-22, 10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([22, 10, -1])
    cylinder(r = 2, h = h + 3);  
  
    translate([-22, -10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([22, -10, -1])
    cylinder(r = 2, h = h + 3);  

    translate([-24, 9.5, -1])
    cylinder(r = 1, h = h + 3);  

    translate([24, 9.5, -1])
    cylinder(r = 1, h = h + 3);  
  
    translate([-24, -9.5, -1])
    cylinder(r = 1, h = h + 3);  

    translate([24, -9.5, -1])
    cylinder(r = 1, h = h + 3);  


  }
}

module BezConic(p0,p1,p2,steps=5) {

	stepsize1 = (p1-p0)/steps;
	stepsize2 = (p2-p1)/steps;

	for (i=[0:steps-1]) {
		assign(point1 = p0+stepsize1*i) 
		assign(point2 = p1+stepsize2*i) 
		assign(point3 = p0+stepsize1*(i+1))
		assign(point4 = p1+stepsize2*(i+1))  {
			assign( bpoint1 = point1+(point2-point1)*(i/steps) )
			assign( bpoint2 = point3+(point4-point3)*((i+1)/steps) ) {
				polygon(points=[bpoint1,bpoint2,p1]);
			}
		}
	}
}

$fn = 30;

motorDistance = 120; // motor to motor distance
motorDiameter = 8.8; // hole size for 8.5mm motor
sideOffset = 3;

motorHolderHeight = 4;
crossHeight = 2;
sideHeight = 2;

x = sqrt(pow(motorDistance / 2, 2) * 2) / 2;

difference() {

  mainBody();

  motorHoles(x, motorDiameter, motorHolderHeight);
  centerHole(crossHeight);

  strapHoles(crossHeight);
}

module mainBody() {

  // motors
  motorHolders(x, motorDiameter, motorHolderHeight); 

  // cross beams
  cross(x, sideOffset, 1, crossHeight);
  cross(x, sideOffset, -1, crossHeight);

  // curved sides
  sides(x, sideOffset, sideHeight);
  
  boardMount(sideHeight);
}

module boardMount(h) {

  union() {
    translate([-12, (23.5 / 2), 0])
    cube([4, 2, h + 2]);

    translate([8, (23.5 / 2), 0])
    cube([4, 2, h + 2]);

    translate([-12, -(23.5 / 2), 0])
    cube([2, 23.5, h + 1]);

    translate([10, -(23.5 / 2), 0])
    cube([2, 23.5, h + 1]);


    translate([-10, - (23.5 / 2) - 10, 0])
    cube([4, 2, h + 2]);

    translate([6, - (23.5 / 2) - 10, 0])
    cube([4, 2, h + 2]);
  }
}
                ```
                

                Example ID: modular_8bed98a0
                Score: 0.654
                Description: I want a propeller of a drone
                Code:
                ```scad
                // Drone Propeller - Parametric OpenSCAD Model
// This model creates an aerodynamic drone propeller with customizable parameters

// ======== CUSTOMIZABLE PARAMETERS ========
// Basic dimensions
prop_diameter = 127;    // Propeller diameter in mm (5 inches)
hub_diameter = 12;      // Hub diameter in mm
hub_height = 6;         // Hub height in mm
shaft_diameter = 5;     // Motor shaft diameter in mm (M5)
num_blades = 2;         // Number of blades

// Blade parameters
blade_chord_max = 14;   // Maximum width of blade in mm
blade_chord_tip = 5;    // Width at blade tip in mm
blade_thickness = 2.5;  // Maximum thickness at blade root in mm
pitch_angle = 15;       // Base pitch angle (degrees)
twist_angle = 12;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.05;  // Airfoil camber ratio (0.0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.7; // Controls how blade width decreases toward tip (0.5-1.0)
efficiency_factor = 1.2;// Multiplier for airfoil lift curve (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution for curved surfaces
blade_segments = 18;    // Number of segments along blade length
profile_resolution = 24;// Number of points in airfoil cross-section

// ======== DERIVED VARIABLES ========
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

// ======== MODULES ========

// Generate an airfoil cross-section profile
module airfoil_profile(chord, thickness, camber, angle) {
    // Create upper and lower curves of the airfoil
    upper_points = [for (i = [0:profile_resolution]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [profile_resolution:-1:0]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments with varying properties from root to tip
    for (i = [0:blade_segments-1]) {
        // Position along blade (normalized 0-1)
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position with non-linear taper
        chord1 = blade_chord_max * (1 - t * (1 - blade_chord_tip/blade_chord_max) * pow(t, tip_taper_factor));
        chord2 = blade_chord_max * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_max) * 
                 pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip for better dynamics)
        thickness1 = blade_thickness * (1 - 0.6 * t);
        thickness2 = blade_thickness * (1 - 0.6 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution for optimal thrust)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment by connecting profiles at z1 and z2
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/3, d1 = hub_diameter, d2 = hub_diameter * 0.6, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/3, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root for structural integrity
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_max * 0.6);
            
            translate([blade_root_offset - blade_chord_max * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_max * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: modern_d16f0c88
                Score: 0.622
                Description: I want a drone propeller
                Code:
                ```scad
                // Aerodynamic Drone Propeller
// Parametric design with optimized airfoil profile and balanced structure

/* CUSTOMIZABLE PARAMETERS */
// Basic dimensions
prop_diameter = 100;    // Propeller diameter (mm)
hub_diameter = 10;      // Hub diameter (mm)
hub_height = 8;         // Hub height (mm)
num_blades = 3;         // Number of blades
shaft_diameter = 5;     // Motor shaft diameter (mm)

// Blade parameters
blade_chord_root = 15;  // Width at blade root (mm)
blade_chord_tip = 6;    // Width at blade tip (mm)
blade_max_thickness = 2;// Maximum thickness (mm)
pitch_angle = 25;       // Base pitch angle (degrees)
twist_angle = 15;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.04;  // Airfoil camber (0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.8; // Controls how quickly the blade tapers (0.5-1.0)
lift_efficiency = 1.2;  // Multiplier for lift curvature shape (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution
blade_segments = 20;    // Number of segments along blade length
airfoil_resolution = 24;// Points in airfoil cross-section

/* DERIVED VARIABLES */
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

/* MODULES */

// Airfoil profile generator
module airfoil_section(chord, thickness, camber, angle) {
    // Create upper and lower curves of airfoil
    upper_points = [for (i = [0:airfoil_resolution]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [airfoil_resolution:-1:0]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments
    for (i = [0:blade_segments-1]) {
        // Position along blade
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position (non-linear taper for better efficiency)
        chord1 = blade_chord_root * (1 - t * (1 - blade_chord_tip/blade_chord_root) * pow(t, tip_taper_factor));
        chord2 = blade_chord_root * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_root) * pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip)
        thickness1 = blade_max_thickness * (1 - 0.7 * t);
        thickness2 = blade_max_thickness * (1 - 0.7 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/4, d1 = hub_diameter, d2 = hub_diameter * 0.7, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/4, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_root * 0.6);
            
            translate([blade_root_offset - blade_chord_root * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_root * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Weight optimization while maintaining structural integrity
- Symmetrical design for balanced flight dynamics
- Vibration dampening to protect electronic components
- Aerodynamic considerations to minimize drag
- Material selection based on strength-to-weight ratio
- Payload capacity requirements and weight distribution
- Motor mount positioning for optimal thrust vectors
- Accessibility for maintenance and component replacement
- Protection for critical components during crashes
- Code Structure: module structure
- Code Structure: algorithms for structural analysis
- Implementation Technique: union
- Implementation Technique: scale
- Implementation Technique: extrude
- Implementation Technique: translate
                    
                    SHAPE COMPONENTS:
                    - Central hub for housing flight controller and main electronics
- Arms (typically 4) extending from the central hub
- Motor mounts at the end of each arm
- Battery compartment with secure mounting points
- Landing gear or integrated landing supports
- Cable management channels or routing paths
- Reinforcement structures at stress concentration points
- Mounting points for additional components (camera, sensors)
- Protective elements for electronics and propellers
                    
                    IMPLEMENTATION STEPS:
                    1. Define specifications (size, weight capacity, component requirements)
2. Create a basic 2D sketch of the frame layout with proper dimensions
3. Model the central hub with mounting points for electronics
4. Design and extrude the arms with appropriate cross-section for strength
5. Add motor mounts at the ends of arms with correct spacing and orientation
6. Incorporate battery mount and electronic component housings
7. Design integrated or attachable landing gear
8. Add reinforcement structures at high-stress junctions
9. Create cable routing channels or management systems
10. Perform structural analysis simulations to identify weak points
11. Optimize design to reduce weight while maintaining structural integrity
12. Add final details like mounting holes, access points, and fastener locations
13. Validate design with printability checks for 3D printing constraints
14. Create assembly instructions and bill of materials

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "utility" type. Here's a suggested structure:
                
                ```scad
                
        module quadcopter frame(height=10, width=20, depth=15, wall_thickness=2) {
            // Utility object with functional features
            difference() {
                union() {
                    // Add your code here
                    // Add your code here
                }
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
frame_size = 250; // The diagonal motor-to-motor distance in mm (standard sizing convention for quadcopters)
arm_width = 15; // Width of the quadcopter arms in mm
arm_height = 8; // Height/thickness of the quadcopter arms in mm
motor_mount_diameter = 16; // Diameter of the motor mounting holes in mm to accommodate standard motors
motor_mount_hole_pattern = 12; // Distance between motor mounting holes in mm (standard patterns: 12mm, 16mm, 19mm)
center_plate_thickness = 3; // Thickness of the center mounting plate in mm
prop_size = 5; // Propeller size in inches (affects clearance calculations)
fc_mount_pattern = 30.5; // Flight controller mounting hole pattern in mm (standard: 20mm, 30.5mm, 45mm)
arm_thickness = 4; // Thickness of the quadcopter arms in mm, affects structural strength and weight
central_hub_diameter = 50; // Diameter of the central hub in mm where the flight controller and electronics are mounted
vibration_dampening = true; // Whether to include vibration dampening features in the design


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: [PDF] MODELING AND ANALYSIS OF 3D PRINTED QUADCOPTER ...
Content: In the present work, 3D modeling and Static structural analysis of the Quadcopter frame are being performed by Autodesk Fusion 360 software. The CAD model is
---

Title: How to Build a Drone from Scratch (with a Parts List) - 3D Insider
Content: The frame. Quadcopter frames are the shape of an X, and each propeller sits on an X point. The two primary considerations for these structures
---

Title: Quadcopter - Devopedia
Content: What are the design considerations for a quadcopter? The essence of quadcopter design is to generate enough thrust to carry the payload.
---

Title: [PDF] 3D Printed Quadcopters - Rutgers School of Engineering
Content: During the design process, the quad- copter's frame must be developed in compli- ance with a number of constraints. For one, the 3D printer available is unable
---

Title: modeling and analysis of 3d printed quadcopter prototype
Content: In the present work, 3D modeling and Static structural analysis of the Quadcopter frame are being performed by Autodesk Fusion 360 software. The
---


USER REQUEST:
quadcopter frame with weight optimization and vibration dampening

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a drone propeller
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: unknown_9af337fa
                Score: 0.800
                Description: I want a drone propeller with 4 blades, each of it with 6 inches and diameter of 9 inches
                Code:
                ```scad
                //pitch (inches)
PitchI = 6;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 4;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_fdda84c1
                Score: 0.800
                Description: Parametric drone propeller with multiple blades
                Code:
                ```scad
                //Multipropv6-ThgV.scad
//A parametric generator for multiblade propellors.

// Created by Hamish Trolove - Feb 2019
//www.techmonkeybusiness.com

//Licensed under a Creative Commons license - attribution
// share alike. CC-BY-SA

//No extra libraries are required and it works under
//OpenSCAD 2015 and later.  This script will not work
//for older versions of OpenSCAD

//Airfoils:
// Points from naca4412.dat in the archive: http://m-selig.ae.illinois.edu/ads/archives/coord_seligFmt.tar.gz
// Not necessarily in the same order as in: http://m-selig.ae.illinois.edu/ads/coord/naca4412.dat

//pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 5;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_301fdbd5
                Score: 0.700
                Description: Propeller for a whirligig
                Code:
                ```scad
                $fn=180;
Off_ang=-20;
//30mm_bearing cut out
difference(){	union(){
					propeller(5);
						translate([0,0,25])
							scale([1,1,.45])
					hub(20);}
	translate([0,0,-20])
		cylinder(h=30,r=15);}
 module hub(ra){
	 translate([0,0,-55])
		cylinder(h=40,r=ra);
	 	 translate([0,0,-15])
			scale([1,1,.8])
				sphere(ra);}
module propeller(x){
	rotate([-90,0,0])
		for(i=[1:360/x:360])
			rotate([0,i,0])	prop();}
module prop(){
	 scale([.5,1,1])
		translate([0,-11,10])
			intersection(){
				linear_extrude(230,twist=40,scale=.15){
					scale([3,1]) circle(10);}
						translate([0,3,0])
							rotate([0,5,Off_ang])
								scale([.5,.2,3])
									sphere(40);}}
                ```
                

                Example ID: unknown_0c41abcf
                Score: 0.700
                Description: I want a propeller
                Code:
                ```scad
                // Propeller Design
// Parameters for customization
$fn = 100;  // Resolution for circular objects

// Main parameters
num_blades = 3;         // Number of propeller blades
hub_radius = 10;        // Radius of central hub
hub_height = 15;        // Height of central hub
shaft_radius = 3;       // Radius of shaft hole
blade_length = 50;      // Length of each blade
blade_width = 15;       // Maximum width of blade
blade_thickness = 3;    // Maximum thickness at blade root
twist_angle = 30;       // Twist angle from root to tip (degrees)
airfoil_camber = 0.1;   // Camber ratio for airfoil shape

// Module for creating a single propeller blade with twist and airfoil profile
module blade() {
    linear_extrude(height = blade_length, twist = -twist_angle, slices = 40, scale = 0.5) {
        union() {
            // Airfoil shape
            translate([-blade_width/4, 0, 0])
                scale([1, blade_thickness/blade_width, 1])
                    ellipse(blade_width/2, blade_width/2);
                
            // Add slight camber for improved aerodynamics
            translate([0, -blade_thickness * airfoil_camber, 0])
                scale([0.8, 0.2, 1])
                    circle(blade_width/2);
        }
    }
}

// Module for creating an ellipse
module ellipse(width, height) {
    scale([width, height, 1]) circle(1);
}

// Module for creating the central hub with shaft hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(r1 = hub_radius, r2 = hub_radius * 0.8, h = hub_height);
            
            // Hub base (for strength)
            cylinder(r = hub_radius * 1.2, h = hub_height * 0.2);
            
            // Hub top cap
            translate([0, 0, hub_height])
                cylinder(r1 = hub_radius * 0.8, r2 = hub_radius * 0.5, h = hub_height * 0.2);
        }
        
        // Shaft hole through center
        translate([0, 0, -1])
            cylinder(r = shaft_radius, h = hub_height + 2);
            
        // Setscrew hole
        translate([0, 0, hub_height/2])
            rotate([0, 90, 0])
                cylinder(r = shaft_radius/2, h = hub_radius + 1);
    }
}

// Assemble the propeller
module propeller() {
    // Central hub
    color("SlateGray") hub();
    
    // Blades
    color("LightSteelBlue")
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades])
            translate([hub_radius * 0.8, 0, hub_height * 0.6])
                rotate([0, 90, 0])
                    blade();
    }
}

// Create the propeller
propeller();
                ```
                

                Example ID: _0c41abcf
                Score: 0.625
                Description: I want a propeller
                Code:
                ```scad
                // Propeller Design
// Customizable parameters
$fn = 100;  // Resolution for circular objects

// Main parameters
num_blades = 3;         // Number of propeller blades
hub_radius = 10;        // Radius of central hub
hub_height = 15;        // Height of central hub
shaft_radius = 3;       // Radius of shaft hole
blade_length = 50;      // Length of each blade
blade_width = 15;       // Maximum width of blade
blade_thickness = 3;    // Maximum thickness at blade root
twist_angle = 30;       // Twist angle from root to tip (degrees)
airfoil_camber = 0.1;   // Camber ratio for airfoil shape

// Module for creating a single propeller blade with twist and airfoil profile
module blade() {
    linear_extrude(height = blade_length, twist = -twist_angle, slices = 40, scale = 0.5) {
        union() {
            // Airfoil shape
            translate([-blade_width/4, 0, 0])
                scale([1, blade_thickness/blade_width, 1])
                    ellipse(blade_width/2, blade_width/2);
                
            // Add slight camber for improved aerodynamics
            translate([0, -blade_thickness * airfoil_camber, 0])
                scale([0.8, 0.2, 1])
                    circle(blade_width/2);
        }
    }
}

// Module for creating an ellipse
module ellipse(width, height) {
    scale([width, height, 1]) circle(1);
}

// Module for creating the central hub with shaft hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(r1 = hub_radius, r2 = hub_radius * 0.8, h = hub_height);
            
            // Hub base (for strength)
            cylinder(r = hub_radius * 1.2, h = hub_height * 0.2);
            
            // Hub top cap
            translate([0, 0, hub_height])
                cylinder(r1 = hub_radius * 0.8, r2 = hub_radius * 0.5, h = hub_height * 0.2);
        }
        
        // Shaft hole through center
        translate([0, 0, -1])
            cylinder(r = shaft_radius, h = hub_height + 2);
            
        // Setscrew hole
        translate([0, 0, hub_height/2])
            rotate([0, 90, 0])
                cylinder(r = shaft_radius/2, h = hub_radius + 1);
    }
}

// Assemble the propeller
module propeller() {
    // Central hub
    color("SlateGray") hub();
    
    // Blades
    color("LightSteelBlue")
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades])
            translate([hub_radius * 0.8, 0, hub_height * 0.6])
                rotate([0, 90, 0])
                    blade();
    }
}

// Create the propeller
propeller();
                ```
                

                Example ID: functional_a7864989
                Score: 0.619
                Description: Realistic propeller, repeller (e.g. used for wind turbines) and wing designs lead to highly organic shapes
                Code:
                ```scad
                // ShortCuts.scad 
// Autor: Rudolf Huttary, Berlin 2015
// last update 2019.07
//
//$fn = 60; 

//show_examples(); 

module show_examples()
	place_in_rect(30, 30)
	{
		Cy(10, 10);  // Cy(r=10, h=10, center=true)
		CyH(h = 10); // half cylinder
		CyH(d=20, h=10); // 
		CyS(h = 10);  // cylinder segment
		CyS(h = 10, w1 = 25, w2 = 75); 
		Cu(10);     // cube(10, center = true)
		Ri(h = 10);  // ring
		RiH(h = 10); // half ring
		RiS(h = 10, w1 = 10); // ring segment
		RiS(h = 10, w1 = 30, w2 = 300); // ring segment 
		Sp();   // sphere
		SpH(10, 30, 30); // half sphere
	}
help(); 

module help() help_shortcuts(); 
module help_ShortCuts() help_shortcuts(); 
  
module help_shortcuts()
{
  h = str("shortcuts.scad\n by Rudolf Huttary\n, 2018.01\n", 
  "help(): shows this help\n",
  "help_shortcuts(): shows this help\n",
  "show_examples(): shows some examples\n",
  "place_in_rect(dx =20, dy=20): places children objects in grid\n",
  "measure(s=10, x=undef, y=undef, z=undef): half transparent cube of given size \n",
  "*Transformations:*\n",
  "module T(x=0, y=0, z=0): translate by [x,y,z]; alternatively T([x,y,z]) allowed \n",
  "module Tx(x=0): translate along x axis\n",
  "module Ty(y=0): translate along y axis\n",
  "module Tz(z=0): translate along z axis\n",
  "module R(x=0, y=0, z=0): rotation by [x,y,z]; alternatively R([x,y,z]) allowed \n",
  "module Rx(x=0): rotate around x axis\n",
  "module Ry(y=0): rotate around y axis\n", 
  "module Rz(z=0): rotate around z axis\n",
  "module S(x=1, y=1, z=1): scale by [x,y,z]; alternatively S([x,y,z]) allowed \n",
  "module Sx(x=1): scale along x axis\n",
  "module Sy(y=1): scale along y axis\n",
  "module Sz(z=1): scale along z axis\n",
  "module Skew(x=0, y=0, z=0, a=0, b=0, c=0): skew operation\n",
  "module skew(x=0, y=0, z=0, a=0, b=0, c=0): skew operation\n",
  "module SkewX(x=0): skew along x axis \n",
  "module SkX(x=0): skew along x axis \n",
  "module SkewY(y=0): skew along y axis \n", 
  "module SkY(y=0): skew along y axis \n",
  "module SkewZ(z=0): skew along z axis \n", 
  "module SkZ(z=0): skew along z axis \n",
  "*Logical*\n",
  "module D(): difference operation\n",
  "U(): union operation\n",
  "I(): intersection operation\n",
  "*Useful*\n",
  "module rotN(r=10, N=4, offs=0, M=undef): place N instances of children around circle with radius r. If M given, only M of N instances\n",
  "module forX(dx = 10, N=4): operator places N instances of children centered along X with instance distance dx\n",
  "module forY(dy = 10, M=4): operator places M instances of children centered along Y with instance distance dy\n",
  "module forZ(dz = 10, M=4): operator places M instances of children centered along Z with instance distance dz\n",
  "module forXY(dx, N=4, dy = 10, M=4): operator places NxM instances of children in centered XY grid with width [dx, dy]\n",
  "module C(r,g,b,t) or C(string,t): color operator; alternatively C([r,g,b], t) and C(\"colorname\",t) allowed  \n",
  "function Rg(N=10): generates int range (0:1:N-1)\n",
  "module measure(s=10, x=undef, y=undef, z=undef): draw transparent 2D square(s) of size s, translated by x,y,z orthogonal to axis x,y,z\n",
  "*Primitives*\n",
  "module Ci(r=10, d=undef): circle with radius r or diameter d\n",
  "module CiH(r=10, w=0, d=undef) or circle_half(...): half circle rotated by w\n",
  "module circle_half(...): CiH(...)\n",
  "module CiS(r=10, w1=0, w2=90, d=undef)or circle_sector(...): circle sector from angle w1 to w2\n",
  "module circle_sector(...): CiS(...)\n",
  "module CiR(R=10, r=5, w1=0, w2=360, D=undef, d=undef): Ring 2D\n",
  "module circle_ring(...): CiR(...)\n",
  "module Sq(x=10, y=undef, center=true)): rect with x,y or square with sides x\n",
  "module Cy(r=10, h=1, center=true, r1=undef, r2=undef, d=undef): cylinder\n",
  "module CyH(r=10, w=0, d=undef) or cylinder_half(...) half cylinder rotated by w\n",
  "module cylinder_half(...): CyH(...)\n",
  "module CyS(r=10, h=1, w1=0, w2=90,center=true, d=undef) or Pie(...) or cylinder_sector(...): cylinder sector from angle w1 to w2\n",
  "module cylinder_sector(...): CyS(...)\n",
  "module CyR(r=10, h=10, r_=1, d=undef, r1=undef, r2=undef, d1=undef, d2=undef, center=false) or cylinder_rounded(...): like cylinder() with rounded end faces \n",
  "module cylinder_ring(...): see CyR(...)\n",
  "module Cu(x=10, y=undef, z=undef, center=true): a cube with sides x,y,z; alternatively cube_rounded([x,y,z], r) and cube_rounded(x, y, z, r) allowed\n",
  "module CuR(x=10, y=20, z=30, r=1, center=true): cube with rounded vertices\n",
  "module cube_rounded(...): see CuR(...)\n",
  "module CuB(x=2, y=10, z=5, dx=1, dy=1, dz=1, center=true): cube bevelled, alternatively cube_bevelled([x,y,z], [dx,dy,dz]) allowed \n",
  "module cube_bevel(...): CuB(...)\n",
  "module Le(h=1, center = true, convexity=1, twist=0, slices=undef, scale=1) linear_extrude\n",
  "module Re(angle = 360): rotate_extrude procrusting\n",
  "module Re2(angle = 360): rotate_extrude non-procrusting (union of 2 rotate_extrude objects)\n",
  "module Ri(R=10, r=5, h=1, center=true, D=undef, d=undef): ring\n",
  "module Ring(...): see Ri(...)\n",
  "module ring(...): see Ri(...)\n",
  "module RiH(R=10, r=5, h=1, w=0 center=true, D=undef, d=undef) half ring rotated by w\n",
  "module ring_half(...) see RiH(...)",
  "module RiS(R=10, r=5, h=1, w1=0, w2=90, center=true, D=undef, d=undef) or ring_sector(): ring sector from w1 to w2\n",
  "module ring_sector(...) see RiS(...)",
  "module Sp(r=10): sphere(r)\n",
  "module SpH(r=10, w1 = 0, w2 = 0):  half sphere rotated with angle w\n",
  "module sphere_half(...) see SpH(...)\n",
  "module To(R=10, r=1, w1=0, w2=360): torus(...): torus from angle w1 to angle w2\n",
  "module torus(...) see To(...)\n");
  echo(h); 
}


// Euclidean Transformations

module T(x=0, y=0, z=0){
  translate(x[0]==undef?[x, y, z]:x)children(); }
  
module Tx(x) { translate([x, 0, 0])children(); }
module Ty(y) { translate([0, y, 0])children(); }
module Tz(z) { translate([0, 0, z])children(); }


module R(x=0, y=0, z=0){rotate(x[0]==undef?[x, y, z]:x) children();}
module Rx(x=90){rotate([x, 0, 0]) children();}
module Ry(y=90){rotate([0, y, 0]) children();}
module Rz(z=90){rotate([0, 0, z]) children();}
module M(x=0, y=0, z=0) mirror(x[0]==undef?[x, y, z]:x) children(); 
module Mx() mirror([1, 0, 0]) children(); 
module My() mirror([0, 1, 0]) children(); 
module Mz() mirror([0, 0, 1]) children(); 

module S(x=1, y=undef, z=undef){ scale(x[0]==undef?[x, y?y:x, z?z:y?1:x]:x) children();}
module Sx(x=1){scale([x, 1, 1]) children();}
module Sy(y=1){scale([1, y, 1]) children();}
module Sz(z=1){scale([1, 1, z]) children();}


module Skew(x=0, y=0, z=0, a=0, b=0, c=0)
  multmatrix([[1, a, x], [b, 1, y], [z, c, 1]]) children(); 
module skew(x=0, y=0, z=0, a=0, b=0, c=0) 
  Skew(x, y, z, a, b, c) children();  
module SkX(x=0) Skew(x=x) children(); 
module SkY(y=0) Skew(y=y) children(); 
module SkZ(z=0) Skew(z=z) children(); 
module SkewX(x=0) Skew(x=x) children(); 
module SkewY(y=0) Skew(y=y) children(); 
module SkewZ(z=0) Skew(z=z) children(); 


// Booleans
module D() if($children >1) difference(){children(0); children([1:$children-1]);} else children(); 
module U() children([0:$children-1]);
module I() intersection_for(n=[0:$children-1]) children(n); 

// rotates N instances of children around z axis
module rotN(r=10, N=4, offs=0, M=undef) for($i=[0:(M?M-1:N-1)])  rotate([0,0,offs+$i*360/N])  translate([r,0,0]) children();
module forN(r=10, N=4, offs=0, M=undef) rotN(r, N, offs, M) children();
module forX(dx = 10, N=4) for($i=[0:N-1]) T(-((N-1)/2-$i)*dx) children(); 
module forY(dy = 10, M=4) for($i=[0:M-1]) Ty(-((M-1)/2-$i)*dy) children(); 
module forZ(dz = 10, M=4) for($i=[0:M-1]) Tz(-((M-1)/2-$i)*dz) children(); 
module forXY(dx = 10, N=4, dy = 10, M=4) forX(dx, N) forY(dy, M) children(); 

// $i Counter, $j= $i-th list element of P
module forI(P, Q=undef,step=1) // P="hi there" | P=[1,3,4] | P=[0:2:12] | P=0, Q=9
{
  X = Q==undef?(is_list(P)?P:
                [for(i=P) i]): 
      is_num(P)?[for(i=[P:step:Q]) i]:
        echo("error") undef; 
  for($i=[0:len(X)-1]) let($j=X[$i]) children(); 
}

module Le(h=10, convexity=4, scale=1, center=true, twist=0, slices=undef)
  linear_extrude(height=h, convexity=convexity, scale=scale, center=center, twist=twist, slices=slices) children(); 

module Re(angle = 360)
{
  rotate_extrude(angle = angle)
  intersection() 
  {
    translate([0, -1e5])square([1e5, 2e5]); 
    children(); 
  }
}

module Re2(angle = 360)
{
  rotate_extrude(angle = angle)
  intersection() 
  {
    translate([1e5, 0])square([2e5, 1e5], center = true); 
    children(); 
  }
  rotate_extrude(angle = angle)
  intersection() 
  {
    translate([-1e5, 0])square([2e5, 1e5], center = true); 
    children(); 
  }
}


// primitives - 2D

module Sq(x =10, y = undef, center = true)
{
  x = x[0]?x:[x, y?y:x]; 
		square(x, center = center); 
}
module Ci(r = 10, d=undef) circle(d?d/2:r); 

// derived primitives - 2d
module CiH(r = 10, w = 0, d=undef)
  circle_half(r, w, d); 

//module CiS(r = 10, w1 = 0, w2 = 90, d=undef, center = true)
//  circle_sector(r, w1, w2, d, center=center); 

module CiR(R=10, r=5, w1=undef, w2=undef, D=undef, d=undef)
{
  if(w1!=undef && w2!=undef)
  D()
  {
    CiS(R, w1, w2, D); 
    CiS(r, w1, w2, d); 
  }
  else
  D()
  {
    Ci(R, D); 
    Ci(r, d); 
  }
}

module CiS(r=10, w1=0, w2=90, d=undef) 
{
  r = d==undef?r: d/2; 
  polygon(pie(r, w1, w2)); 
  function pie(r=40, a1=0, a2=150) = 
    let(start = a1%360)
    let(end = (a2%360-start)>=0?a2%360:a2%360+360)
    let(fa = $fn==0?$fa:360/$fn)
    let(step = (end-start)/ceil((end-start)/fa)- 1e-7)
    r*[[0,0], for(i=[start:step:end]) [cos(i), sin(i)]]; 
}
  

// primitives - 3d
module Cy(r = 10, h = 1, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
  if(r1!=undef)
    cylinder(r1=r1, r2=r2?r2:d2/2, h=h, center=center); 
  else if(d!=undef)
    cylinder(r=d/2, h=h, center=center); 
  else if(d1!=undef)
    cylinder(r1=d1/2, r2=r2?r2:d2/2, h=h, center=center); 
  else cylinder(r=r, h=h, center=center); 
    

module Cu(x = 10, y = undef, z = undef, center = true)
  cube(x[0] == undef?[x, y?y:x, y?z?z:1:x]:x, center=center); 

CuR(x=2, y=10, z=5, r=1, center=true)
  cube_rounded(x, y, z, r, center); 
  
module CuR(x = 10, y = 20, z = 30, r = 1, center = true)
  cube_rounded(x, y, z, r, center); 

module CuB (x=2, y=10, z=5, dx=1, dy=1, dz=1, center=true)
  cube_bevel(x, y, z, dx, dy, dz, center); 
  
module CyR(r = 10, h=10, r_=1, d = undef, r1=undef, r2=undef, d1 = undef, d2 = undef, center=false)  
  cylinder_rounded(r, h, r, d, r1, r2, d1, d2, center); 

// derived primitives - 3d
module CyH(r = 10, h = 1, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
  cylinder_half(r=r, h=h, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2); 

module CyS(r = 10, h = 1, w1 = 0, w2 = 90, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
  cylinder_sector(r=r, h=h, w1=w1, w2=w2, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2); 

module Ri(R = 10, r = 5, h = 1, center = true, D=undef, d=undef)
  ring(R, r, h, center, D, d); 

module RiS(R = 10, r = 5, h = 1, w1 = 0, w2 = 90, center = true, D=undef, d=undef)
   ring_sector(R, r, h, w1, w2, center, D, d); 

module RiH(R = 10, r=5, h = 1, w = 0, center = true, D=undef, d=undef)
   ring_half(R, r, h, w, center, D, d); 
module Pie(r = 10, h = 1, w1 = 0, w2 = 90, center = true, d=undef)
  cylinder_sector(r, h, w1, w2, center, d);  
module Sp(r = 10)
  sphere(r); 
module SpH(r = 10, w1 = 0, w2 = 0)
  sphere_half(r, w1, w2); 
module To(R=10, r=1, r1 = undef, w=0, w1=0, w2=360, fn = undef) torus(R=R, r=r, r1=r1, w=w,w1=w1, w2=w2, fn=fn);  

module C(r=1, g=1, b=1, t=1) 
{
  if(r!=undef)
  if(len(r)) 
    color(r, g) children(); 
  else
    color([r,g,b], t) children(); 
  else
    children();
}

module red(t=1) color("red", t) children(); 
module green(t=1) color("green", t) children(); 
module blue(t=1) color("blue", t) children(); 
module black(t=1) color("black", t) children(); 
module white(t=1) color("white", t) children(); 
module yellow(t=1) color("yellow", t) children(); 
module lightblue(t=1) color("lightblue", t) children(); 
module gray(t=1) color("gray", t) children(); 
module lightgray(t=1) color("lightgray", t) children(); 
module orange(t=1) color("orange", t) children(); 
module darkgray(t=1) color("darkgray", t) children(); 

function Rg(rg) = let(x=rg[2]+.00001?rg:[0:1:rg-1])  
[for(i=[x[0]:x[1]:x[2]]) i]; 

//


// clear text definitions

module cube_rounded(x=10, y=20, z=30, r=1, center=true)
{
  sz = is_list(x)?x:[x,y,z]; 
  r = is_list(x)?y:r; 
  echo(x, y, z, r, sz); 
  ce = is_list(center)?center:[center, center, center]; 
  r_ = min(abs(r), abs(sz.x/2), abs(sz.y/2), abs(sz.z/2)); 
  translate([ce.x?-sz.x/2:0,ce.y?-sz.y/2:0, ce.z?-sz.z/2:0])
  if(r)
    hull() 
    {
      translate([r_, r_, r_]) sphere(r_); 
      translate([r_, r_, sz.z-r_]) sphere(r_); 
      translate([r_, sz.y-r_, r_]) sphere(r_); 
      translate([r_, sz.y-r_, sz.z-r_]) sphere(r_); 
      translate([sz.x-r_, r_, r_]) sphere(r_); 
      translate([sz.x-r_, r_, sz.z-r_]) sphere(r_); 
      translate([sz.x-r_, sz.y-r_, r_]) sphere(r_); 
      translate([sz.x-r_, sz.y-r_, sz.z-r_]) sphere(r_); 
    }
  else 
    cube(size); 
}

module cube_bevel(x=2, y=10, z=5, dx=1, dy=1, dz=1, center=true)
{
  S = is_list(x)?x:[x,y,z]; 
  D_ = is_list(y)?y:[dx,dy,dz];
  D=[min(S[0]/2, D_[0]), 
     min(S[1]/2, D_[1]), 
     min(S[2]/2, D_[2])]; 
  translate(center?[0,0,0]:[S[0]/2+dx, S[1]/2+dy, S[2]/2+dz])
  hull()
  {
   cube(S + [2*D[0], 0, 0], center = true); 
   cube(S + [0, 2*D[1], 0], center = true); 
   cube(S + [0, 0, 2*D[2]], center = true); 
  }
}


module circle_half(r = 10, w = 0, d = undef)
{
  R= d?d/2:r;
	difference()
	{
		circle(R); 
     rotate([0, 0, w-90])
     translate([0, -R])
		square([R, 2*R], center = false); 
	}
}

module circle_sector(r = 10, w1 = 0, w2 = 90, d = undef)
{
  R = d?d/2:r; 
  W2 = (w1>w2)?w2+360:w2; 
  diff = abs(W2-w1);
  if (diff < 180)
    intersection()
		{
       circle_half(R, w1); 
       circle_half(R, W2-180); 
 		}
	else if(diff>=360)
    circle(R); 
  else
		{
       circle_half(R, w1); 
       circle_half(R, W2-180); 
 		}
}

module cylinder_half(r = 10, h = 1, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
{
  R = max(d?d/2:r, r1?r1:0, r2?r2:0, d1?d1/2:0, d2?d2/2:0);
  difference()
  {
    Cy(r=r, h=h, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2);
    Ty(-(R+1)/2)
    Cu(2*R+1, R+1, h+1, center = center); 
  }
//  linear_extrude(height = h, center = center)
//  circle_half(r=r, w=w, d=d); 
} 

module cylinder_sector(r = 10, h = 1, w1 = 0, w2 = 90, center = true, r1 = undef, r2=undef, d=undef, d1=undef, d2=undef)
{
  R = max(d?d/2:r, r1?r1:0, r2?r2:0, d1?d1/2:0, d2?d2/2:0);
    intersection()
    {
      Cy(r=r, h=h, center=center, r1=r1, r2=r2, d=d, d1=d1, d2=d2);
      cylinder_sector_(r=R, h=h, w1=w1, w2=w2, center=center);
    }
}

module cylinder_sector_(r = 10, h = 1, w1 = 0, w2 = 90, center = true)
  linear_extrude(height = h, center = center, convexity = 2)
  circle_sector(r=r, w1=w1, w2=w2); 

module cylinder_rounded(r=10, h=10, r_=1, d=undef, r1=undef, r2=undef, d1=undef, d2=undef, center=true)
{
  r1 = r1==undef?d1==undef?d==undef?r:d/2:d1/2:r1;
  r2 = r2==undef?d2==undef?d==undef?r:d/2:d2/2:r2;
  r_ = min(abs(h/4), abs(r1), abs(r2), abs(r_));
  h = abs(h);
  Tz(center?-h/2:0) rotate_extrude() I()
  {
    offset(r_)offset(-r_) polygon([[-2*r_,0], [r1, 0], [r2, h], [0,h], [-2*r_,h]] );
    Sq(max(r1,r2), h, 0);
  }
} 

module Ring(R1 = 12, R2 = 10, r1 = 6, r2 = 5, h = 10, center = true)
	difference()
	{
    Cy(r1=R1, r2=r1, h=h, center = center); 
    Tz(-.001)Cy(r1=R2, r2=r2, h=h+1,center = center); 
	}


module ring(R = 10, r = 5, h = 1, center = true, D=undef, d=undef)
  linear_extrude(height = h, center = center, convexity = 2)
	difference()
	{
    Ci(r = D?D/2:R); 
    Ci(r = d?d/2:r); 
	}


module ring_half(R = 10, r = 5, h = 1, w = 0, center = true, D=undef, d=undef)
  linear_extrude(height = h, center = center, convexity = 2)
  Rz(w)
	difference()
	{
    CiH(r = D?D/2:R); 
    Ci(r = d?d/2:r); 
	}

module ring_sector(R = 10, r = 5, h = 1, w1 = 0, w2 = 90, center = true, D=undef, d=undef)
  linear_extrude(height = h, center = center, convexity = 2)
	difference()
	{
    CiS(r = D?D/2:R, w1 = w1, w2 = w2); 
    Ci(r = d?d/2:r); 
	}


module sphere_half(r = 10, w1 = 0, w2 = 0)
  R(w1, w2)
	intersection()
	{
   	sphere(r); 
     	translate([-r, -r, 0])
		cube([2*r, 2*r, r]); 
	}

module torus(R=10, r=1, r1 = undef, w=0, w1=0, w2=360, fn = undef)
{
  if (r1)
    D(){
      To(R=R, r=r, w=w, w1=w1, w2=w2, fn=fn); 
      To(R=R, r=r1, w=w, w1=w1-1, w2=w2+1, fn=fn); 
    }
  else
    Rz(w1)
    rotate_extrude(angle = w2-w1)
    T(R)
    Rz(w) ci(); 
 module ci()
    if(fn!=undef) circle(r, $fn=fn); else circle(r); 
}

// additional code
module place_in_rect(dx =20, dy=20)
{
  cols = ceil(sqrt($children)); 
  rows = floor(sqrt($children)); 
  for(i = [0:$children-1])
	{ 
	  T(dx*(-cols/2+(i%cols)+.5), dy*(rows/2-floor(i/cols)-.5))
		 children(i); 
	}
}

module measure(s=10, x=undef, y=undef, z=undef)
{
  p=[[s, s, 0], [-s, s, 0], [-s, -s, 0], [s, -s, 0]]; 
  C("black",.5)
  {
    if(z) Tz(z) polyhedron(p, [[0,1,2,3]]); 
    if(x) Tx(x) Ry(90)polyhedron(p, [[0,1,2,3]]); 
    if(y) Ty(y) Rx(90) polyhedron(p, [[0,1,2,3]]); 
  }
}

// Naca4_sweep.scad - sweep library
// Code: Rudolf Huttary, Berlin 
// 1st release : June 2015
// last update: 2020.04.10
// commercial use prohibited

// use <naca4.scad>

//example1(); 
//rotate([80, 180, 130])
//example(); 

// sweep from NACA1480 to NACA6480 (len = 230 mm, winding y,z = 80
module example()
{
  N = 40; 
  sweep(gen_dat(N=5, dz=1,N=N), showslices = false); 
//  sweep(gen_dat(N=5, dz=1,N=N), showslices = true); 
  
  // specific generator function
  function gen_dat(M=10,dz=.1,N=10) = [for (i=[1:dz:M])   
    let( L = length(i))
    let( af = vec3D(
        airfoil_data([.1,.5,thickness(i)], L=length(i), N = N)))
    T_(-L/2, 0, (i+1)*2, af)];  // translate airfoil
  
  function thickness(i) = .5*sin(i*i)+.1; 
  function length(i) = (60+sin(12*(i-3))*30); 
}

module help() help_Naca_sweep(); 
module help_Naca_sweep()
{
  echo(str("\n\n<b>Naca4_sweep library - by Rudolf Huttary, Berlin</b>\n",
  "module sweep(dat, convexity = 5, showslices = false, close = false, planar_caps = false)  // dat - vec of vec3-polygons\n", 
  "module skin(dat, showslices = false, close = false, planar_caps = true, convexity = 5) // like sweep \n",
  "module sweeps(Dat, convexity = 5) // lazy union of multiple sweeps\n",
  "module sweep_multihole(outer, holes, convexity = 5) // sweep with multiple holes\n",
  "module sweep_path(path, shape, close = false) // sweep shape along path\n",
  "function sweep(dat, close = false, planar_caps = true) // dat - vec of vec3-polygons \n",
  "function sweeps(Dat) = // lazy union sweep\n",
  "function sweep_path(path, shape) // sweep shape along path\n",
  "\n<b>Some matrix/vector operations </b>\n",
  "function rotate_from_to(a,b) = // matrix for rotation from normal a to normal b\n",
  "function transpose(A)\n",
  "function normal(a,b,c)\n, // a can be vector ",
  "function unit(a)  // unify a to length 1\n",
  "\n<b>Affine operations</b> \n=================\n",
  "function vec3D(v, z=0)  // expand vec2 to vec3",
  "function vec3(v, z=0)  // expand vec2 to vec3",
  "function T(x=0, y=0, z=0, v) and function T_(x=0, y=0, z=0, v) // translates vec of vec3, x may be vector\n", 
  "function Tx(x=0, v) and function Tx_(x=0, v) // x-translates vec of vec3\n", 
  "function Ty(y=0, v) and function Ty_(y=0, v) // y-translates vec of vec3\n", 
  "function Tz(z=0, v) and function Tz_(z=0, v) // z-translates vec of vec3\n", 
  "function R(x=0, y=0, z=0, v) and function R_(x=0, y=0, z=0, v) // rotates vec of vec3\n", 
  "function Rx(x=0, v) and function Rx_(x=0, v) // x-rotates vec of vec3\n", 
  "function Ry(y=0, v) and function Ry_(y=0, v) // y-rotates vec of vec3\n", 
  "function Rz(z=0, v) and function Rz_(z=0, v) // z-rotates vec of vec3\n", 
  "function S(x=0, y=0, z=0, v) and function S_(x=0, y=0, z=0, v) // scales vec of vec3\n", 
  "function Sx(x=0, v) and function Sx_(x=0, v) // x-translates vec of vec3\n", 
  "function Sy(x=0, v)and function Sy_(x=0, v) // y-translates vec of vec3\n", 
  "function Sz(x=0, v) and function Sz_(x=0, v) // z-translates vec of vec3\n",
  "function count(a, b) // sequence a to b as list\n",
  "function subdiv(path, maxlen = 10) // subdivide 3D point path segments, if longer than maxlen\n",
  "=================\n")); 
}

// Calculates a polyhedron based extrusion. 
// Expects a dataset defined as *non-selfintersecting* sequence of polygons that describes a extrusion trajectory
//  interchangable with skin()
// dat := vector of simple polygons, with polygon := vec of vec3, minimum 3 points per polygon expected
// use "planar_caps = true" only if triangulation of OpenSCAD works flawlessly
module sweep(dat, showslices = false, close = false, planar_caps = true, convexity = 5) 
{
  n = len(dat);     // # datasets
  l = len(dat[0]);  // points per dataset 
  if(l<3) echo("ERROR: sweep() expects more than 3 points per dataset"); 
  if (showslices)  for(i=dat) poly(i);
  else
  {
    obj = sweep(dat, close=close, planar_caps=planar_caps); 
    polyhedron(obj[0], obj[1], convexity = convexity); 
  }
}

module poly(p)
{
  p_ = (len(p[0])==2)?vec3D(p):p;
  polyhedron(p_, [count(0,len(p)-1)]); 
}

module skin(dat, showslices = false, close = false, planar_caps = true, convexity = 5) 
 sweep(dat, showslices, close, planar_caps, convexity); 

module sweep_path(path, shape, close = false) // usage: sweep_path(circle(r=100), circle(r=30), close=true); 
  sweep(sweep_path(path, shape, close=close), close = close); 
 
function sweep_path(path, shape, close = false) = 
  [for(i=0, n=path[1]-path[0], 
    m=-normal(shape),
    R=rotate_from_to(n, m); 
    i<len(path); 
    m=n, i=i+1, 
    n=i<len(path)-1?path[i+1]-path[i]:close?path[0]-path[i-1]:n,
    R=R*rotate_from_to(n, m))   echo(i, n)
      T(path[i], shape*R)];

function normal(a,b,c) = a[0]==undef?unit(cross(a-b,b-c)): unit(cross(a[0]-a[1],a[1]-a[2])); 

function rotate_from_to(a,b) = // matrix for rotation from normal a to normal b
        let( axis = unit(cross(a,b)) )
        axis*axis >= 0.99 ? 
           transpose([unit(b), axis, cross(axis, unit(b))]) * [unit(a), axis, cross(axis, unit(a))] : 
            [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
function transpose(A) = [for(i=[0:2])[for(j=[0:2]) A[j][i]]]; 
function unit(a) = a/norm(a); 
function rotate_from_to(a,b) =  
let( axis = unit(cross(a,b)) )
 axis*axis >= 0.99 ? 
  transpose([unit(b), -axis, cross(-axis, unit(b))]) * [unit(a), -axis, cross(-axis, unit(a))] : 
  [[1, 0, 0], [0, 1, 0], [0, 0, 1]];


module sweep_multihole(outer, holes, convexity = 5)
  difference()
  { 
    sweep(outer, convexity = convexity); 
    sweeps(holes, convexity = convexity); 
  }
  

// sweeps generates a single polyhedron from multiple datasets
module sweeps(Dat, convexity = 5) // lazy union sweep
{
  soup = sweeps(Dat); 
  polyhedron(soup[0], soup[1], convexity = convexity);  
}

function sweeps(Dat) = // lazy union sweep
  let(sweeps = [for(S=Dat) sweep(S)])              // do all the sweeps
  let(offs = sweepsNewoffs([for(S=sweeps) len(S[0])]))  // calc indices for face shifts
  let(faces = [for(i=[0:len(sweeps)-1]) each sweepsShiftFaces(sweeps[i][1], offs[i])])  // shift faces indices 
  let(points = [for(S=sweeps) each S[0]])  
    [points, faces]; 

  function sweepsShiftFaces(faces, N) = // helper: calcs face shift indices
    [for(x=faces) [for(y=x) y+N]]; 
    
  function sweepsNewoffs(L, o=0, i=0) = // helper: calcs acculumlated offsets 
      i<len(L)?concat([o], sweepsNewoffs(L, o+L[i], i+1)):[];

function sweep(dat, close = false, planar_caps = true) = // main sweep function
  let(n=len(dat), l=len(dat[0]))
  let(first = planar_caps?[count(l-1, 0)]: facerev(earcut(dat[0])))
  let(last = planar_caps?[count((n-1)*l,(n)*l-1)]: faces_shift((n-1)*l, (earcut(dat[0])))) 
  let(faces = close?faces_sweep(l,n, close) :concat(first, last, faces_sweep(l,n))) 
  let(points = [for (i=[0:n-1], j=[0:l-1]) dat[i][j]]) // flatten points vector
[points, faces]; 

function count(a, b) = [for (i=[a:(a<b?1:-1):b]) i];  // helper
function faces_shift(d, dat) = [for (i=[0:len(dat)-1]) dat[i] + [d, d, d]]; // helper
  
//// knit polyhedron
  function faces_sweep(l, n=1, close = false) = 
      let(M = n*l, n1=close?n+1:n) 
      concat([[0,l,l-1]],   // first face
             [for (i=[0:l*(n1-1)-2], j = [0,1])
                j==0? [i, i+1, (i+l)%M] 
                    : [i+1, (i+l+1)%M, (i+l)%M]
             ]
             ,[[(n1*l-1)%M, (n1-1)*l-1, ((n1-1)*l)%M]
             ]); // last face
      ;
    
function facerev(dat) = [for (i=[0:len(dat)-1]) [dat[i][0],dat[i][2],dat[i][1]]]; 

//// vector and vector set operation stuff ///////////////////////
//// Expand 2D vector into 3D
function vec3(v,z=0) = v[0][0]==undef?[v[0],v[1],z]:[for(a=v) vec3D(a, z)]; 
function vec2(v) = v[0][0]==undef?[v[0], v[1]]:[for(a=v) vec2(a)]; 
function vec3D(v,z=0) = vec3(v, z); 

// Translation - 1D, 2D, 3D point vector //////////////////////////
//   recursive! operates over vectors, lists of vectors, lists of lists ... 
function T_(x=0, y=0, z=0, v) = let(il=x[0]!=undef?len(x)==3:false)
  let(v = il?y:v, x = il?x:[x, y, z]) v[0][0]!=undef?[for (i=v) T_(x,i)]:v+x; 
function T(x=0, y=0, z=0, v) = T_(x,y,z,v); // synonym
/// translate along one axis
function Tx_(x=0, v=undef) = v[0][0]!=undef?[for (i=v) Tx_(x,i)]:v+[x,0,0]; 
function Tx(x=0, v=undef) = Tx_(x,v); // synonym
function Ty_(y=0, v) = v[0][0]!=undef?[for (i=v) Ty_(y,i)]:v+[0,y,0];  
function Ty(y=0, v) = Ty_(y,v); // synonym
function Tz_(z=0, v) = v[0][0]!=undef?[for (i=v) Tz_(z,i)]:v+[0,0,z]; 
function Tz(z=0, v) = Tz_(z,v); // synonym

//// Rotation - 2D, 3D point vector ///////////////////////////////////
//   recursive! operates over vectors, lists of vectors, lists of lists ... 
// 2D vectors allowed 
function R_(x=0, y=0, z=0, v) = let(len_x_eq_3= x[0]!=undef?len(x)==3:false) 
  let(v = len_x_eq_3?y:v, x=len_x_eq_3?x:[x, y, z])
  v[0][0]!=undef? [for(i=v) R_(x,i)]:Rz_(x[2], Ry(x[1], Rx_(x[0], v)));  
function R(x=0, y=0, z=0, v) = R_(x,y,z,v); // synonym
// rotate around one axis
function Rx_(x, A) = A[0][0]!=undef?[for(i=A) Rx_(x, i)]:
    A*[[1, 0, 0], [0, cos(x), sin(x)], [0, -sin(x), cos(x)]]; 
function Rx(x, A) = Rx_(x, A); // synonym
function Ry_(y, A) = A[0][0]!=undef?[for(i=A) Ry_(y, i)]:
    A*[[cos(y), 0, sin(y)], [0, 1, 0], [-sin(y), 0, cos(y)]]; 
function Ry(y, A) = Ry_(y, A); // synonym
function Rz_(z, A) = let(lenA0is2=A[0]!=undef?len(A)==2:false) 
    A[0][0]!=undef? 
    [for(i=A) Rz_(z, i)]: 
    lenA0is2? 
    A*[[cos(z), sin(z)], [-sin(z), cos(z)]]: 
    A*[[cos(z), sin(z), 0], [-sin(z), cos(z), 0], [0, 0, 1]]; 
function Rz(z, A) = Rz_(z, A); // synonym


//// Scale - 2D, 3D point vectors ///////////////////////////////////
//   recursive! operates over vectors, lists of vectors, lists of lists ... 
function S_(x=1, y=1, z=1, v) = let(len_x_eq_3=x[0]!=undef?len(x)==3:false)
  let(v = len_x_eq_3? y:v, x = len_x_eq_3? x:[x, y, z])
    v[0][0]!=undef?
//    echo(v=v,x=x)
      [for (i=v) S_(x,i)]:
        [for (i=[0:len(v)-1]) v[i]*x[i] ];
function S(x=1, y=1, z=1, v) = S_(x,y,z,v);     
// scale along one axis
function Sx_(x=0, v) = S_(x=x, v=v); 
function Sx(x=1, v) = Sx_(x,v); // synonym    
function Sy_(y=0, v) = S_(y=y, v=v); 
function Sy(y=1, v) = Sy_(y,v); // synonym    
function Sz_(z=0, v) = S_(z=z, v=v); 
function Sz(z=1, v) = Sz_(z,v); // synonym   

// usage example: 
// skin(LinearPathExtrude(subdiv(Sq(100), 20))); 
// function LinearPathExtrude(path, h=10, twist = 90, slices=10) = 
//   [for(i=[0:n])  Rz(w/n*i, Tz(h/slices*i, path)) ]; 
function subdiv(path, maxlen = 10) = // subdivide path segments if larger than maxlen
let(L = len(path)) 
[for(i=[0:L-1])
  let (unit = path[i]-path[(i+1)%L])
  let (l = norm(unit))
  if(l>maxlen) 
    let(n = ceil(echo(l/(maxlen)) l/maxlen))
    each[ for(j=[0:n-1]) path[i]-j*unit/(n)]
  else
   path[i]]; 


module airfoil(naca=12, L = 100, N = 81, h = 1, open = false)
{
  linear_extrude(height = h)
  polygon(points = airfoil_data(naca, L, N, open)); 
}

// this is the main function providing the airfoil data
function airfoil_data(naca=12, L = 100, N = 81, open = false) = 
  let(Na = naca[0]!=undef?naca:NACA(naca))
  let(A = [.2969, -0.126, -.3516, .2843, open?-0.1015:-0.1036])
  [for (b=[-180:360/(N):179.99]) 
    let (x = (1-cos(b))/2)  
    let(yt = sign(b)*Na[2]/.2*(A*[sqrt(x), x, x*x, x*x*x, x*x*x*x])) 
    Na[0]==0?L*[x, yt]:L*camber(x, yt, Na[0], Na[1], sign(b))];  

// helper functions
function NACA(naca) = 
  let (M = floor(naca/1000))
  let (P = floor((naca-M*1000)/100)) 
  [M/100, P/10, floor(naca-M*1000-P*100)/100];  

function camber(x, y, M, P, upper) = 
  let(yc = (x<P)?M/P/P*(2*P*x-x*x): M/(1-P)/(1-P)*(1 - 2*P + 2*P*x -x*x))
  let(dy = (x<P)?2*M/P/P*(P-x):2*M/(1-P)/(1-P)*(P-x))
  let(th = atan(dy))
  [upper ? x - y*sin(th):x + y*sin(th), upper ? yc + y*cos(th):yc - y*cos(th)];

////////////////////////////////////////////////////
// splines.scad - library for mulivariate splines
// Implementation: Rudolf Huttary (c), Berlin 
//  November 2015
//  commercial use prohibited
//
//  usage scheme - n-dimensional natural cubic spline interpolation 
//    A = [[...],[...],[...]]; // define Mxn matrix, M>2, n>1
//    B = nSplines(A, N);      // get interpolated Nxn matrix
//    C = gen_dat(B);          // interpret data and transform into trajectory
//    sweep(B);                // render 
//
//  for code examples  see: 
//     http://forum.openscad.org/Rendering-fails-difference-between-F5-and-F6-tp15041p15100.html
//     http://forum.openscad.org/general-extrusion-imperfect-tp14740p14752.html
//     knot() example in this file!
//
///// some information functions to measure diameter and bounding box of an interpolated system
//  usage:   
//    B = nSplines(A); 
//    echo(str("outer diam=",Max(Norm(B)))); 
//    echo(str("bounding box=",Box(B))); 


// testcode 
//A = [ 
//  [-4.3,    .57,   .1,  .3],
//  [-.9,     .32,   1,   .4],
//  [1.5,     .07,   .1,  .5],
//  [2.5,    -1.48,  -1,  1.6],
//  [5.6,    -1.68,  -2,  .7],
//  [6.6,     1 ,    1.5, .4],
//  [4.6,    .5 ,    1,   .3],
//  [-1 ,     -2,    1.3, .7],
//  [-5 ,     -2,    1.5, 1.8]
//  ]*10;


//A= [
//[2*x, 0, 0, 1],
//[x+dx, dy, 0, 1],
//[x, 0, 0, 1],
//[x-dx, dy, 0, 1],
//[0, 0, 0, 1],
//[x-dx, -dy, 0, 1],
//[x, 0, 0, 1],
//[x+dx, -dy, 0, 1],
//[2*x, 0, 0, 1],
//]*40;

knot(); 

splines_help();


module knot()
{
// knot
A = [ 
  [-5,    0,   0],
  [-1,    0,   0],
  [-.4,    0,   -.2],
  [.3,    .3,   .2],
  [.2,     -.5,   0],
  [0,     0,   -.5],
  [-.2,     .5,   -0],
  [-.3,    -.3,   .2],
  [.4,    0,   -.2],
  [1,    0,   0],
  [5,    0,   0],
  ]*10;


N = 200; 

nS = nSpline(A,N);   // 4D-Spline rasterized

translate([0,0,20])
//{
//  plot4D(nS);         // 4D-plot, 4th dim is implicit radius
//  plot4D(A, "red"); 
//}
plot3D(col3D(nS), r=2); // 3D-plot, radius explicit
plot3D(col3D(nS), r=2); // 3D-plot, radius explicit
plot3D(col3D(A), r=3, c="red"); 

}

module help() splines_help();

/////////////////////////////////////////////////////////////
// library stuff - modules //////////////////////////////////
module plot3D(A, r=1, c = "yellow")
{ 
  for(i=[0:len(A)-1])
    color(c)
    translate(A[i])
    sphere(r, $fn=30); 
}

module plot4D(A, c = "yellow")
{
  for(i=[0:len(A)-1])
    color(c)
    translate([A[i][0], A[i][1], A[i][2]])
    sphere(A[i][3], $fn=30); 
}

module help () help_splines(); 

module help_splines()
{
  echo("\nModule prototypes:\n
=============\n
  help() - echos help in console
  help_splines() - echos help in console
  plot3D(A, r=1, c = \"yellow\")\n
  plot4D(A, c = \"yellow\")\n\n
  Function prototypes:\n
=============\n
  NxM = nSpline(S, N) - n-dim spline interpolation\n
  t = line_integral(S) - calcs line integral over 3D polygon\n
  coeffs = spline2D(x,y) - caculates coeffs for cubic spline\n
  y = spline2D_eval(coeffs, t, x) - evaluate spline at x\n
  Y = spline2D_rasterize(coeffs, t, N) - \n
  m = Max(A, flat=true) recursive max\n
  m = Min(A, flat=true) recursive min\n
  n = Norm(A) - recursive norm\n
  bb = Box(A) - boundingbox\n
  v = flat3(A, n=0) - flatten structured vector\n 
  
  "
); 
}


/////////////////////////////////////////////////////////////
// spline stuff - functions /////////////////////////////////
function nSpline(S, N) = 
// Rasterizes a PxM-dim vector sequence S into a NxM-dim sequence
// using a multivariate cubic spline interpolation scheme.
// along   a line integral 
// over P-dim polygon cord is used as common x-vector
//  S - is PxM-dim and denotes a seq of M-dim vectors to be
//      used as y-vectors
// returns NxM interpolated M-dim vectors
  let(M=len(S[0]))
  let(t = line_integral(S))
  transpose(
  [for(i=[0:M-1])
    let(C = col(S,i))
    let(coeffs = spline2D(t,C)) 
    (spline2D_rasterize(coeffs, t, N))]);

/////////////////////////////////////////////////////////////
//////// 2D cubic splines - main functions ///////////////// 
function spline2D(x,y) = 
// calculates coeffs of cubic spline segments 
// i.e. all coeffs of eq. systems Ax+Bx+Cx+D = y
//    x,y - paired vectors
//    [A, B, C, D]   returned vector values
  let(MT = eq_sys(x,y))  
  let(b = concat(0, solve_eq(MT[0], MT[1]), 0))
  let(N = len(x)-2) 
  let(dx = [for (i=[0:N])  x[i+1] - x[i]]) 
  let(A  = [for (i=[0:N]) (b[i+1]-b[i])/(3*dx[i])])
  let(C =  [for (i=[0:N]) (y[i+1]-y[i])/dx[i] - (b[i+1]-b[i])*dx[i]/3 - b[i]*dx[i]])
  [A, b, C, y]; 

function spline2D_rasterize(coeffs, t, N) = 
// evaluates a 2D-spline defined by coeffs for the ordered vector t
// at N equidistant points
// returns N vector containing sequence of interpolation values 
  let(T = raster(t,N))
  [for(i=[0:len(T)-1]) spline2D_eval(coeffs, t, T[i])];

function spline2D_eval(coeffs, t, x) = 
// evaluate spline represented by coeffs and t at x
// f(x) returned
    let(i = interval_idx(t,x))
    let(x_ = x-t[i])
    pow(x_,3)*coeffs[0][i]+
    pow(x_,2)*coeffs[1][i]+
           x_*coeffs[2][i]+
             coeffs[3][i] ;

/////////////////////////////////////////////////////////////
///stuff need for solving spline specific equation system ///
function eq_sys(x, y) = 
//transfers value pairs into eq.system M*x=T
//    x,y - paired vectors
//   [M, T] returned vector values with M - symmetric band (m=1) matrix 
//           in sparse lower band Nx2 representation
//   T - right side vector
    let(N = len(x)-3)
    let(T = [for (i=[0:N]) 
      3*((y[i+2]-y[i+1])/(x[i+2]-x[i+1]) - (y[i+1]-y[i])/(x[i+1]-x[i])) ])
    let(M = [for (i=[0:N]) 
      [(i==0)?0:(x[i+1]-x[i]), 2*(x[i+2]-x[i]) ]])
    [M, T]; 

function solve_eq(M,y) = 
// solves eq. system M*x = y, 
// M symmetric band (m=1) matrix, in sparse lower band representation
// uses Cholesky factorization L'*L*x=y
    let(N = len(M)-1)
    let(L = cholesky(M))
    LLx(L,y);
    
function LLx(L,y) =  
// solve L'Lx=y by first solving L'(Lx) = L'x_ = y and then Lx = x_
  let (N = len(y)-1) 
  let (x_ = [ for (i= [0:N]) Lx(i, L, y)]) 
            [ for (i= [0:N]) Lx_(i, N, L, x_)]; 
function Lx(i,L,y) =   (i==0)? y[0]/L[0][1]: (y[i] - Lx(i-1,L,y) * L[i][0])/L[i][1]; 
function Lx_(i,N,L,y) =(i==N)? y[i]/L[i][1]: (y[i] - Lx_(i+1,N,L,y) * L[i+1][0])/L[i][1]; 
    
function cholesky(A) = 
//  Cholesky factorization - applies only to symmetric band (m=1) matrix
// A - matrix to be factorized in sparse lower band representation
// returns Cholesky matrix in sparse lower band representation
    let(N=len(A)-1) 
    [ for(k= [0:N]) 
      let(Lk_ = Lk(A, k))
      [Lk_[0], Lk_[1]]
    ];
function Lk(A,k) = 
// recursive helper of cholesky()
  (k==0)?
    [0, sqrt(A[0][1]), A[0][1]]: 
      let(Lk_0  = (A[k][0] / Lk(A, k-1)[1])) 
      let(Ak_1  = (A[k][1] - Lk_0*Lk_0))
      let(Lk_1  = sqrt(Ak_1))
    [Lk_0, Lk_1, Ak_1];

/////////////////////////////////////////////////////////////
// some more general matrix and vector functions ////////////
function col(S,c=0) = 
// returns column c of matrix S
   [for(i=[0:len(S)-1]) S[i][c]]; 

function col3D(S) =
// returns first 3 columns of matrix S
   let(n=len(S[0])-1)
   [for(i=[0:len(S)-1]) 
     [S[i][0], (n>0)?S[i][1]:0, (n>1)?S[i][2]:0]]; 

function transpose(A) =
  [for(i=[0:len(A[0])-1])
    [for(j=[0:len(A)-1])
      A[j][i]]]; 

function line_integral(S) = let (M = len(S))
// calculates piecewise line integral over S, 
//    S is an ordered sequence of M distinct N-dim vectors
// returns ordered N-sequence of accumulated distances
    [for (i=[0:M-1]) lineT2(S,i)]; 
  
function lineT1(S, i, k) = 
// recursive helper of lineT2()
    let(x=(i==0)?0:S[i][k]-S[i-1][k])
    let(t1 = x*x)
    k==0 ? t1 : t1 + lineT1(S, i, k-1); 
  
function lineT2(S, i) = 
// recursive helper of line_integral()
    let(N = len(S[0]))
    let(x=lineT1(S,i,N-1))
    let(t1  = pow(x, .25)) 
    (i==0)? 0: (i==1) ? t1 : t1 + lineT2(S,i-1); 

function raster(t,N=100) = 
// splits interval covered by ordered vector t 
//    into N equ.dist. intervals
// returns raster as ordered N vector    
   let(d = t[len(t)-1]-t[0])
    [for (i=[0:N-1]) t[0]+i*d/(N-1)]; 

function interval_idx(t, x) = 
// returns index of interval containing real number x
// in ordered interval sequence defined by vector t
   let(N= len(t)-1)
  [for(i=[0:N-1]) 
    if(t[0]>x || (t[i]<=x && (t[i+1])>=x) || i==N-1) i][0];
 
    
// if flat == true 
//    max(vec of ... vec) 
// else
//    vec of (max(vec))
function Max(A, flat=true) = 
    let (m = 
      len(A[0])>1?
         [for(i=[0:len(A)-1]) Max(A[i])]:
          max(A) ) 
       flat?max(m):m; 

////////////////////////////////////////////////////////////////////
///// some information functions to measure diameter and bounding box of an interpolated system
//  usage:   
//    B = nSplines(A); 
//    echo(str("outer diam=",Max(Norm(B)))); 
//    echo(str("bounding box=",Box(B))); 
         
// if flat == true min(vec of ... vec) else vec of (min(vec))
function Max(A, flat=true) = 
    let (m = 
      len(A[0])>1?
         [for(i=[0:len(A)-1]) Max(A[i])]:
          max(A) ) 
       flat?max(m):m; 

// if flat == true max(vec of ... vec) else vec of (max(vec))
function Min(A, flat=true) = 
    let (m = 
      len(A[0])>1?
         [for(i=[0:len(A)-1]) Min(A[i])]:
          min(A) ) 
       flat?min(m):m; 

// norm of vec of vec ... vec3D       
function Norm(A) = 
  let (m = 
    len(A[0])>1?
       [for(i=[0:len(A)-1]) Norm(A[i])]:
        norm(A)) m;  

// calculate bounding box over vec of ... vec3D as [[x,y,z], [X,Y,Z]]

function Box(A) = [ 
    [min(flat3(A,0)), min(flat3(A,1)), min(flat3(A,2))], 
    [max(flat3(A,0)), max(flat3(A,1)), max(flat3(A,2))], 
    ]; 

// flatten  vec of vec of ... vec3D into vec of vec3D
function flat3(A, n=0) = 
      A[0][0][0] ==undef? A[n]:
      [for (i=[0:len(A)-1]) 
        for (j=[0:len(A[i])-1]) 
          flat3(A[i][j], n)];
    

// Mavic pro mini 11/6.6

pitch = 66;  // 66 mm advance per revolution

// A blade is described by matrix M. 
// Each line of M holds 10 parameters characterizing a single
// airfoil slice (rib or frame) and its placement in 3D.
//   Parameters are: naca4(camber, dist, thickness), chord length, translation(x,y,z), rotation(x,y,z)
echo(pa(12)); 
M = [// naca_params, chord, TX,  TY,   TZ    RX, Ry,  RZ
      [ .0, .4, .15,     4,  0,   0,    2,    0,  0,  -0], // ascending pitch
      [ .1, .4, .15,     5,  0,   0,    4,    0,  0,  -10],
      [ .1, .4, .1,     10,  0,   0,   12,    0,  0,  -pa(12)], // from here proper pitch ... 
      [ .1, .4, .1,     11,  0,   0,   18,    0,  0,  -pa(18)],
      [ .1, .4, .061,    5,  0,   0,   53,    0,  0,  -pa(53)],
      [ .1, .4, .06,     2,  0,  .1,   55,    0,  0,  -pa(55)],
    ]; 


CW = true;         // set false for counter clockwise rotation
N = 50;             // # of slices to be interpolated
M_ = nSpline(M, N); // interpolation 

// create blades
sl = false;  // if true, show slices only
n=2;         // number of blades in propeller
forN(0, n)   // rotate 2 objects with radius offset 0
  Sx(CW?1:-1)  // orientation
    Rx(90)       // flip to XY plane
      sweep(gendata(M_), showslices = sl);  // extrude blade along interpolated path


/////////////////////////////////////////////////////////////
// helping functions 

function gendata(M) =  // main function to generate airfoil slices
[ for(i=[0:len(M)-1]) 
  let(N=M[i])
  let(af = Tx(-N[3]/2, vec3(airfoil_data(part(N, 0, 2), L=N[3]))))  // generate polygon for slice
  T(part(N, 4, 6), R(part(N, 7,9), af))]    // place (=rotate + translate) slice in 3D
  ; 

function part(N, start, end) = [for(i=[start:1:end]) N[i]]; // cut vector part
  
function pa(x, pitch=pitch) = atan(pitch/(2*x*PI));  // pitch angle for x [mm]
                ```
                

                Example ID: _15fd3a5c
                Score: 0.617
                Description: I want a blade of propeller
                Code:
                ```scad
                // Propeller Blade Model
// This creates a single aerodynamic propeller blade with airfoil profile
// Parameters can be adjusted to change the blade's size, shape and pitch

/* PARAMETERS */
// Main dimensions
blade_length = 100;     // Length of the blade from hub to tip
blade_chord_root = 25;  // Width of blade at root (near hub)
blade_chord_tip = 15;   // Width of blade at tip
blade_thickness = 3;    // Maximum thickness of the blade

// Airfoil and twist properties
twist_angle = 30;       // Total twist angle from root to tip (degrees)
pitch_angle = 20;       // Base pitch angle (degrees)
camber = 0.06;          // Airfoil camber (curvature)

// Resolution parameters
segments = 30;          // Number of segments along blade length
airfoil_points = 24;    // Points to define airfoil cross-section

/* MODULES */

// NACA-inspired airfoil profile generator
module airfoil_profile(chord, thickness_ratio, camber_ratio, angle) {
    points = [for (i = [0:airfoil_points]) 
        let(
            t = i / airfoil_points,
            x = chord * (1 - cos(t * 180)),
            // Thickness distribution (symmetric part)
            thick = thickness_ratio * chord * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber_ratio * chord * sin(t * 180),
            // Upper and lower surfaces
            upper = [x, yc + thick, 0],
            lower = [x, yc - thick, 0]
        )
        (i <= airfoil_points/2) ? upper : lower
    ];
    
    // Rotate to account for pitch and twist
    rotate([0, 0, angle])
    polygon(points = [for (p = points) [p[0], p[1]]]);
}

// Create a single blade
module propeller_blade() {
    for (i = [0:segments-1]) {
        // Calculate position along blade length
        t = i / (segments - 1);
        z1 = t * blade_length;
        z2 = (i + 1) / (segments - 1) * blade_length;
        
        // Calculate chord at this position (linear taper)
        chord1 = blade_chord_root + t * (blade_chord_tip - blade_chord_root);
        chord2 = blade_chord_root + (i + 1) / (segments - 1) * (blade_chord_tip - blade_chord_root);
        
        // Calculate twist angle at this position (linear twist)
        angle1 = pitch_angle + t * twist_angle;
        angle2 = pitch_angle + (i + 1) / (segments - 1) * twist_angle;
        
        // Calculate thickness ratio (thinner toward tip)
        thickness_ratio1 = blade_thickness / chord1 * (1 - 0.3 * t);
        thickness_ratio2 = blade_thickness / chord2 * (1 - 0.3 * (i + 1) / (segments - 1));
        
        // Create segment by hulling two cross-sections
        hull() {
            translate([0, 0, z1])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness_ratio1, camber, angle1);
                    
            translate([0, 0, z2])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness_ratio2, camber, angle2);
        }
    }
}

// Create blade with root transition
module complete_blade() {
    union() {
        // Main blade
        propeller_blade();
        
        // Root transition to hub (simplified fillet)
        translate([0, 0, 0])
        rotate_extrude(angle = 360)
        polygon([
            [0, 0],
            [0, blade_length * 0.05],
            [blade_chord_root * 0.3, blade_length * 0.02],
            [blade_chord_root * 0.4, 0]
        ]);
    }
}

// Generate the blade
complete_blade();

// Uncomment to see the blade with hub attachment
/*
difference() {
    union() {
        complete_blade();
        // Hub cylinder
        color("gray")
        cylinder(h=10, r=blade_chord_root * 0.5, center=true, $fn=32);
    }
    
    // Hub mounting hole
    color("red")
    cylinder(h=12, r=3, center=true, $fn=32);
}
*/
                ```
                

                Example ID: modular_e6bcb845
                Score: 0.454
                Description: Design of a frame of a drone
                Code:
                ```scad
                module fillet(r=1.0,steps=3,include=true, fn=8) {
  if(include) for (k=[0:$children-1]) {
	children(k);
  }
  for (i=[0:$children-2] ) {
    for(j=[i+1:$children-1] ) {
	fillet_two(r=r,steps=steps, fn=fn) {
	  children(i);
	  children(j);
	  intersection() {
		children(i);
		children(j);
	  }
	}
    }
  }
}

module fillet_two(r=1.0, steps=3, fn=8) {
  for(step=[1:steps]) {
	hull() {
	  render() intersection() {
		children(0);
		offset_3d(r=r*step/steps, fn=fn) children(2);
	  }
	  render() intersection() {
		children(1);
		offset_3d(r=r*(steps-step+1)/steps, fn=fn) children(2);
	  }
	}
  }
}

module offset_3d(r=1.0, fn=8) {
  for(k=[0:$children-1]) minkowski() {
	children(k);
	sphere(r=r,$fn=fn);
  }
}

$fa = 1;
$fs= 0.1;


motor_platform_radius_inside = 25/2;
motor_platform_thickness = 3;
motor_protection_thickness = 2;
motor_protection_height = 14 + motor_platform_thickness - motor_protection_thickness/2;

motor_axis_protection_radius = 5.5/2;
motor_axis_protection_height = 2.3;
motor_platform_radius = motor_platform_radius_inside + motor_protection_thickness;

motor_screw_hole_radius = 2/2;

motor_screw_right_C = 6;
motor_screw_right_A = motor_screw_right_C/sqrt(2);
motor_screw_left_C = 8;
motor_screw_left_A = motor_screw_left_C/sqrt(2);
arm_width = 20;
arm_thickness = 6;
arm_angle = 15;

propeller_radius = 127/2;
propeller_safety_distance = 13;

arm_width_angled = 20;
arm_box_rounding_radius = 10;

motor_platform_rounding_radius = 20;
motor_platform_rounding_triangle_C = motor_platform_radius + motor_platform_rounding_radius;
motor_platform_rounding_triangle_B = arm_width/2 + motor_platform_rounding_radius;
motor_platform_rounding_triangle_A = sqrt(pow(motor_platform_rounding_triangle_C,2)-pow(motor_platform_rounding_triangle_B,2));
motor_platform_rounding_angle = asin(motor_platform_rounding_triangle_A/motor_platform_rounding_triangle_C);
motor_platform_rounding_intersection_X = sin(motor_platform_rounding_angle)*motor_platform_rounding_radius;
motor_platform_rounding_intersection_Y = tan(motor_platform_rounding_angle)*motor_platform_rounding_radius;

motor_platform_Z_rounding_radius = 6;

motor_cable_hole_angle = 12;

motor_cable_hole_triangle_a = arm_thickness - motor_platform_thickness;
motor_cable_hole_triangle_b = motor_cable_hole_triangle_a/tan(motor_cable_hole_angle);
motor_cable_hole_width = 4.5;
motor_cable_hole_height = 3;
motor_cable_hole_relation = motor_cable_hole_height/motor_cable_hole_width;
motor_cable_hole_start = motor_platform_radius_inside + motor_cable_hole_triangle_b;


motor_distance_front_back = propeller_radius*2+propeller_safety_distance*2;

box_wall_thickness = 2;
box_wall_height = 24.2;
box_bottom_thickness = 4;
box_length = motor_distance_front_back + motor_platform_radius*2;
echo("box_length = ", box_length);

flight_controller_slot_depth = 1.5;
flight_controller_size = 36;

sonar_center_distance = -70.8;
sonar_platform_height = 12;
sonar_platform_width = 45.3;
sonar_platform_length = 20.3;
sonar_hole_radius = 16 / 2;
sonar_hole_distance = 9.65;

box_width = max(flight_controller_size, sonar_platform_width) + 2*box_wall_thickness;
motor_distance_left_right = box_width + propeller_radius*2 + propeller_safety_distance*2;

box_front_add = box_width/2 - 9.5;
box_front_add_diff = box_width/2 - box_front_add;
box_front_rounding_center = box_front_add_diff - box_length/2;


arm_length = (motor_distance_left_right/2) / cos(arm_angle);

esc_cable_hole_width = 3;
esc_cable_hole_height = 1.2;
esc_cable_hole_relation = esc_cable_hole_height/esc_cable_hole_width;
motor_center_esc_hole_distance = ((motor_distance_left_right - box_width +box_wall_thickness)/2);
box_cable_hole_intersection = motor_distance_front_back/2 - motor_center_esc_hole_distance * tan(arm_angle);

fpv_cam_thread_radius = 11.86/2;
fpv_cam_thread_height = 16;
fpv_cam_board_floor_thickness = 2;
fpv_cam_board_width = 33;
fpv_cam_board_thickness = 5;
fpv_cam_board_thread_distance = 16;

openlog_wall1_a = 1.5;
openlog_wall1_b = 2;
openlog_wall1_from_corner = 19.3;

openlog_wall2_from_corner = 5;
openlog_wall2_a = 22;
openlog_wall2_b = 2;
openlog_wall2_height = box_bottom_thickness + 8;
openlog_wall2_rounding_radius = 3;

openlog_slot_thickness = 1.1;
openlog_slot_height = 11.4;
openlog_slot_from_floor = 0.8;

gps_tower_radius_outside = 10.2/2;
gps_tower_radius_inside = 7.9/2;
gps_tower_height = 10;
gps_tower_outside_holder = 4;
gps_tower_center_distance = 48;

module arm_2D() {
    translate([0,-arm_width/2]) square([arm_length,arm_width]);

    // rounding between motor platform and arm
    difference() {
        translate([motor_platform_rounding_triangle_A-motor_platform_rounding_intersection_X,-motor_platform_rounding_triangle_B]) square([motor_platform_rounding_intersection_X,arm_width+motor_platform_rounding_radius*2]);
        
        translate([motor_platform_rounding_triangle_A,motor_platform_rounding_triangle_B]) circle(r=motor_platform_rounding_radius);
        translate([motor_platform_rounding_triangle_A,-motor_platform_rounding_triangle_B,-0.1]) circle(r=motor_platform_rounding_radius);
    }
}

module motor_platform() {
    difference() {
        cylinder(r=motor_platform_radius, h=motor_platform_thickness);
        
        // axis protection
        translate([0,0,motor_platform_thickness-motor_axis_protection_height]) cylinder(r=motor_axis_protection_radius, h=motor_axis_protection_height+0.1);

        // screw holes
        translate([motor_screw_right_A,motor_screw_right_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([-motor_screw_right_A,-motor_screw_right_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([motor_screw_left_A,-motor_screw_left_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
        translate([-motor_screw_left_A,motor_screw_left_A,-0.1]) cylinder(r=motor_screw_hole_radius, h=motor_platform_thickness+0.2);
    }
    
}

module motor_protection() {
    
    difference() {
        cylinder(r=motor_platform_radius, h=motor_protection_height);
            translate([0,0,-0.1])
        cylinder(r=motor_platform_radius_inside, h=motor_protection_height+0.2);
    }
    translate([0,0,motor_protection_height])
    rotate_extrude()
    translate([motor_platform_radius_inside+motor_protection_thickness/2,0,0]) 
    circle(r=motor_protection_thickness/2);
    
    translate([0,0,arm_thickness])
    intersection() {
        linear_extrude(height=motor_platform_Z_rounding_radius+1) arm_2D();
        rotate_extrude()
        translate([motor_platform_radius, 0, 0])
        difference() {
            square([motor_platform_Z_rounding_radius,motor_platform_Z_rounding_radius]);
            translate([motor_platform_Z_rounding_radius,motor_platform_Z_rounding_radius])
            circle(r = motor_platform_Z_rounding_radius);
        }
    }
}

module simple_arm() {
    translate([motor_platform_radius*2,-arm_width/2]) cube([arm_length-motor_platform_radius*2,arm_width,arm_thickness]);
}

module complete_arm() {
    
    difference() {
        union() {
            motor_protection();
            difference() {
                linear_extrude(height=arm_thickness) arm_2D();
                //subtract the space of the motor_platform from the arm
                translate([0,0,-0.1]) cylinder(r=motor_platform_radius_inside, h=motor_protection_height);
            }
        }
        
        translate([motor_cable_hole_start,0,arm_thickness])
        rotate([0,-1*(motor_cable_hole_angle+90),0])
        translate([motor_cable_hole_height,0,0])
        scale([motor_cable_hole_relation,1,1])
        cylinder(r=motor_cable_hole_width,h=motor_cable_hole_triangle_b+motor_platform_radius); 
    }
    motor_platform();
}

module box_arm_fillet() { 
    translate([0,0,box_wall_height/2]) cube([box_width,box_length-box_front_add_diff*2,box_wall_height], center=true);
    translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) simple_arm();
}

module placed_arm() {
    translate([-motor_distance_left_right/2,-motor_distance_front_back/2,0]) rotate([0,0,arm_angle]) complete_arm();
}

module placed_esc_to_fc_hole() {
    translate([box_width/2-box_wall_thickness,box_cable_hole_intersection,box_bottom_thickness])
    rotate([0,90-15,arm_angle])
    difference() {
        c = esc_cable_hole_width*2 / cos(arm_angle);
        b = sin(arm_angle) * c;
        
        scale([esc_cable_hole_relation,1,1])
        translate([-esc_cable_hole_width,0,-b/2])
        cylinder(r=esc_cable_hole_width, h=arm_length/3);
        
        rotate([arm_angle,0,0])
        translate([-esc_cable_hole_height*2-1,-c/2,-b])
        cube([esc_cable_hole_height*2+2,c,b]);
    }
}

module box_with_arms() difference() {
    union() {
        translate([0,box_front_add_diff/2,box_wall_height/2]) cube([box_width,box_length-box_front_add_diff,box_wall_height], center=true);
        box_arm_fillet();
        mirror([0,1,0]) box_arm_fillet();
        mirror([1,0,0]) box_arm_fillet();
        mirror([0,1,0]) mirror([1,0,0]) box_arm_fillet();
        placed_arm();
        mirror([0,1,0]) placed_arm();
        mirror([1,0,0]) placed_arm();
        mirror([0,1,0]) mirror([1,0,0]) placed_arm();
        
        //rounding in front for fpv camera
        translate([0,box_front_rounding_center,0]) cylinder(r=box_width/2, h= box_wall_height);
    }
    
    //make the box hollow, leave a wall with box_wall_thickness
    translate([0,-box_wall_thickness/2+box_front_add_diff/2,box_wall_height/2+box_bottom_thickness]) cube([box_width-box_wall_thickness*2,box_length-box_wall_thickness-box_front_add_diff,box_wall_height], center=true);
    
    translate([0,box_front_rounding_center,box_bottom_thickness]) cylinder(r=box_width/2-box_wall_thickness, h= box_wall_height);
    
    // holes in the box for cables from ESC to flightcontroller
    placed_esc_to_fc_hole();
    mirror([0,1,0]) placed_esc_to_fc_hole();
    mirror([1,0,0]) placed_esc_to_fc_hole();
    mirror([0,1,0]) mirror([1,0,0]) placed_esc_to_fc_hole();
}

module gps_tower() {
    cylinder(r = gps_tower_radius_inside, h = gps_tower_height);
    translate([0,0,gps_tower_height])
    sphere(r = gps_tower_radius_inside);

    rotate_extrude()
    translate([gps_tower_radius_outside, 0, 0])
    difference() {
        square([gps_tower_outside_holder,gps_tower_outside_holder]);
        translate([gps_tower_outside_holder,gps_tower_outside_holder])
        circle(r = gps_tower_outside_holder);
    }
}

module box_with_all_adds() {
    box_with_arms();
    
    //sonar platform
translate([0,sonar_center_distance,sonar_platform_height/2])
cube([box_width-box_wall_thickness*2,sonar_platform_length,sonar_platform_height], center=true);
    
    //openlog wall1
    translate([-box_width/2+box_wall_thickness,box_length/2-box_wall_thickness-openlog_wall1_from_corner-openlog_wall1_a,0])
    cube([openlog_wall1_b,openlog_wall1_a,box_wall_height]);
    
    //openlog wall2
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner,box_length/2-box_wall_thickness-openlog_wall2_a,0])
    cube([openlog_wall2_b,openlog_wall2_a,openlog_wall2_height]);

    //openlog wall2 rounding
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner+openlog_wall2_b,box_length/2-box_wall_thickness-openlog_wall2_rounding_radius,0])
    difference() {
        cube([openlog_wall2_rounding_radius,openlog_wall2_rounding_radius,openlog_wall2_height]);
        translate([openlog_wall2_rounding_radius,0,0])
        cylinder(r = openlog_wall2_rounding_radius, h = openlog_wall2_height+1);
    }
    
    //gps tower
    translate([0,-gps_tower_center_distance,box_bottom_thickness])
    gps_tower();
}

module quad_with_slots() difference() {
    box_with_all_adds();
    
    //sonar holes
    translate([sonar_hole_radius+sonar_hole_distance/2,sonar_center_distance,0])
    cylinder(r=sonar_hole_radius, h=39.229+1, center=true);
    translate([-sonar_hole_radius-sonar_hole_distance/2,sonar_center_distance,0])
    cylinder(r=sonar_hole_radius, h=39.229+1, center=true);
    
    //slit through sonar platform for camera cable
    translate([0,sonar_center_distance,sonar_platform_height/2+box_bottom_thickness+1])
    cube([11,sonar_platform_length+2,sonar_platform_height+2], center=true);
    
    //openlog_micro_sd_card_slot
    translate([-box_width/2+box_wall_thickness+openlog_wall2_from_corner-openlog_slot_thickness,box_length/2-box_wall_thickness-1,box_bottom_thickness+openlog_slot_from_floor])
    cube([openlog_slot_thickness,box_wall_thickness+2,openlog_slot_height]);
    
    //flight controller slot
    translate([0,0,box_bottom_thickness+(flight_controller_slot_depth+1)/2-flight_controller_slot_depth])
    cube([flight_controller_size,flight_controller_size,(flight_controller_slot_depth+1)], center=true);
    
    //fpv cam thread mount
    translate([0,-box_length/2,fpv_cam_thread_radius+fpv_cam_thread_height+fpv_cam_board_floor_thickness])
    rotate([90,0,0]) cylinder(r=fpv_cam_thread_radius, h=20);
    //fpv board slot
    translate([-fpv_cam_board_width/2,-box_length/2-box_front_add+fpv_cam_board_thread_distance,fpv_cam_board_floor_thickness]) cube([fpv_cam_board_width,fpv_cam_board_thickness,10]);
}

module sonar_platform() difference() {
    cube([box_width-box_wall_thickness*2,sonar_platform_length,sonar_platform_height], center=true);

}
quad_with_slots();
                ```
                

                Example ID: unknown_7ae6d851
                Score: 0.480
                Description: I want a blade of a drone propeller
                Code:
                ```scad
                //pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 12;

//Resolution steps between stations
SectRes = 10;  

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Spinner hinge radius at pin
SpinHPinRad = 34;

//Diameter of hinge pin
SpinPinD = 3;

//Blade base diameter
SpinHubD = 6;

//Spinner hinge width
SpinHL = 7;

//Hinge Pin Height Adjuster
SpinHubVTweak = 0.25;

//Holder variables for calculated Blade section parameters.  Ignore these.
Poz1 =0;
Poz2 = 0;
StrtAngi = 0;
EndAngi = 0;
StepLi = 0;
StrtWi = 0;
EndWi = 0; 


// Blade airfoil profile. Change with caution.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];


function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

StubSteps = (Diam/(16*SectL)>SpinHPinRad*1.2)?round(Diam/(16*SectL)):round(SpinHubD*1.1/SectL);

BldStubLn = 0.98*StubSteps * SectL; 
BldStrtPoint = round((SpinHPinRad+BldStubLn+0.5*SpinHubD)/SectL)-1;

function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
    rotate([0,90,0])
    cylinder (r =0.5*SpinHubD, h = SpinHL, center = true, $fn = 100);
}



module Hubcutter()
{
    union()
    {
        // Pin hole
        translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r = 0.5*SpinPinD, h = SpinHL*4, center = true, $fn = 100);
        
        //The two face shavers
        translate([1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 0.6*SpinHubD, r2 = 2.5*SpinHubD, h = SpinHL*2, center = true, $fn = 100);
        
        translate([-1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 5*SpinHubD, r2 = 0.6*SpinHubD, h = SpinHL*2, center = true, $fn = 100);        

    }
}


module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    union()
    {
    for(i = [BldStrtPoint:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module Hinge()
{
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*(SpinHPinRad+BldStubLn+0.5*SpinHubD)/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        EndAngi = atan(Pitch/(2*PI*(SpinHPinRad+BldStubLn+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+BldStubLn+0.5*SpinHubD);
        StrtAngi = atan(Pitch/(2*PI*(SpinHPinRad+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+0.5*SpinHubD);
        

            translate([0,-SpinHPinRad-0.5*SpinHubD,0])        
            rotate([90,0,0])
            Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);

    }
}


translate([0,SpinHPinRad,0])
difference()
{
    union()
    {
        Hinge();
        rotate([90,0,0])BladeBuilder();
    }
    Hubcutter();
}
                ```
                

                Example ID: modular_d8a808a0
                Score: 0.440
                Description: drone propeller with roter_twist value from -25 to -20 to maintain a more aggressive blade angle at the outer edge of the prop.
                Code:
                ```scad
                module airfoil() {

	m = camber_max/100;
	p = camber_position/10;
	t = thickness/100;
	
	pts = 25; // datapoints on each of upper and lower surfaces
	
	function xx(i) = 1 - cos((i-1)*90/(pts-1));
	function yt(i) = t/0.2*(0.2969*pow(xx(i),0.5) - 0.126*xx(i)-0.3516*pow(xx(i),2) + 0.2843*pow(xx(i),3) - 0.1015*pow(xx(i),4));
	function yc(i) = xx(i)<p ? m/pow(p,2)*(2*p*xx(i) - pow(xx(i),2)) : m/pow(1-p,2)*(1 - 2*p + 2*p*xx(i) - pow(xx(i),2));
	function xu(j) = xx(j) - yt(j)*(sin(atan((yc(j)-yc(j-1))/(xx(j)-xx(j-1)))));
	function yu(j) = yc(j) + yt(j)*(cos(atan((yc(j)-yc(j-1))/(xx(j)-xx(j-1)))));
	function xl(j) = xx(j) + yt(j)*(sin(atan((yc(j)-yc(j-1))/(xx(j)-xx(j-1)))));
	function yl(j) = yc(j) - yt(j)*(cos(atan((yc(j)-yc(j-1))/(xx(j)-xx(j-1)))));

	polygon( points=[ 
 	// upper side front-to-back
	[0,0],[xu(2),yu(2)],[xu(3),yu(3)],[xu(4),yu(4)],[xu(5),yu(5)],[xu(6),yu(6)],[xu(7),yu(7)],[xu(8),yu(8)],[xu(9),yu(9)],[xu(10),yu(10)],[xu(11),yu(11)],[xu(12),yu(12)],[xu(13),yu(13)],[xu(14),yu(14)],[xu(15),yu(15)],[xu(16),yu(16)],[xu(17),yu(17)],[xu(18),yu(18)],[xu(19),yu(19)],[xu(20),yu(20)],[xu(21),yu(21)],[xu(22),yu(22)],[xu(23),yu(23)],[xu(24),yu(24)],[xu(25),yu(25)],
	// lower side back to front
	[xl(25),yl(25)],[xl(24),yl(24)],[xl(23),yl(23)],[xl(22),yl(22)],[xl(21),yl(21)],[xl(20),yl(20)],[xl(19),yl(19)],[xl(18),yl(18)],[xl(17),yl(17)],[xl(16),yl(16)],[xl(15),yl(15)],[xl(14),yl(14)],[xl(13),yl(13)],[xl(12),yl(12)],[xl(11),yl(11)],[xl(10),yl(10)],[xl(9),yl(9)],[xl(8),yl(8)],[xl(7),yl(7)],[xl(6),yl(6)],[xl(5),yl(5)],[xl(4),yl(4)],[xl(3),yl(3)],[xl(2),yl(2)],
	] ); 
}

// standard ellipse formula: 
// plot for minor points ( faster )
function ellipse(x)  = sqrt( (1 - pow( x, 2 )/pow(ellipse_minor,2)) * pow(ellipse_major,2) );

// plot for major points ( more points) 
function ellipse2(y,e_major,e_minor) = sqrt((1 - pow(y,2)/pow(e_major,2)) * pow(e_minor,2));

module eliptical_wing(e_major, e_minor, e_chord, e_twist) {
	for( n = [1:e_major*ellipse_split] ) {
		translate([n/ellipse_split,-ellipse2(n/ellipse_split,e_major,e_minor)*e_chord ,0]) {   
			scale([0.5,ellipse2(n/ellipse_split,e_major,e_minor)*2,ellipse2(n/ellipse_split,e_major,e_minor)*2]) {
				rotate ( [ 90,0,90 ] ) {
					// 2D to 3D as linear extrusion 
					rotate([0,0,-n*e_twist/(e_major*ellipse_split)])
					linear_extrude(height=0.1,twist = e_twist/(e_major*ellipse_split))  airfoil();    
				} 
			}
		}
	} 
}
module eliptical_wing_r(e_major, e_minor, e_chord, e_twist) {
	for( n = [1:e_major*ellipse_split] ) {
		translate([-n/ellipse_split,-ellipse2(n/ellipse_split,e_major,e_minor)*e_chord ,0]) {   
			scale([1.25,ellipse2(n/ellipse_split,e_major,e_minor)*2,ellipse2(n/ellipse_split,e_major,e_minor)*2]) {   // wing length, chord , and height  ( chord and height should be the same ) 
				rotate ( [ 90,0,90 ] ) {
					// 2D to 3D as linear extrusion 
					rotate([0,0,-n*e_twist/(e_major*ellipse_split)])
					linear_extrude(height=0.1,twist = -e_twist/(e_major*ellipse_split))  airfoil();    
				} 
			}
		}
	} 
}
module straight_wing(s_length, s_base, e_twist) {

	translate([0,-s_base/3,0])rotate ( [ 90,0,90 ] ) {
		linear_extrude(height = s_length, center = false, convexity = 100, twist = e_twist)
		scale(s_base)
		airfoil(); 
	}
}
module straight_wing_r(s_length, s_base, e_twist) {
	translate([-s_length,-s_base/3,0])rotate ( [ 90,e_twist,90 ] ) {
		linear_extrude(height = s_length, center = false, convexity = 100, twist = -e_twist)
		scale(s_base)
		airfoil(); 
	}
}

module on_arc(radius, angle) {
    x = radius - radius * cos(angle);
    y = radius * sin(angle);
    translate([x,y,0])
        rotate([0,0,-angle])
            child(0);
}
module roundedBox(size, radius, sidesonly){
	rot = [ [0,0,0], [90,0,90], [90,90,0] ];
	if (sidesonly) {
		cube(size - [2*radius,0,0], true);
		cube(size - [0,2*radius,0], true);
		for (x = [radius-size[0]/2, -radius+size[0]/2],
				 y = [radius-size[1]/2, -radius+size[1]/2]) {
			translate([x,y,0]) cylinder(r=radius, h=size[2], center=true,$fn=32);
		}
	}
	else {
		cube([size[0], size[1]-radius*2, size[2]-radius*2], center=true);
		cube([size[0]-radius*2, size[1], size[2]-radius*2], center=true);
		cube([size[0]-radius*2, size[1]-radius*2, size[2]], center=true);

		for (axis = [0:2]) {
			for (x = [radius-size[axis]/2, -radius+size[axis]/2],
					y = [radius-size[(axis+1)%3]/2, -radius+size[(axis+1)%3]/2]) {
				rotate(rot[axis]) 
					translate([x,y,0]) 
					cylinder(h=size[(axis+2)%3]-2*radius, r=radius, center=true,$fn=32);
			}
		}
		for (x = [radius-size[0]/2, -radius+size[0]/2],
				y = [radius-size[1]/2, -radius+size[1]/2],
				z = [radius-size[2]/2, -radius+size[2]/2]) {
			translate([x,y,z]) sphere(radius);
		}
	}
}


///////////////////////////////////////////////////////////////////////
//** Setting Section
///////////////////////////////////////////////////////////////////////

//NACA4 airfoil DATA
camber_max = 8;
camber_position = 4;
thickness = 12;

// wing basic sizing  ( affects both eliptical and straight wings ) 
length = 55;
basewidth = 15;

roter_angle = -30;
roter_twist = -20;
roter_number = 2;

roter_ring_tic = 0.75;

// cone sizing
cone_height = 0;

// hub sizing
hub_outer = 18;
hub_height = 8;
hub_offset = -1;

shaft_hole = 5.1;

// extra eliptical wing  sizing: 
ellipse_major = length;
ellipse_minor = basewidth/2;
ellipse_chord = 2/3;
ellipse_split = 2;

// the chord value : 
//  1 gives fully eliptical wing front and rear ,   
//  2/3 gives spitfire style eliptical wings ( more curve on back edge) 
//  1/3 gives nearly straight front, and heavily curved back edge 
//  0.0 gives straight-fronted wing 

// Rotor Type
straight = 1;
roter_ring = 0;
clockwise = 0;// clockwise:1 anticlockwise:1

///////////////////////////////////////////////////////////////////////
//** Main
///////////////////////////////////////////////////////////////////////
$fn=256;

difference(){
	union(){
		// a simple straight wings
		for(a = [0 : 360/roter_number : 360]) {
			mirror([clockwise,0,0]) //anticlockwise
			intersection(){
				// straight_wing
				on_arc(0, a)
					translate([0,-basewidth/6,0])rotate([roter_angle,0,0])
					straight_wing(length, basewidth, roter_twist);
					
				// wing_tip_cutting
				if (straight == 1 && roter_ring == 0 ){
					on_arc(0, a)
					translate([length/2,basewidth/6,0])
						rotate([-roter_angle,0,0])
					roundedBox([length, basewidth, basewidth*3], basewidth/3, true);
				}
			}
			// rotor ring
			if (straight == 1 && roter_ring == 1 ){
				// roter_ring
				translate ([0,0,hub_height/2])
				difference(){
					cylinder(h = hub_height*2, r=length+roter_ring_tic, center = true, $fn=256);
					cylinder(h = hub_height*3, r=length, center = true, $fn=256);
				}
			}
		}
		// cone (not needed)
//		translate ([0, 0, hub_height/2+hub_offset])scale([1, 1, cone_height/hub_outer]) difference() {
//			sphere(r=hub_outer/2, $fn=60);
//			translate ([0, 0, -hub_outer/2])
//				cube(size=[2*hub_outer, 2*hub_outer, hub_outer], center=true);
//		}
		// center hub
		translate ([0, 0, hub_offset])
		cylinder (h = hub_height, r=hub_outer/2, center = true, $fn=100);
	}
// shaft hole and resess
	translate ([0, 0, -hub_height/4+hub_offset])
		cylinder (h = hub_height*2, r=shaft_hole/2, center = true, $fn=100);
translate ([0, 0, hub_height+3])
		cylinder (h = 20, r=7, center = true, $fn=100);
}
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Aerodynamic efficiency - propeller design must maximize thrust while minimizing drag
- Structural integrity - must withstand high rotational forces and mechanical stress
- Material selection - balance between weight, strength, and manufacturability
- Balanced design - proper weight distribution to prevent vibration during operation
- Pitch angle optimization - determines lift efficiency and power consumption
- Scale appropriateness - dimensions must match intended drone size and power requirements
- Code Structure: module structure
- Code Structure: algorithms for aerodynamics and stress analysis
- Implementation Technique: union
- Implementation Technique: minkowski
- Implementation Technique: scale
- Implementation Technique: mirror
- Implementation Technique: rotate
- Implementation Technique: extrude
                    
                    SHAPE COMPONENTS:
                    - Hub/mounting hole - central connection point to the motor shaft
- Blade root - thicker section where blade connects to hub for structural strength
- Airfoil profile - cross-sectional shape that generates lift
- Leading edge - front edge that first contacts airflow
- Trailing edge - thin back edge where airflow exits
- Blade tip - optimized end section to reduce vortex formation and noise
- Twist gradient - progressive angle change from hub to tip for consistent lift
                    
                    IMPLEMENTATION STEPS:
                    1. Determine specifications based on drone requirements (size, weight, motor RPM)
2. Create the hub with appropriate mounting hole diameter (typically 1.5-5mm)
3. Design the basic airfoil profile considering lift-to-drag ratio
4. Extrude the airfoil along a path to create the basic blade shape
5. Apply twist gradient from hub to tip (higher angle at hub, lower at tip)
6. Mirror the blade to create the second blade (for bi-blade design)
7. Add fillets at blade roots to reduce stress concentration
8. Verify balance by checking center of mass
9. Optimize for 3D printing by ensuring minimal support requirements
10. Test structural integrity through simulation before production

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "mechanical" type. Here's a suggested structure:
                
                ```scad
                
        module drone propeller(height=10, width=20, depth=15, wall_thickness=2) {
            union() {
                // Base shape based on: Hub/mounting hole - central connection point to the motor shaft, Blade root - thicker section where blade connects to hub for structural strength, Airfoil profile - cross-sectional shape that generates lift, Leading edge - front edge that first contacts airflow, Trailing edge - thin back edge where airflow exits, Blade tip - optimized end section to reduce vortex formation and noise, Twist gradient - progressive angle change from hub to tip for consistent lift
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
num_blades = 4; // Number of propeller blades
diameter = 9; // Propeller diameter in inches
pitch = 4.5; // Propeller pitch in inches (affects angle and lift)
hub_radius = 10; // Radius of the central hub in mm
shaft_radius = 3; // Radius of the center shaft hole in mm
blade_thickness = 1.2; // Maximum thickness of the blade in millimeters (affects strength and weight)
twist_angle = 30; // Twist angle from root to tip in degrees
airfoil_camber = 0.06; // Airfoil camber ratio (affects blade curvature)
prop_diameter = 5.0; // Total diameter of the propeller in inches (common drone sizes range from 3-9 inches)
hub_diameter = 10.0; // Diameter of the center hub in millimeters
mounting_hole_diameter = 3.0; // Diameter of the center mounting hole in millimeters (to connect to motor shaft)
blade_count = 2; // Number of propeller blades (typically 2-3 for drones)
pitch_angle = 8.0; // Blade pitch angle in degrees, affects thrust and efficiency


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: 65mm Bi-Blade Propeller - Download Free 3D model by The Van ...
Content: A 65mm press-fit propeller made for FPV drones modeled in Fusion 360, textured in Substance Painter. License: CC Attribution Creative Commons Attribution.
---

Title: Assembly procedures of propeller: (a) fabricate the 3D printed...
Content: Assembly procedures of propeller: (a) fabricate the 3D printed components for building a propeller assembly , (b) assemble the BLDC motor and the propeller
---

Title: [PDF] Design of Multi Material Drone Propeller - IIETA
Content: Multi-material plan has acquired consideration in designing ... The main purpose is to extend drones flight time and enhance their propulsion
---

Title: 3D printed drone propellers - Weerg
Content: The use of materials such as versatile resin and PA11 nylon allows for the experimentation of propeller configurations that would be complex or
---

Title: RC Drone Propeller - 3D Model by 3dsldworks
Content: RC drone propeller dimensions: Main diameter - 1.5 Inch (40mm) , Hole diameter - 1.5mm, Height - 0.2 inch (6.3mm). More by 3dsldworks  Bionic
---


USER REQUEST:
aerodynamic efficiency propeller design structural integrity material selection balanced design pitch angle optimization scale appropriateness

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================



================================================================================
PROMPT FOR: I want a propeller of a qudacopter
================================================================================

You are an expert in OpenSCAD 3D modeling. Your task is to generate OpenSCAD code based on the user's description.

BASIC KNOWLEDGE:

OpenSCAD is a 3D modeling tool that uses a scripting language to create 3D objects. Here are some basic concepts:

Basic shapes (3D):
1. cube(size = [x,y,z], center = true/false); - Creates a rectangular prism
2. sphere(r=radius); - Creates a sphere
3. cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false); - Creates a cylinder
4. polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); - Creates complex shapes

Transformations:
1. translate([x,y,z]) - Moves object
2. rotate(a = deg_a, v = [x, y, z]) - Rotates object (degrees)
3. scale([x,y,z]) - Scales object
4. resize([x,y,z],auto,convexity) - Modifies the size of the child object to match the given x,y,z.
5. mirror([x,y,z]) - Creates a mirror image of a child element across a specified plane
6. multmatrix(m) - Multiplies the geometry of all child elements with the given affine transformation matrix
7. offset(r|delta,chamfer) - generates a new 2d interior or exterior outline from an existing outline
8. hull() - Displays the convex hull of child nodes.
9. minkowski(convexity) - Creates a minkowski sum of child nodes.

Boolean operations:
1. union() - Combines objects
2. difference() - Subtracts second object from first
3. intersection() - Shows overlap between objects

Basic Syntax:
1. Variables: var = value; (e.g., radius = 10;)
2. Comments: // Single line comment, /* Multi-line comment */
3. Mathematical Operators: +, -, *, /, %, ^
4. Comparison Operators: ==, !=, <, <=, >, >=
5. Logical Operators: &&, ||, !
6. Conditional Statement: if (condition) { ... } else { ... }
7. Loops:
- for (i = [start:step:end]) { ... }
- for (i = [value1, value2, ...]) { ... }
8. Modules:
- Define: module name(parameters) { ... }
- Call: name(parameters);
9. Functions:
- Define: function name(parameters) = expression;
- Call: name(parameters)
10. Echo Command: echo("text", variable);
11. Children: Using $children and children() for module composition

Templates:
The system provides templates for common object types:
- container: For hollow objects with inner space
- mechanical: For objects with moving or functional parts
- furniture: For chairs, tables, and other furniture pieces
- decorative: For artistic and decorative objects
- tableware: For plates, cups, and other food-related items
- architectural: For building and structural elements
- organizer: For storage and organizing objects
- electronic: For device cases and holders
- instrument: For tools and functional instruments
- jewelry: For decorative wearable items
- utility: For practical everyday objects
- toy: For playful and recreational items
- enclosure: For cases with lids or covers
- fixture: For mounting and attachment components 
- modular: For systems with interchangeable parts

You can use these templates by calling the appropriate module template.


RELEVANT EXAMPLES:

                Example ID: _0c41abcf
                Score: 0.591
                Description: I want a propeller
                Code:
                ```scad
                // Propeller Design
// Customizable parameters
$fn = 100;  // Resolution for circular objects

// Main parameters
num_blades = 3;         // Number of propeller blades
hub_radius = 10;        // Radius of central hub
hub_height = 15;        // Height of central hub
shaft_radius = 3;       // Radius of shaft hole
blade_length = 50;      // Length of each blade
blade_width = 15;       // Maximum width of blade
blade_thickness = 3;    // Maximum thickness at blade root
twist_angle = 30;       // Twist angle from root to tip (degrees)
airfoil_camber = 0.1;   // Camber ratio for airfoil shape

// Module for creating a single propeller blade with twist and airfoil profile
module blade() {
    linear_extrude(height = blade_length, twist = -twist_angle, slices = 40, scale = 0.5) {
        union() {
            // Airfoil shape
            translate([-blade_width/4, 0, 0])
                scale([1, blade_thickness/blade_width, 1])
                    ellipse(blade_width/2, blade_width/2);
                
            // Add slight camber for improved aerodynamics
            translate([0, -blade_thickness * airfoil_camber, 0])
                scale([0.8, 0.2, 1])
                    circle(blade_width/2);
        }
    }
}

// Module for creating an ellipse
module ellipse(width, height) {
    scale([width, height, 1]) circle(1);
}

// Module for creating the central hub with shaft hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(r1 = hub_radius, r2 = hub_radius * 0.8, h = hub_height);
            
            // Hub base (for strength)
            cylinder(r = hub_radius * 1.2, h = hub_height * 0.2);
            
            // Hub top cap
            translate([0, 0, hub_height])
                cylinder(r1 = hub_radius * 0.8, r2 = hub_radius * 0.5, h = hub_height * 0.2);
        }
        
        // Shaft hole through center
        translate([0, 0, -1])
            cylinder(r = shaft_radius, h = hub_height + 2);
            
        // Setscrew hole
        translate([0, 0, hub_height/2])
            rotate([0, 90, 0])
                cylinder(r = shaft_radius/2, h = hub_radius + 1);
    }
}

// Assemble the propeller
module propeller() {
    // Central hub
    color("SlateGray") hub();
    
    // Blades
    color("LightSteelBlue")
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades])
            translate([hub_radius * 0.8, 0, hub_height * 0.6])
                rotate([0, 90, 0])
                    blade();
    }
}

// Create the propeller
propeller();
                ```
                

                Example ID: unknown_301fdbd5
                Score: 0.539
                Description: Propeller for a whirligig
                Code:
                ```scad
                $fn=180;
Off_ang=-20;
//30mm_bearing cut out
difference(){	union(){
					propeller(5);
						translate([0,0,25])
							scale([1,1,.45])
					hub(20);}
	translate([0,0,-20])
		cylinder(h=30,r=15);}
 module hub(ra){
	 translate([0,0,-55])
		cylinder(h=40,r=ra);
	 	 translate([0,0,-15])
			scale([1,1,.8])
				sphere(ra);}
module propeller(x){
	rotate([-90,0,0])
		for(i=[1:360/x:360])
			rotate([0,i,0])	prop();}
module prop(){
	 scale([.5,1,1])
		translate([0,-11,10])
			intersection(){
				linear_extrude(230,twist=40,scale=.15){
					scale([3,1]) circle(10);}
						translate([0,3,0])
							rotate([0,5,Off_ang])
								scale([.5,.2,3])
									sphere(40);}}
                ```
                

                Example ID: modern_d16f0c88
                Score: 0.564
                Description: I want a drone propeller
                Code:
                ```scad
                // Aerodynamic Drone Propeller
// Parametric design with optimized airfoil profile and balanced structure

/* CUSTOMIZABLE PARAMETERS */
// Basic dimensions
prop_diameter = 100;    // Propeller diameter (mm)
hub_diameter = 10;      // Hub diameter (mm)
hub_height = 8;         // Hub height (mm)
num_blades = 3;         // Number of blades
shaft_diameter = 5;     // Motor shaft diameter (mm)

// Blade parameters
blade_chord_root = 15;  // Width at blade root (mm)
blade_chord_tip = 6;    // Width at blade tip (mm)
blade_max_thickness = 2;// Maximum thickness (mm)
pitch_angle = 25;       // Base pitch angle (degrees)
twist_angle = 15;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.04;  // Airfoil camber (0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.8; // Controls how quickly the blade tapers (0.5-1.0)
lift_efficiency = 1.2;  // Multiplier for lift curvature shape (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution
blade_segments = 20;    // Number of segments along blade length
airfoil_resolution = 24;// Points in airfoil cross-section

/* DERIVED VARIABLES */
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

/* MODULES */

// Airfoil profile generator
module airfoil_section(chord, thickness, camber, angle) {
    // Create upper and lower curves of airfoil
    upper_points = [for (i = [0:airfoil_resolution]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [airfoil_resolution:-1:0]) 
        let(
            t = i / airfoil_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * lift_efficiency * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments
    for (i = [0:blade_segments-1]) {
        // Position along blade
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position (non-linear taper for better efficiency)
        chord1 = blade_chord_root * (1 - t * (1 - blade_chord_tip/blade_chord_root) * pow(t, tip_taper_factor));
        chord2 = blade_chord_root * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_root) * pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip)
        thickness1 = blade_max_thickness * (1 - 0.7 * t);
        thickness2 = blade_max_thickness * (1 - 0.7 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_section(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/4, d1 = hub_diameter, d2 = hub_diameter * 0.7, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/4, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_root * 0.6);
            
            translate([blade_root_offset - blade_chord_root * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_root * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

                Example ID: unknown_9af337fa
                Score: 0.507
                Description: I want a drone propeller with 4 blades, each of it with 6 inches and diameter of 9 inches
                Code:
                ```scad
                //pitch (inches)
PitchI = 6;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 4;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_fdda84c1
                Score: 0.504
                Description: Parametric drone propeller with multiple blades
                Code:
                ```scad
                //Multipropv6-ThgV.scad
//A parametric generator for multiblade propellors.

// Created by Hamish Trolove - Feb 2019
//www.techmonkeybusiness.com

//Licensed under a Creative Commons license - attribution
// share alike. CC-BY-SA

//No extra libraries are required and it works under
//OpenSCAD 2015 and later.  This script will not work
//for older versions of OpenSCAD

//Airfoils:
// Points from naca4412.dat in the archive: http://m-selig.ae.illinois.edu/ads/archives/coord_seligFmt.tar.gz
// Not necessarily in the same order as in: http://m-selig.ae.illinois.edu/ads/coord/naca4412.dat

//pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//Number of blades
BladeNo = 5;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 10;

//Resolution steps between stations
SectRes = 10;

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Motor shaft size
PropShftD = 5;

//Propellor hub diameter
PropHubD = 10;

//Imaginary diameter for guiding hub cone angle
PropHubDCutterMax = 14;

//Propellor hub thickness
PropHubT = 5;

//Hub pin option (if left as 0, then this option will be ignored)
//Diameter of Hub Pins (Option)
HubPinD = 0;

//Pitch Circle Diameter of Hub Pins (Option)
HubPinPCD = 0;


 //Holder variables for calculated Blade section parameters
Poz1 =0;  //Ignore me
Poz2 = 0;  //Ignore me
StrtAngi = 0;  //Ignore me
EndAngi = 0;  //Ignore me
StepLi = 0;  //Ignore me
StrtWi = 0;  //Ignore me
EndWi = 0;   //Ignore me


// Blade airfoil profile.  Replace this as needed.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];

//The following blade width shape is a function taken from an existing blade.
//It should be varied with other functions to suit the needs to the user.
//The variable is a ratio of the position along the blade length.
function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

//Number of steps in the Stub section /This will be calculated for 1/6th of
//blade length or 1.5 * Hub diameter, whichever is bigger
StubSteps = (Diam/(12*SectL)>PropHubD*1.5)?round(Diam/(12*SectL)):round(PropHubD*1.5/SectL);

BldStubLn = 0.98*StubSteps * SectL;  //The length of the hub section of blade 
//To ensure a manifold join we will reduce the stub length a tiny amount

//Function to adjust the pitch angle to match manufactured blades (which are flatter)
function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,0,-0.25*PropHubT])cylinder (r = PropHubD/2, h = 1.5*PropHubT, center = true, $fn = 100);
}

module Hubcutter()
{
    union()
    {
        cylinder (r = PropShftD/2, h = PropHubT*1.5, center = true, $fn = 100);
        translate([0,0,-1.5*PropHubT])cylinder (r2 = PropHubD/2, r1 = 0.5*PropHubDCutterMax, h = 2*PropHubT, center = true, $fn = 100);
        
        //Hub pin option.  If the HubPinD and HubPinPCD parameters
        //Are zero, the option will be ignored.
        if(HubPinD > 0 && HubPinPCD > 0)
        {
            translate([0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
            translate([-0.5*HubPinPCD,0,0])cylinder(r = 0.5*HubPinD, h = PropHubT*1.5, center = true, $fn = 100);
        }
    }
}

module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
//Parameters being parsed are Start Angle, End Angle, The height of the section
// the start chord length and the end chord length.
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    //Step through the sections defined by the number of stations and 
    //Add a section of blade profile.
    union()
    {
    for(i = [0:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module CoreBit()
{
    //To strengthen the rotor core we'll use a stub of blade and 
    //the section of the hub to create a hull shape that should
   //merge it tidily.
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*BldStubLn/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        StrtAngi = PitchAngAdj(0.5*PropHubD);
        EndAngi = atan(Pitch/(2*PI*BldStubLn))*PitchAngAdj(BldStubLn);
        
        difference()
        {
        rotate([90,0,0])Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);
            union(){
            //Add some cutters to trim the blade stub to make a tidier merge for
            //small numbers of blades.
                rotate([0,0,15])
                translate([0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);
                
                rotate([0,0,-15])
                translate([-0.5*(PropHubD+EndWi),-0.5*BldStubLn,0])
                cube([EndWi,BldStubLn,EndWi],center = true);   
            }
        }
    }
}



difference()
{
    union()
    {
        
        for(N = [0:BladeNo-1])
        {
            rotate([90,0,N*360/BladeNo])BladeBuilder();
             rotate([0,0,N*360/BladeNo])CoreBit();
        }
    }
    Hubcutter();
}
                ```
                

                Example ID: unknown_7ae6d851
                Score: 0.467
                Description: I want a blade of a drone propeller
                Code:
                ```scad
                //pitch (inches)
PitchI = 4.5;

//diameter (inches)
DiamI = 9;

//pitch (mm)
PitchM = 0;

//diameter (mm)
DiamM = 0;

//Maximum chord length (mm)
MaxChdW = 19;

//No of stations along blade
Statns = 12;

//Resolution steps between stations
SectRes = 10;  

Pitch = (PitchM > 0)? (PitchM):(PitchI * 25.4);  //Turn pitch values into metric
Diam = (DiamM > 0)? (DiamM):(DiamI * 25.4);  //Turn pitch values into metric

//Pitch adjustment factor hub end
PitchAdjHub = 1;

//Pitch adjustment factor tip end
PitchAdjTip = 1;

//Position of blade centreline on chord (%)
BldCtr = 35;

//Spinner hinge radius at pin
SpinHPinRad = 34;

//Diameter of hinge pin
SpinPinD = 3;

//Blade base diameter
SpinHubD = 6;

//Spinner hinge width
SpinHL = 7;

//Hinge Pin Height Adjuster
SpinHubVTweak = 0.25;

//Holder variables for calculated Blade section parameters.  Ignore these.
Poz1 =0;
Poz2 = 0;
StrtAngi = 0;
EndAngi = 0;
StepLi = 0;
StrtWi = 0;
EndWi = 0; 


// Blade airfoil profile. Change with caution.
Airfoil_points = [[1000,1.3],[950,14.7],[900,27.1],[800,48.9],[700,66.9],[600,81.4],[500,91.9],[400,98],[300,97.6],[250,94.1],[200,88],[150,78.9],[100,65.9],[75,57.6],[50,47.3],[25,33.9],[12.5,24.4],[0,0],[12.5,-14.3],[25,-19.5],[50,-24.9],[75,-27.4],[100,-28.6],[150,-28.8],[200,-27.4],[250,-25],[300,-22.6],[400,-18],[500,-14],[600,-10],[700,-6.5],[800,-3.9],[900,-2.2],[950,-1.6],[1000,-1.3]];


function BldChrdLen(x) = 1.392*pow(x,4) -1.570*pow(x,3)-2.46*pow(x,2)+3.012*x+0.215;

SectL =  Diam/(2*Statns);  //Length of each section

StubSteps = (Diam/(16*SectL)>SpinHPinRad*1.2)?round(Diam/(16*SectL)):round(SpinHubD*1.1/SectL);

BldStubLn = 0.98*StubSteps * SectL; 
BldStrtPoint = round((SpinHPinRad+BldStubLn+0.5*SpinHubD)/SectL)-1;

function PitchAngAdj(x) = 2*(PitchAdjTip-PitchAdjHub)/Diam*x+PitchAdjHub;


module hub()
{
    translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
    rotate([0,90,0])
    cylinder (r =0.5*SpinHubD, h = SpinHL, center = true, $fn = 100);
}



module Hubcutter()
{
    union()
    {
        // Pin hole
        translate([0,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r = 0.5*SpinPinD, h = SpinHL*4, center = true, $fn = 100);
        
        //The two face shavers
        translate([1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 0.6*SpinHubD, r2 = 2.5*SpinHubD, h = SpinHL*2, center = true, $fn = 100);
        
        translate([-1.5*SpinHL,-SpinHPinRad,-SpinHubVTweak*SpinHubD])
        rotate([0,90,0])
        cylinder (r1 = 5*SpinHubD, r2 = 0.6*SpinHubD, h = SpinHL*2, center = true, $fn = 100);        

    }
}


module Bladeprofile(StrtAng, EndAng, StepL, StrtW, EndW)
{
    echo(StrtAng, EndAng, StepL, StrtW, EndW);
    linear_extrude(height=StepL, scale=EndW/StrtW,twist = EndAng - StrtAng, slices = SectRes)
     rotate([0,0,-StrtAng])  //Position angle
     translate([-BldCtr/100*StrtW,0])  //shift profile to position airfoil centreline
     scale(StrtW) //Base Scale at start
     scale (0.001) polygon(points=Airfoil_points); //Scale profile to unit size)
    
}

module BladeBuilder()
{
    union()
    {
    for(i = [BldStrtPoint:Statns-1])
        {
            //calculate the position start and end variables
            // for the particular section
            Poz1 = i*SectL; 
            Poz2 = (i+1)*SectL;
            
            //calculate the chord lengths at the two positions
            StrtWi = BldChrdLen(2*Poz1/Diam)*MaxChdW;
            EndWi = BldChrdLen(2*Poz2/Diam)*MaxChdW;
            
            //calculate the blade angles at the two positions
            StrtAngi = atan(Pitch/(2*PI*Poz1))*PitchAngAdj(Poz1);
            EndAngi = atan(Pitch/(2*PI*Poz2))*PitchAngAdj(Poz2);
            
            translate([0,0,Poz1])Bladeprofile(StrtAngi, EndAngi,SectL,StrtWi, EndWi);
           
            
        }
    }
}

module Hinge()
{
    hull()
    {
       hub();
       //Blade stub - Width to merge with main blade
       EndWi = BldChrdLen(2*(SpinHPinRad+BldStubLn+0.5*SpinHubD)/Diam)*MaxChdW;
       
        //Blade stub angles and twist.
        EndAngi = atan(Pitch/(2*PI*(SpinHPinRad+BldStubLn+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+BldStubLn+0.5*SpinHubD);
        StrtAngi = atan(Pitch/(2*PI*(SpinHPinRad+0.5*SpinHubD)))*PitchAngAdj(SpinHPinRad+0.5*SpinHubD);
        

            translate([0,-SpinHPinRad-0.5*SpinHubD,0])        
            rotate([90,0,0])
            Bladeprofile(StrtAngi, EndAngi, BldStubLn, EndWi, EndWi);

    }
}


translate([0,SpinHPinRad,0])
difference()
{
    union()
    {
        Hinge();
        rotate([90,0,0])BladeBuilder();
    }
    Hubcutter();
}
                ```
                

                Example ID: modular_8bed98a0
                Score: 0.505
                Description: I want a propeller of a drone
                Code:
                ```scad
                // Drone Propeller - Parametric OpenSCAD Model
// This model creates an aerodynamic drone propeller with customizable parameters

// ======== CUSTOMIZABLE PARAMETERS ========
// Basic dimensions
prop_diameter = 127;    // Propeller diameter in mm (5 inches)
hub_diameter = 12;      // Hub diameter in mm
hub_height = 6;         // Hub height in mm
shaft_diameter = 5;     // Motor shaft diameter in mm (M5)
num_blades = 2;         // Number of blades

// Blade parameters
blade_chord_max = 14;   // Maximum width of blade in mm
blade_chord_tip = 5;    // Width at blade tip in mm
blade_thickness = 2.5;  // Maximum thickness at blade root in mm
pitch_angle = 15;       // Base pitch angle (degrees)
twist_angle = 12;       // Additional twist from root to tip (degrees)
airfoil_camber = 0.05;  // Airfoil camber ratio (0.0-0.1 recommended)

// Performance tuning
tip_taper_factor = 0.7; // Controls how blade width decreases toward tip (0.5-1.0)
efficiency_factor = 1.2;// Multiplier for airfoil lift curve (1.0-1.5)

// Resolution settings
$fn = 80;               // Overall resolution for curved surfaces
blade_segments = 18;    // Number of segments along blade length
profile_resolution = 24;// Number of points in airfoil cross-section

// ======== DERIVED VARIABLES ========
blade_length = (prop_diameter - hub_diameter) / 2;
blade_root_offset = hub_diameter / 2;

// ======== MODULES ========

// Generate an airfoil cross-section profile
module airfoil_profile(chord, thickness, camber, angle) {
    // Create upper and lower curves of the airfoil
    upper_points = [for (i = [0:profile_resolution]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc + thick]
    ];
    
    lower_points = [for (i = [profile_resolution:-1:0]) 
        let(
            t = i / profile_resolution,
            x = chord * (1 - cos(t * 180)),
            // NACA-inspired thickness distribution
            thick = thickness * (0.2969 * sqrt(x/chord) - 
                    0.1260 * (x/chord) - 0.3516 * pow(x/chord, 2) + 
                    0.2843 * pow(x/chord, 3) - 0.1015 * pow(x/chord, 4)),
            // Camber line
            yc = camber * efficiency_factor * chord * sin(t * 180)
        )
        [x, yc - thick]
    ];
    
    // Combine upper and lower curves and rotate to the specified angle
    rotate([0, 0, angle])
        polygon(points = concat(upper_points, lower_points));
}

// Generate a single propeller blade
module blade() {
    // Create blade segments with varying properties from root to tip
    for (i = [0:blade_segments-1]) {
        // Position along blade (normalized 0-1)
        t = i / blade_segments;
        z1 = t * blade_length;
        z2 = (i + 1) / blade_segments * blade_length;
        
        // Calculate chord length at each position with non-linear taper
        chord1 = blade_chord_max * (1 - t * (1 - blade_chord_tip/blade_chord_max) * pow(t, tip_taper_factor));
        chord2 = blade_chord_max * (1 - (i+1)/blade_segments * (1 - blade_chord_tip/blade_chord_max) * 
                 pow((i+1)/blade_segments, tip_taper_factor));
        
        // Calculate thickness (thinner toward tip for better dynamics)
        thickness1 = blade_thickness * (1 - 0.6 * t);
        thickness2 = blade_thickness * (1 - 0.6 * ((i+1)/blade_segments));
        
        // Calculate twist angle (non-linear distribution for optimal thrust)
        angle1 = pitch_angle + twist_angle * (1 - pow(1 - t, 1.5));
        angle2 = pitch_angle + twist_angle * (1 - pow(1 - (i+1)/blade_segments, 1.5));
        
        // Create segment by connecting profiles at z1 and z2
        hull() {
            translate([blade_root_offset + z1, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord1, thickness1, airfoil_camber, angle1);
            
            translate([blade_root_offset + z2, 0, 0])
                linear_extrude(height = 0.01)
                    airfoil_profile(chord2, thickness2, airfoil_camber, angle2);
        }
    }
}

// Hub with motor shaft mounting hole
module hub() {
    difference() {
        union() {
            // Main hub cylinder
            cylinder(h = hub_height, d = hub_diameter, center = true);
            
            // Hub reinforcement at base
            translate([0, 0, -hub_height/2])
                cylinder(h = hub_height/4, d1 = hub_diameter * 1.2, d2 = hub_diameter, center = false);
            
            // Top cap with aerodynamic shape
            translate([0, 0, hub_height/2 - 0.01])
                cylinder(h = hub_height/3, d1 = hub_diameter, d2 = hub_diameter * 0.6, center = false);
        }
        
        // Shaft hole
        cylinder(h = hub_height * 1.5, d = shaft_diameter, center = true);
        
        // Set screw hole
        translate([0, hub_diameter/3, 0])
            rotate([90, 0, 0])
                cylinder(h = hub_diameter, d = shaft_diameter * 0.6, center = true);
    }
}

// Create smooth transition from hub to blade
module blade_root_transition(angle) {
    rotate([0, 0, angle]) {
        // Create a fillet between hub and blade root for structural integrity
        hull() {
            translate([blade_root_offset, 0, -hub_height/4])
                cylinder(h = 0.1, d = blade_chord_max * 0.6);
            
            translate([blade_root_offset - blade_chord_max * 0.1, 0, -hub_height/2])
                cylinder(h = 0.1, d = blade_chord_max * 0.3);
                
            translate([0, 0, -hub_height/2])
                cylinder(h = 0.1, d = hub_diameter);
        }
    }
}

// Complete propeller assembly
module propeller() {
    // Central hub
    hub();
    
    // Blades with transitions
    for (i = [0:num_blades-1]) {
        rotate([0, 0, i * 360 / num_blades]) {
            // Main blade
            blade();
            
            // Root transition for structural integrity
            blade_root_transition(0);
        }
    }
}

// Generate the propeller
propeller();
                ```
                

STEP-BACK ANALYSIS:
CORE PRINCIPLES:
                    - Aerodynamic efficiency to maximize lift while minimizing power consumption
- Structural integrity to withstand high rotational forces and mechanical stress
- Weight optimization to balance strength and performance requirements
- Pitch angle design for appropriate thrust generation
- Symmetry and balance for stable rotation at high RPM
- Material selection compatible with 3D printing constraints
- Code Structure: module structure
- Code Structure: algorithms for aerodynamic simulation
- Implementation Technique: minkowski
- Implementation Technique: rotate
- Implementation Technique: scale
- Implementation Technique: mirror
- Implementation Technique: union
                    
                    SHAPE COMPONENTS:
                    - Hub section with mounting hole for motor shaft connection
- Airfoil-shaped blades with optimized cross-section
- Leading edge with appropriate curvature for air intake
- Trailing edge with thinning profile for reduced drag
- Blade root reinforcement for structural stability
- Tip design to minimize vortex formation and noise
- Surface finish considerations for reduced drag
                    
                    IMPLEMENTATION STEPS:
                    1. Determine propeller specifications (diameter, pitch, number of blades) based on quadcopter requirements
2. Create the central hub with appropriate mounting hole diameter and depth
3. Design the airfoil cross-section profile with proper lift-to-drag ratio
4. Model the blade with gradual twist from root to tip to maintain optimal angle of attack
5. Add fillets and reinforcements at blade-hub junction to prevent stress concentration
6. Optimize blade thickness distribution for strength while minimizing weight
7. Perform static structural analysis to verify integrity under expected loads
8. Conduct aerodynamic simulation to validate thrust performance
9. Adjust design based on simulation results
10. Prepare model for 3D printing with appropriate tolerances and support structures

TEMPLATE SUGGESTION:

                SUGGESTED TEMPLATE:
                The object appears to be a "mechanical" type. Here's a suggested structure:
                
                ```scad
                
        module propeller(height=10, width=20, depth=15, wall_thickness=2) {
            union() {
                // Base shape based on: Hub section with mounting hole for motor shaft connection, Airfoil-shaped blades with optimized cross-section, Leading edge with appropriate curvature for air intake, Trailing edge with thinning profile for reduced drag, Blade root reinforcement for structural stability, Tip design to minimize vortex formation and noise, Surface finish considerations for reduced drag
                // Add your code here
            }
        }
    
                ```
                
                AVAILABLE TEMPLATES:
- container: For container-type objects
- mechanical: For mechanical-type objects
- furniture: For furniture-type objects
- decorative: For decorative-type objects
- tableware: For tableware-type objects
- architectural: For architectural-type objects
- organizer: For organizer-type objects
- electronic: For electronic-type objects
- instrument: For instrument-type objects
- jewelry: For jewelry-type objects
- utility: For utility-type objects
- toy: For toy-type objects
- enclosure: For enclosure-type objects
- fixture: For fixture-type objects
- modular: For modular-type objects

                
                Feel free to use this template as a starting point and modify it as needed.
                

PARAMETER SUGGESTIONS:
SUGGESTED PARAMETERS:
prop_diameter = 127; // Total diameter of the propeller in mm (typical quadcopter props range from 3-10 inches)
num_blades = 2; // Number of propeller blades (quadcopters typically use 2-4 blades)
hub_diameter = 10; // Diameter of the central hub in mm that connects to the motor
shaft_diameter = 5; // Diameter of the motor shaft hole in mm (common sizes: 3mm, 5mm)
pitch_angle = 15; // Base pitch angle in degrees (affects thrust and efficiency)
blade_chord_max = 14; // Maximum width of blade at its widest point in mm
blade_thickness = 2.5; // Maximum thickness of the blade in mm
propeller_diameter = 127; // The total diameter of the propeller in mm (typical 5-inch quadcopter propeller)
blade_count = 2; // Number of blades on the propeller (2-blade is standard, but 3 or more can be used)
propeller_pitch = 76.2; // The theoretical forward distance traveled in one rotation in mm (commonly expressed as a 5x3 prop where 3 is the pitch in inches)
shaft_hole_diameter = 5; // Diameter of the center mounting hole in mm for the motor shaft
airfoil_thickness = 1.5; // Maximum thickness of the blade's airfoil profile in mm


WEB CONTENT AND REFERENCE INFORMATION:
Here is relevant information from web searches:

Title: [PDF] Bladed Propeller Designs for Static Quadcopter Applications
Content: The design of propellers to be 3D printed for this application provided unique challenges due to the requirements of fine surface quality, structural rigidity
---

Title: [PDF] Design and Analysis of 3D Printed Quadrotor Frame - iarjset
Content: The frame is designed to accommodate 5040 propellers and Emax- RS2205 2300kv brushless DC motors on the arm. Fig 1.b) Quadrotor frame assembly in exploded view.
---

Title: Design and modal analysis of a Quadcopter propeller through finite ...
Content: Propellers provide thrust force to the Quadcopter, all the pressure and body weight have to be balanced by the thrust force generated by the propellers.
---

Title: Prediction of Printing Failure of a 3D Printed Drone Propeller using ...
Content: A 3D printed propeller seems to suffer from higher material strain than the conventionally manufactured propeller [16] , questioning its feasibility to
---

Title: nano quad propeller 3d models - STLFinder
Content: The specifications for this personalized design include a prop shaft height of 100, prop shaft radius of 3, a name plate top with the text "Nano Lab", font
---


USER REQUEST:
propeller of a quadcopter

Please generate OpenSCAD code that satisfies the user's request. Follow these guidelines:
1. Use clear variable names and comments
2. Break down complex shapes into modules 
3. Use proper indentation and formatting
4. Include helpful comments explaining the code
5. Make the design parametric where appropriate (using variables for key dimensions)
6. Implement the design following the step-back analysis principles
7. Use techniques from relevant examples when applicable
8. Consider the suggested template structure if it's appropriate for this design

CRITICAL INSTRUCTIONS:
- Your response must ONLY contain the OpenSCAD code and NOTHING else
- Do NOT include any explanations, questions, or other text outside the code block
- Do NOT ask for clarification - implement the best solution based on the information provided
- ALWAYS enclose your code in triple backtick code blocks with the scad tag, like this:

```scad
// Your code here
```

OpenSCAD code:

================================================================================

